package runtime;

import java.util.*;
import java.lang.reflect.Array;

import util.*;

/**
 * ????????????????
 * ???AbstractAtom???????????????????????????
 * Functor????????Functor????????????Map?????
 * Functor?????????????
 * @author Mizuno
 */
final class AtomSet implements Set{
	/** atoms?????????????? */
	private int size = 0;
	/** ŽÀ??????????????? */
	private Map atoms = new HashMap();

	/** ??????? */	
	public int size() {
		return size;
	}
	/** ???true */
	public boolean isEmpty() {
		return size == 0;
	}
	/** ????????????????true? */
	public boolean contains(Object o) {
		Functor f = ((Atom)o).getFunctor();
		Set s = (Set)atoms.get(f);
		if (s == null) {
			return false;
		} else {
			return s.contains(o);
		}
	}
	/**
	 * ?????Functor???????????
	 * ??????????????????
	 * ???????add/remove??????????
	 */	
	public Set getAtomsOfFunctor(Functor f) {
		Set s = (Set)atoms.get(f);
		if (s == null) {
			return new HashSet();
		} else {
			return s;
		}
	}
	/** ???????????????? */
	public Iterator iterator() {
		return new AtomIterator(atoms);
	}
	/** ???????????????????? */
	public Iterator iteratorOfFunctor(Functor functor) {
		Set s = (Set)atoms.get(functor);
		if (s == null) {
			return Util.NULL_ITERATOR;
		} else {
			return s.iterator();
		}
	}
	/** 
	 * Functor????????
	 * ??????????Functor???????????????????
	 * ???????????Functor??????????????????????
	 */
	public Iterator functorIterator() {
		return atoms.keySet().iterator();
	}
	/**
	 * ????????????????????????
	 * ???????ŽÀ?????AbstractAtom[]???
	 */
	public Object[] toArray() {
		Object[] ret = new Atom[size];
		int index = 0;
		Iterator it = iterator();
		while (it.hasNext()) {
			ret[index++] = it.next();
		}
		if (index != size) {
			System.err.println("SYSTEM ERROR!: AtomSet.size is incorrect");
		}
		return ret;
	}
	/**
	 * ????????????????????????
	 * ???????ŽÀ???????????????ŽÀ??????????
	 */
	public Object[] toArray(Object[] a) {
		if (a.length > size) {
			a = (Object[])Array.newInstance(a.getClass(), size);
		}
		int index = 0;
		Iterator it = iterator();
		while (it.hasNext()) {
			a[index++] = it.next();
		}
		while (index < size) {
			a[index++] = null;
		}
		return a;
	}
	/**
	 * ??????????????
	 * @return ?????????true
	 */
	public boolean add(Object o) {
		Functor f = ((Atom)o).getFunctor();
		Set s = (Set)atoms.get(f);
		if (s == null) {
			s = new HashSet();
			s.add(o);
			atoms.put(f, s);
			size++;
			return true;
		} else if (s.add(o)) {
			size++;
			return true;
		} else {
			return false;
		}
	}
	/**
	 * ???????????????
	 * @return ?????????true
	 */
	public boolean remove(Object o) {
		Functor f = ((Atom)o).getFunctor();
		Set s = (Set)atoms.get(f);
		if (s == null) {
			return false;
		} else if (s.remove(o)) {
			size--;
			return true;
		} else {
			return false;
		}
	}
	/**
	 * ?????????????????????????true????
	 * ????????ŽÀ??????????????????? 
	 */
	public boolean containsAll(Collection c) {
		Iterator it = c.iterator();
		while (it.hasNext()) {
			if (contains(it.next()) == false) {
				return false;
			}
		}
		return true;
	}
	/**
	 * ???????????????????????????
	 * ????????ŽÀ??????????????????? 
	 * @return ?????????true
	 */
	public boolean addAll(Collection c) {
		boolean ret = false;
		Iterator it = c.iterator();
		while (it.hasNext()) {
			if (add(it.next())) {
				size++;
				ret = true;
			}
		}
		return ret;
	}
	/**
	 * ??????????????????????????
	 * ????????ŽÀ??????????????????? 
	 * @return ?????????true
	 */
	public boolean removeAll(Collection c) {
		boolean ret = false;
		Iterator it = c.iterator();
		while (it.hasNext()) {
			if (remove(it.next())) {
				size--;
				ret = true;
			}
		}
		return ret;
	}
	/** ??????? */
	public boolean retainAll(Collection c) {
		throw new UnsupportedOperationException();
	}
	/** ???????? */
	public void clear() {
		atoms.clear();
		size = 0;
	}
}
/** AtomSet?????????????? */
final class AtomIterator implements Iterator {
	/** Functor???????????Set??????Map */
	Map atoms;
	/** ??Functor??????????? */
	Iterator atomSetIterator;
	/** ??Functor??????????????? */
	Iterator atomIterator;

	/** ?????Map???????????????????? */
	AtomIterator(Map atoms) {
		this.atoms = atoms;
		atomSetIterator = atoms.values().iterator();
		if (atomSetIterator.hasNext()) {
			atomIterator = ((Set)atomSetIterator.next()).iterator();
		} else {
			atomIterator = Util.NULL_ITERATOR;
		}
	}
	public boolean hasNext() {
		while (atomIterator.hasNext() == false) {
			if (atomSetIterator.hasNext() == false) {
				return false;
			}
			atomIterator = ((Set)atomSetIterator.next()).iterator();
		}
		return true;
	}
	public Object next() {
		while (atomIterator.hasNext() == false) {
			// ????????????NoSuchElementException?????
			atomIterator = ((Set)atomSetIterator.next()).iterator();
		}
		return atomIterator.next();
	}
	/** ??????????UnsupportedOperationException???? */
	public void remove() {
		throw new UnsupportedOperationException();
	}
}
