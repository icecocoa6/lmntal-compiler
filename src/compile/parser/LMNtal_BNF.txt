/**
 * LMNtalソースファイル =(1)=> 解析木 =(2)=> 意味解析 =(3)=> ルールオブジェクト
 * (1) 構文解析器
 *   @ ソースファイルをそのままJavaのオブジェクトへと変換する。
 *     compile.parser.*
 *   @ JFlex, Java CUPを使用
 *     JFlex (http://jflex.de/) Ver 1.4 pre5
 *         ant flex_compile
 *     Java CUP (http://www.cs.princeton.edu/~appel/modern/java/CUP/) Ver 0.10k
 *         ant bison_compile
 *   @ 簡略記法も対応する
 *   @ ルールでしか出現しないもの(RuleContext)がデータ部分に出ている
 *     ようなことはチェックしていない
 *      P と T の区別はしていない
 *
 * (2) 意味解析器
 *   @ compile.struture.*
 *   @ リンクの貼り付け
 *   @ アトム中のアトムなどの簡略記法を展開する
 *   @ 膜を通過するリンクのプロキシーを生成する
 * 
 * (3) ルールコンパイラー (compile.RuleCompiler)
 *   @ プログラム中のルール部分をルールオブジェクトに変換する
 *     compile.Rule
 * 
 *
 * <LMNtalの構文>
 * P ::= 0 | p(X1, ... ,Xm) | P, P | { P } | (T :- G | T)
 * T ::= 0 | p(X1, ... ,Xm) | T, T | { T } | (T :- G | T)
 *     | @p | $p[X1, ... ,Xm|A] | p(*X1, ... , *Xm)
 * A ::= [] | *X
 * G ::= 0 | G, G | \+($p1=(T1), ..., $pn=(Tn))
 * <構文条件>
 * @ プロセスのルール外に同じリンクが2回を越えて出現してはならない
 * @ ルールはルールの左辺またはガードに出現してはならない
 * @ ルールの左辺に出現する @p $p は膜の内側に出現しなければならない
 */

<LinkName>      =   [A-Z][a-zA-Z0-9]*
<AtomName>      =   [a-z0-9][a-zA-Z0-9]*

<Link>          =   <LinkName>

<Atom>          =   <AtomName>
                   | <AtomName> '(' ')'
                   | <AtomName> '(' <ProcessList> ')'

<Membrane>      =   '{' '}'
                  | '{' <ProcessList> '}'

<Rule>          =   '(' <ProcessList> ':-' <ProcessList> ')'
                  | '(' <ProcessList> ':-' <NagateList> <ProcessList> ')' // not supported now

<ProcessCotext> =   '$' <AtomName>

<RuleContext>   =   '@' <AtomName>

<Context>       =   <ProcessContext>
                  | <RuleContext>

<LinkUnify>     = <LinkName> '=' <LinkName>

<Process>       =   <Atom>
                  | <Membrane>
                  | <Rule>
                  | <Context>
                  | <Link>
                  | <LinkUnify>

<ProcessList>   =   <Process>
                  | <ProcessList> ',' <Process>

<LMNtalProg>    =   <ProcessList>
