package compile.parser.intermediate;

import java.util.*;
import runtime.*;
import compile.parser.MySymbol;

parser code {: 
	public static void main(String[] args) throws Exception {
		Lexer lexer = new Lexer(System.in);
		parser parser = new parser(lexer);
		ArrayList list = (ArrayList)parser.parse().value;

		for (int i = 0; i < list.size(); i++) {
			((InterpretedRuleset)list.get(i)).showDetail();
		}
	}

	public void report_error(String message, Object info) {
		System.err.print(message);
		if (info instanceof MySymbol) {
			MySymbol symbol = (MySymbol)info;
			System.err.print(" : Unexpected Token <" + symbol.token + "> at line " + symbol.left);
		}
		System.err.println();
    }
    public void unrecovered_syntax_error(java_cup.runtime.Symbol cur_token) throws Exception {
    	report_fatal_error("Couldn't repair and continue parse", null);
	}
:};


terminal			KW_COMPILED_RULESET, KW_COMPILED_RULE, KW_ATOM_MATCH, KW_MEM_MATCH, KW_GUARD, KW_BODY;
terminal			KW_MODULE;
terminal			INSIDE_PROXY, OUTSIDE_PROXY;
terminal			LBRACKET, RBRACKET, UNDERBAR, COMMA, COLON, LBRACE, RBRACE, DOT;
terminal Integer	RULESET_ID;
terminal String		SQUOTED_STRING, DQUOTED_STRING;
terminal String		INST_NAME;
terminal Integer	LABEL;
terminal Integer	NUMBER;
terminal Double		FLOAT;

non terminal Object[]			File;
non terminal ArrayList			RulesetList;
non terminal InterpretedRuleset	Ruleset;
non terminal ArrayList			RuleList;
non terminal Rule				Rule;
non terminal InstructionList	AtomMatch, MemMatch, Guard, Body;
non terminal InstructionList	InstructionList;
non terminal Instruction		Instruction;
non terminal ArrayList			ArgList, ArgList2;
non terminal Object				Arg;
non terminal Functor			Functor;
non terminal ArrayList			NumberList, NumberList2;
non terminal ArrayList			ModuleList;
non terminal compile.structure.Membrane		Module;
non terminal ArrayList			RuleRefList;

start with File;

File			::=	  RulesetList:rulesets ModuleList:modules
						{: RESULT = new Object[] {rulesets, modules}; :}
					| RulesetList:rulesets
						{: RESULT = new Object[] {rulesets, new ArrayList()}; :};
RulesetList		::=	  Ruleset:rs
						{: ArrayList list = new ArrayList(); list.add(rs); RESULT = list; :}
					| RulesetList:list Ruleset:rs
						{: list.add(rs); RESULT=list; :};
Ruleset			::=	  KW_COMPILED_RULESET RULESET_ID:id RuleList:rules
						{: RESULT = new InterpretedRuleset(id.intValue(), rules); :};
RuleList		::=	  Rule:rule
						{: ArrayList list = new ArrayList(); list.add(rule); RESULT = list; :}
					| RuleList:list Rule:rule
						{: list.add(rule); RESULT = list; :};
Rule			::=	  KW_COMPILED_RULE AtomMatch:atomMatch MemMatch:memMatch Guard:guard Body:body
						{: RESULT = new Rule(atomMatch, memMatch, guard, body); :};
AtomMatch		::=	  KW_ATOM_MATCH InstructionList:list
						{: RESULT = list; :};
MemMatch		::=	  KW_MEM_MATCH InstructionList:list
						{: RESULT = list; :};
Guard			::=	  /*empty*/
						{: RESULT = null; :}
					| KW_GUARD LABEL:label COLON InstructionList:list
						{: list.setLabel(label.intValue()); RESULT = list; :};
Body			::=	  /*empty*/
						{: RESULT = null; :}
					| KW_BODY LABEL:label COLON InstructionList:list
						{: list.setLabel(label.intValue()); RESULT = list; :};
InstructionList	::=   Instruction:inst
						{: InstructionList list = new InstructionList(); list.add(inst); RESULT = list; :}
					| InstructionList:list Instruction:inst
						{: list.add(inst); RESULT = list; :}
					| InstructionList:list COMMA Instruction:inst
						{: list.add(inst); RESULT = list; :};
Instruction		::=	  INST_NAME:name LBRACKET ArgList:args RBRACKET
						{: RESULT = new Instruction(name, args); :};
ArgList			::=	  /*empty*/
						{: RESULT = new ArrayList(); :}
					| ArgList2:list
						{: RESULT = list; :};
ArgList2		::=   Arg:arg
						{: ArrayList list = new ArrayList(); list.add(arg); RESULT = list; :}
					| ArgList2:list COMMA Arg:arg
						{: list.add(arg); RESULT = list; :};
Arg				::=	  NUMBER:num
						{: RESULT = num; :}
					| Functor:func
						{: RESULT = func; :}
					| LBRACKET NumberList:list RBRACKET
						{: RESULT = list; :}
					| LBRACKET InstructionList:list RBRACKET
						{: RESULT = list; :}
					| DQUOTED_STRING:str
						{: RESULT = str; :}
					| RULESET_ID:id
						{: RESULT = new RulesetRef(id); :}
					| LABEL:label
						{: RESULT = new LabelRef(label); :};
Functor			::=	  SQUOTED_STRING:name UNDERBAR NUMBER:arity
						{: RESULT = new Functor(name, arity.intValue()); :}
					| SQUOTED_STRING:path DOT SQUOTED_STRING:name UNDERBAR NUMBER:arity
						{: RESULT = new Functor(name, arity.intValue(), path); :}
					| NUMBER:v UNDERBAR NUMBER:arity
						{: /*assert(arity.intValue()==1);*/ RESULT = new IntegerFunctor(v.intValue()); :}
					| FLOAT:v UNDERBAR NUMBER:arity
						{: /*assert(arity.intValue()==1);*/ RESULT = new FloatingFunctor(v.doubleValue()); :}
					| DQUOTED_STRING:v UNDERBAR NUMBER:arity
						{: /*assert(arity.intValue()==1);*/ RESULT = new StringFunctor(v); :}
					| INSIDE_PROXY
						{: RESULT = Functor.INSIDE_PROXY; :}
					| OUTSIDE_PROXY
						{: RESULT = Functor.OUTSIDE_PROXY; :};
NumberList		::=	  /*empty*/
						{: RESULT = new ArrayList(); :}
					| NumberList2:list
						{: RESULT = list; :};
NumberList2		::=	  NUMBER:v
						{: ArrayList list = new ArrayList(); list.add(v); RESULT = list; :}
					| NumberList2:list COMMA NUMBER:v
						{: list.add(v); RESULT = list; :};
ModuleList		::=	  KW_MODULE
						{: RESULT = new ArrayList(); :}
					| ModuleList:list Module:module
						{: list.add(module); RESULT = list; :};
Module			::=	  SQUOTED_STRING:name LBRACE RuleRefList:rules RBRACE
						{: compile.structure.Membrane mem = new compile.structure.Membrane(null);
						   mem.name = name;
						   mem.rulesets.addAll(rules);
						   RESULT = mem;
						:};
RuleRefList		::=	  /*empty*/
						{: RESULT = new ArrayList(); :}
					| RULESET_ID: ruleset
						{: ArrayList list = new ArrayList(); list.add(ruleset); RESULT=list; :}
					| RuleRefList:list COMMA RULESET_ID:ruleset
						{: list.add(ruleset); RESULT = list; :};
