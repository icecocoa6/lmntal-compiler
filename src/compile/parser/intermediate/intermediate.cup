package compile.parser.intermediate;

import java.util.*;
import runtime.*;
import compile.parser.MySymbol;

parser code {: 
	public static void main(String[] args) throws Exception {
		Lexer lexer = new Lexer(System.in);
		parser parser = new parser(lexer);
		ArrayList list = (ArrayList)parser.parse().value;

		for (int i = 0; i < list.size(); i++) {
			((InterpretedRuleset)list.get(i)).showDetail();
		}
	}

	public void report_error(String message, Object info) {
		System.err.print(message);
		if (info instanceof MySymbol) {
			MySymbol symbol = (MySymbol)info;
			System.err.print(" : Unexpected Token <" + symbol.token + "> at line " + symbol.left);
		}
		System.err.println();
    }
    public void unrecovered_syntax_error(java_cup.runtime.Symbol cur_token) throws Exception {
    	report_fatal_error("Couldn't repair and continue parse", null);
	}
:};


terminal			KW_COMPILED_RULESET, KW_COMPILED_RULE, KW_ATOM_MATCH, KW_MEM_MATCH, KW_GUARD, KW_BODY;
terminal			INSIDE_PROXY, OUTSIDE_PROXY;
terminal			LBRACKET, RBRACKET, UNDERBAR, COMMA, COLON;
terminal Integer	RULESET_ID;
terminal String		SQUOTED_STRING, DQUOTED_STRING;
terminal String		INST_NAME;
terminal Integer	LABEL;
terminal Integer	NUMBER;
terminal Double		FLOAT;

non terminal ArrayList			RulesetList;
non terminal InterpretedRuleset	Ruleset;
non terminal ArrayList			RuleList;
non terminal Rule				Rule;
non terminal InstructionList	AtomMatch, MemMatch, Guard, Body;
non terminal ArrayList			InstructionList;
non terminal Instruction		Instruction;
non terminal ArrayList			ArgList, ArgList2;
non terminal Object				Arg;
non terminal Functor			Functor;
non terminal ArrayList			NumberList, NumberList2;

start with RulesetList;

RulesetList		::=	  Ruleset:rs
						{: ArrayList list = new ArrayList(); list.add(rs); RESULT = list; :}
					| RulesetList:list Ruleset:rs
						{: list.add(rs); RESULT=list; :};
Ruleset			::=	  KW_COMPILED_RULESET RULESET_ID:id RuleList:rules
						{: RESULT = new InterpretedRuleset(id.intValue(), rules); :};
RuleList		::=	  Rule:rule
						{: ArrayList list = new ArrayList(); list.add(rule); RESULT = list; :}
					| RuleList:list Rule:rule
						{: list.add(rule); RESULT = list; :};
Rule			::=	  KW_COMPILED_RULE AtomMatch:atomMatch MemMatch:memMatch Guard:guard Body:body
						{: RESULT = new Rule(atomMatch, memMatch, guard, body); :};
AtomMatch		::=	  KW_ATOM_MATCH InstructionList:list
						{: RESULT = new InstructionList(list); :};
MemMatch		::=	  KW_MEM_MATCH InstructionList:list
						{: RESULT = new InstructionList(list); :};
Guard			::=	  /*empty*/
						{: RESULT = null; :}
					| KW_GUARD LABEL:label COLON InstructionList:list
						{: RESULT = new InstructionList(label.intValue(), list); :};
Body			::=	  /*empty*/
						{: RESULT = null; :}
					| KW_BODY LABEL:label COLON InstructionList:list
						{: RESULT = new InstructionList(label.intValue(), list); :};
InstructionList	::=   Instruction:inst
						{: ArrayList list = new ArrayList(); list.add(inst); RESULT = list; :}
					| InstructionList:list Instruction:inst
						{: list.add(inst); RESULT = list; :};
Instruction		::=	  INST_NAME:name LBRACKET ArgList:args RBRACKET
						{: RESULT = new Instruction(name, args); :};
ArgList			::=	  /*empty*/
						{: RESULT = new ArrayList(); :}
					| ArgList2:list
						{: RESULT = list; :};
ArgList2		::=   Arg:arg
						{: ArrayList list = new ArrayList(); list.add(arg); RESULT = list; :}
					| ArgList2:list COMMA Arg:arg
						{: list.add(arg); RESULT = list; :};
Arg				::=	  NUMBER:num
						{: RESULT = num; :}
					| Functor:func
						{: RESULT = func; :}
					| LBRACKET NumberList:list RBRACKET
						{: RESULT = list; :}
					| LBRACKET InstructionList:list RBRACKET
						{: RESULT = list; :}
					| DQUOTED_STRING:str
						{: RESULT = str; :}
					| RULESET_ID:id
						{: RESULT = new RulesetRef(id); :}
					| LABEL:label
						{: RESULT = new RuleRef(label); :};
Functor			::=	  SQUOTED_STRING:name UNDERBAR NUMBER:arity
						{: RESULT = new Functor(name, arity.intValue()); :}
					| NUMBER:v UNDERBAR NUMBER:arity
						{: /*assert(arity.intValue()==1);*/ RESULT = new IntegerFunctor(v.intValue()); :}
					| FLOAT:v UNDERBAR NUMBER:arity
						{: /*assert(arity.intValue()==1);*/ RESULT = new FloatingFunctor(v.doubleValue()); :}
					| DQUOTED_STRING:v UNDERBAR NUMBER:arity
						{: /*assert(arity.intValue()==1);*/ RESULT = new StringFunctor(v); :}
					| INSIDE_PROXY
						{: RESULT = Functor.INSIDE_PROXY; :}
					| OUTSIDE_PROXY
						{: RESULT = Functor.OUTSIDE_PROXY; :};
NumberList		::=	  /*empty*/
						{: RESULT = new ArrayList(); :}
					| NumberList2:list
						{: RESULT = list; :};
NumberList2		::=	  NUMBER:v
						{: ArrayList list = new ArrayList(); list.add(v); RESULT = list; :}
					| NumberList2:list COMMA NUMBER:v
						{: list.add(v); RESULT = list; :};
