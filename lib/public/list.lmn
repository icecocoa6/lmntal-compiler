/**
NAME
	List module

SYNOPSIS


AUTHOR
	Koji Hara

HISTORY
	2004/05/22(Sat)

*/

{
module(list).

//new : unit -> List
/**
 * list.new(-Res)
 *
 * 空のリストを返します。
 */
H=list.new :- H=[].

/**
 * is_empty(+List, -Res)
 * 
 * Listが空かどうか検査し、空ならばtrue/1を、空でないならfalse/1をResに返します。
 */
H=is_empty([], Return) :- H=[], Return=true.
H=is_empty('.'(Value, Next), Return) :- H='.'(Value, Next), Return=false.

/**
 * unshift(+List, +Obj, -NewList)
 * リストListの先頭にObjを格納し、Resに返します。
 */
H=unshift([], Obj) :- H='.'(Obj, []).
H=unshift('.'(Value, Next), Obj) :- H='.'(Obj, '.'(Value, Next)).

/**
 * shift(+List, -Ret, -NewList)
 *
 * リストListの先頭要素を取り出してRetに返し、NewListに更新されたリストを返します。
 */
H=shift([], Return) :- H=[], Return=nil.
H=shift('.'(Value, Next), Return) :- H=Next, Return=Value.

/**
 * list.append(+List1, +List2, -Res)
 *
 * リストList1の後ろにリストList2を結合したリストをResに返します。
 */
H=list.append([], B) :- H=B.
H=list.append([Value|Next], B) :- H=[Value|list.append(Next, B)].


/**
 * list.of_queue(+Queue, -List)
 * 
 * キューQueueをリストに変換し、Listに返します。
 */
H=list.of_queue(queue.new(Head, Head)) :- H=[].
H=list.of_queue(queue.new(Head, Tail)) :-
	H=[El | list.of_queue(shift(queue.new(Head, Tail), El))].


/**
 * list.grep(+F, +List, -Res):
 *
 * リストListの要素のうちFによってtrueが返るもののみを含むリストをResに返します。
 * @example r=list.grep(f, [1,2,3,4,5]).
 *          H=[f,N] :- N<3 | H=[true, N].
 *          H=[f,N]:-N>=3 | H=[false,N].
 */
H=list.grep(F, List) :- unary(F) | H=grep_s0(list.map(F, List)).
H=grep_s0([ [true, El] | CDR ]) :- H=[El | grep_s0(CDR)].
H=grep_s0([ [false, El] | CDR ]) :- H=grep_s0(CDR), nil(El).
H=grep_s0([]) :- H=[].

//Functor -> List -> List
/**
 * list.map(+F, +List, -Res):
 *
 * FとリストListの各要素との2要素リストからなるリストをResに返します。
 * H=list.map(F, [B1, ..., Bn]) は H=[[F, B1], [F, B2], ..., [F, Bn]]です。
 */
H=list.map(F, List) :- H=list.fold(F, [], List).

//Functor -> Functor -> List -> List
/**
 * list.fold(+F, +I, +List, -Res):
 * 
 * H=list.fold(F, I, [B1, ..., Bn]) は H=[[F, B1], [F, B2], ..., [F, Bn]|I] です。
 */
H=list.fold(F, I, []) :- unary(F), unary(I) | H=I.
H=list.fold(F, I, [CAR|CDR]) :- unary(F), unary(I) | H=[ [F, CAR] | list.fold(F, I, CDR)].

/**
 * unfold
 * 
 * (Seed -> Boolean)
 *  -> (Seed -> Value)
 *  -> (Seed -> NewSeed)
 *  -> Seed
 *  -> (Seed -> TailValue)
 *  -> List
 * 
 * @see Gauche http://www.shiro.dreamhost.com/scheme/gauche/man/gauche-refj_216.html#SEC239
 */
H=list.unfold(P, F, G, Seed, Tailgen) :-
	unary(P),unary(F),unary(G),unary(Seed),unary(Tailgen) |
	H=list.unfold_s0(P, F, G, Seed, Tailgen, [P,Seed]).

H=list.unfold_s0(P, F, G, Seed, Tailgen, true) :-
	unary(P),unary(F),unary(G),unary(Seed),unary(Tailgen) |
	H=[ [F,Seed] | list.unfold_s0(P, F, G, [G,Seed], Tailgen, [P,Seed]) ].

H=list.unfold_s0(P, F, G, Seed, Tailgen, false) :-
	unary(P),unary(F),unary(G),unary(Seed),unary(Tailgen) |
	H=[ [F,Seed] ].

// << Sample of unfold >>
// r=list.unfold(p,f,g,0,f).
// H=[p,N]:-10>N|H=true.
// H=[p,N]:-N=10|H=false.
// H=[g,N]:-M=N+1|H=M.
// H=[f,N]:-H=N.
// ==> r([0,1,2,3,4,5,6,7,8,9,10,11]), @601, @603

// r=list.fold("+", 0, [1,2,3]). (H=[ ["+",A]|B] :- A+B=C | H=C).

/**
 * list.flatten(+List, -Res)
 *
 * @example
 *  r=list.flatten([0,[a,b,c],[["a",["b"],["c","d"]]]])
 *    ==>
 *  r=list.flatten([0,a,b,c,"a","b","c","d"])
 */
H=list.flatten([]) :- H=[].
H=list.flatten([CAR|CDR]) :- unary(CAR) | H=[CAR|list.flatten(CDR)].
H=list.flatten([[CAR|CADR]|CDR]) :- H=list.flatten([CAR|list.append(CADR,CDR)]).
//Res=list.flatten(nil, R) :- Res=R.
//Res=list.flatten(int(N), R) :- Res=cons(int(N), R).
//Res=list.flatten(cons(A, B), R) :- Res=list.flatten(A, list.flatten(B, R)).

/**
 * list.choose_k(+List, +K, -Res)
 *
 * 要素数 n 個のリストListから k 個順不同で取り出す全ての組み合わせをリストにしてResに返す。
 *
 */

//r=choose_k([a, b, c, d, e], 3).
//r=choose_k([b, c], 1).
H=list.choose_k(L, K) :- H=choose_k(L, K).
H=choose_k(L, K) :- ground(L), K=0 | H=[].
H=choose_k([], K) :- int(K) | H=[].
H=choose_k([Hd|R], K) :- K=1 | H=[[Hd]|choose_k(R, K)].

// Hd を選ぶ場合とそうでない場合の全組み合わせをくっつける 
H=choose_k([Hd|Tl], K) :- K>1, ground(Tl) |
H=list.append(dist(Hd, choose_k(Tl, K-1)), choose_k(Tl, K)).

// map (cons A) L
H=dist(A, []) :- ground(A) | H=[].
H=dist(A, [Hd|Tl]) :- ground(A) | H=[[A|Hd]|dist(A, Tl)].


/**
 * list.uniq
 * 
 * List -> List
 * 
 * uniq でないことが書けないので膜の反応終了を条件に not の動作をさせるようにした。
 */
//H=list.uniq(L) :- ground(L) | H={r=list.uniq0(L)}.
//H=list.uniq0([]) :- H=[], fin.
//H={fin, r=R, $p[], @r} :- ground(R) | H=R.
//H=list.uniq0([Hd|Tl]) :- uniq(Hd) | H=[Hd|list.uniq0(Tl)].
//H={HH=list.uniq0([Hd|Tl]), $p[HH,Tl], @r}/ :- ground(Hd) | H={HH=list.uniq0(Tl), $p[HH,Tl], @r}.

/**
 * list.uniq
 * 
 * List -> List
 * 
 * not_uniq を追加したのでこう書ける
 * 現状、uniq() の履歴が共有されてしまう。
 */
H=list.uniq([     ]) :-                H=[                ].
H=list.uniq([Hd|Tl]) :-     uniq(Hd) | H=[Hd|list.uniq(Tl)].
H=list.uniq([Hd|Tl]) :- not_uniq(Hd) | H=    list.uniq(Tl) .

}.
//res = list.flatten(cons(cons(int(1),cons(int(2),int(3))), int(4)), nil).

