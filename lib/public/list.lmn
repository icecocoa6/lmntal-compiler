/**
NAME
	List module

SYNOPSIS


AUTHOR
	Koji Hara

HISTORY
	2004/05/22(Sat)

*/

{
module(list).

/**
 * list.new(-Res)
 *
 * 空のリストを返します。
 * @param -Res 結果(空のリスト)
 */
H=list.new :- H=[].

/**
 * list.is_empty(+List, -Res, -NewList)
 * 
 * Listが空かどうか検査し、空ならばtrue/1を、空でないならfalse/1をResに返します。
 * @param +List リスト
 * @param -Res 空のとき true/1, 空でないとき false/1
 * @param -NewList (変更されていない)リスト
 * @example r=list.is_empty([],R), ret=R ==> r=[], ret=true
 */
H=list.is_empty([], Return) :- H=[], Return=true.
H=list.is_empty('.'(Value, Next), Return) :- H='.'(Value, Next), Return=false.

/**
 * list.unshift(+List, +Obj, -NewList)
 *
 * リストListの先頭にObjを格納します。
 * @param +List リスト
 * @param +Obj 先頭に格納する要素
 * @param -NewList 更新されたリスト
 */
H=list.unshift([], Obj) :- H='.'(Obj, []).
H=list.unshift('.'(Value, Next), Obj) :- H='.'(Obj, '.'(Value, Next)).

/**
 * list.shift(+List, -Ret, -NewList)
 *
 * リストListの先頭要素を取り出します。
 * @param +List リスト
 * @param -Ret 取り出された要素
 * @param -NewList 更新されたリスト
 */
H=list.shift([], Return) :- H=[], Return=nil.
H=list.shift('.'(Value, Next), Return) :- H=Next, Return=Value.

/**
 * list.append(+List1, +List2, -Res)
 *
 * リストList1の後ろにリストList2を結合したリストをResに返します。
 */
H=list.append([], B) :- H=B.
H=list.append([Value|Next], B) :- H=[Value|list.append(Next, B)].


/**
 * list.of_queue(+Queue, -List)
 * 
 * キューQueueをリストに変換し、Listに返します。
 * @see queue
 */
H=list.of_queue(queue.new(Head, Head)) :- H=[].
H=list.of_queue(queue.new(Head, Tail)) :-
	H=[El | list.of_queue(list.shift(queue.new(Head, Tail), El))].


/**
 * list.grep(+F, +List, -Res):
 *
 * リストListの要素のうちFによってtrueが返るもののみを含むリストをResに返します。
 * @example r=list.grep(f, [1,2,3,4,5]).
 *          H=[f,N] :- N<3 | H=[true, N].
 *          H=[f,N]:-N>=3 | H=[false,N].
 */
H=list.grep(F, List) :- unary(F) | H=list.grep_s0(list.map(F, List)).
H=list.grep_s0([ [true, El] | CDR ]) :- H=[El | list.grep_s0(CDR)].
H=list.grep_s0([ [false, El] | CDR ]) :- H=list.grep_s0(CDR), nil(El).
H=list.grep_s0([]) :- H=[].

/**
 * list.map(+F, +List, -Res):
 *
 * FとリストListの各要素との2要素リストからなるリストをResに返します。
 * H=list.map(F, [B1, ..., Bn]) は H=[[F, B1], [F, B2], ..., [F, Bn]]です。
 */
H=list.map(F, List) :- H=list.fold(F, [], List).

/**
 * list.fold(+F, +I, +List, -Res):
 * 
 * H=list.fold(F, I, [B1, ..., Bn]) は H=[[F, B1], [F, B2], ..., [F, Bn]|I] です。
 * @example r=list.fold("+", 0, [1,2,3]). (H=[ ["+",A]|B] :- A+B=C | H=C).
 */
H=list.fold(F, I, []) :- unary(F), unary(I) | H=I.
H=list.fold(F, I, [CAR|CDR]) :- unary(F), unary(I) | H=[ [F, CAR] | list.fold(F, I, CDR)].

/**
 * list.unfold
 * 
 * (Seed -> Boolean)
 *  -> (Seed -> Value)
 *  -> (Seed -> NewSeed)
 *  -> Seed
 *  -> (Seed -> TailValue)
 *  -> List
 * 
 * @example
 * r=list.unfold(p,f,g,0,f).
 * H=[p,N]:-10>N|H=true.
 * H=[p,N]:-N=10|H=false.
 * H=[g,N]:-M=N+1|H=M.
 * H=[f,N]:-H=N.
 * ==> r([0,1,2,3,4,5,6,7,8,9,10,11])
 * @see Gauche http://www.shiro.dreamhost.com/scheme/gauche/man/gauche-refj_216.html#SEC239
 */
H=list.unfold(P, F, G, Seed, Tailgen) :-
	unary(P),unary(F),unary(G),unary(Seed),unary(Tailgen) |
	H=list.unfold_s0(P, F, G, Seed, Tailgen, [P,Seed]).
H=list.unfold_s0(P, F, G, Seed, Tailgen, true) :-
	unary(P),unary(F),unary(G),unary(Seed),unary(Tailgen) |
	H=[ [F,Seed] | list.unfold_s0(P, F, G, [G,Seed], Tailgen, [P,Seed]) ].
H=list.unfold_s0(P, F, G, Seed, Tailgen, false) :-
	unary(P),unary(F),unary(G),unary(Seed),unary(Tailgen) |
	H=[ [F,Seed] ].

/**
 * list.flatten(+List, -Res)
 *
 * @example
 *  r=list.flatten([0,[a,b,c],[["a",["b"],["c","d"]]]])
 *    ==>
 *  r=list.flatten([0,a,b,c,"a","b","c","d"])
 */
H=list.flatten([]) :- H=[].
H=list.flatten([CAR|CDR]) :- unary(CAR) | H=[CAR|list.flatten(CDR)].
H=list.flatten([[CAR|CADR]|CDR]) :- H=list.flatten([CAR|list.append(CADR,CDR)]).
//Res=list.flatten(nil, R) :- Res=R.
//Res=list.flatten(int(N), R) :- Res=cons(int(N), R).
//Res=list.flatten(cons(A, B), R) :- Res=list.flatten(A, list.flatten(B, R)).

/**
 * list.choose_k(+List, +K, -Res)
 *
 * 要素数 n 個のリストListから k 個順不同で取り出す全ての組み合わせをリストにしてResに返す。
 *
 * @example
 * r=choose_k([a, b, c, d, e], 3).
 * r=choose_k([b, c], 1).
 */
//H=list.choose_k(L, K) :- H=choose_k(L, K).
H=list.choose_k(L, K) :- ground(L), K=0 | H=[].
H=list.choose_k([], K) :- int(K) | H=[].
H=list.choose_k([Hd|R], K) :- K=1 | H=[[Hd]|list.choose_k(R, K)].

// Hd を選ぶ場合とそうでない場合の全組み合わせをくっつける 
H=list.choose_k([Hd|Tl], K) :- K>1, ground(Tl) |
H=list.append(list.dist(Hd, list.choose_k(Tl, K-1)), list.choose_k(Tl, K)).

// map (cons A) L
H=list.dist(A, []) :- ground(A) | H=[].
H=list.dist(A, [Hd|Tl]) :- ground(A) | H=[[A|Hd]|list.dist(A, Tl)].

/**
 * list.uniq
 * 
 * List -> List
 * 
 * uniq でないことが書けないので膜の反応終了を条件に not の動作をさせるようにした。
 */
//H=list.uniq(L) :- ground(L) | H={r=list.uniq0(L)}.
//H=list.uniq0([]) :- H=[], fin.
//H={fin, r=R, $p[], @r} :- ground(R) | H=R.
//H=list.uniq0([Hd|Tl]) :- uniq(Hd) | H=[Hd|list.uniq0(Tl)].
//H={HH=list.uniq0([Hd|Tl]), $p[HH,Tl], @r}/ :- ground(Hd) | H={HH=list.uniq0(Tl), $p[HH,Tl], @r}.

/**
 * list.uniq
 * 
 * List -> List
 * 
 * not_uniq を追加したのでこう書ける
 * 現状、uniq() の履歴が共有されてしまう。
 */
H=list.uniq([     ]) :-                H=[                ].
H=list.uniq([Hd|Tl]) :-     uniq(Hd) | H=[Hd|list.uniq(Tl)].
H=list.uniq([Hd|Tl]) :- not_uniq(Hd) | H=    list.uniq(Tl) .


list.use_guard :-
[:/*inline_define*/
import util.Util;
class /*__UNITNAME__*/CustomGuardImpl implements CustomGuard {
	public boolean run(String guardID, Membrane mem, Object obj) throws GuardNotFoundException {
//		System.out.println("guardID "+guardID);
		ArrayList ary = (ArrayList)obj;
//		for(int i=0;i<ary.size();i++) {
//			System.out.println(ary.get(i).getClass());
//		}
//		System.out.println("CustomGuardImpl "+ary);
		
		if(guardID.equals("is_list")) {
			return Util.isList((Link)ary.get(0));
		}
		else if(guardID.equals("list_max")) {
			Atom a = new Atom(null, new IntegerFunctor(0));
			boolean b = Util.listMax((Link)ary.get(0), a);
			ary.set(1, a);
			return b;
		}
		else if(guardID.equals("list_min")) {
			Atom a = new Atom(null, new IntegerFunctor(0));
			boolean b = Util.listMin((Link)ary.get(0), a);
			ary.set(1, a);
			return b;
		}
		else if(guardID.equals("member")) {
			return Util.listMember((Atom)ary.get(0), (Link)ary.get(1));
		}
		else if(guardID.equals("not_member")) {
			return !Util.listMember((Atom)ary.get(0), (Link)ary.get(1));
		}
		else if(guardID.equals("test")) {
//			boolean b = Util.listMin((Link)ary.get(0), a);
			Atom aa = mem.newAtom(new IntegerFunctor(777));
			Link link = (Link)ary.get(0);
//			link.getAtom().remove();
			mem.inheritLink(aa, 0, link);
			return true;
		}
		throw new GuardNotFoundException();
	}
}
:].

/**
 * list.split(+List, +N, -Tail, -Head)
 *
 * リストをN番目で２つに分割して，分割後のリストをTail, Headに返します
 * 2006.2.28 by inui
 */
H=list.split(List,  X, Tail) :- X=0    | H=[], Tail=List.
H=list.split([   ], X, Tail) :- int(X) | H=[], Tail=[].
H=list.split([Y|Z], X, Tail) :- X>0    | H=[Y|list.split(Z,X-1,Tail)].

}.
//res = list.flatten(cons(cons(int(1),cons(int(2),int(3))), int(4)), nil).
