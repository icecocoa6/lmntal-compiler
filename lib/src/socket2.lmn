/*

NAME

	未定
	socket2 は冴えない

SYNOPSIS

	socekt2.init(acceptPort)
	  初期化
	socket2.connect(remoteHost)
	　通信路を確立
	socket2.send(remoteHost,messege)
	  メッセージを送信
	socket2.close(remoteHost)
	  通信路を閉じる
	socket2.terminate
	  終了
	サンプルはsample/okabe/socket2c.lmn とsample/okabe/socket2s.lmn にあります

AUTHOR

	Ryo Okabe

HISTORY

	1.0  2005/11/23(Wed)

*/

[:/*inline_define*/
import java.io.*;
import java.net.*;
import java.util.*;
import compile.*;
import compile.parser.LMNParser;
import compile.parser.ParseException;
import compile.parser.intermediate.RulesetParser;

/*
 *  class: AcceptThread
 */
class AcceptThread implements Runnable {
  volatile Thread th = null;
  ServerSocket servSock;
  final Membrane mem;
  
  /*
   *  AcceptThread.AcceptThread()
   */
  AcceptThread(ServerSocket servSock, Membrane mem) {
    this.servSock = servSock;
    this.mem = mem;
  }
  
  /*
   *  AcceptThread.start()
   */
  public void start() {
    if(th == null) {
      th = new Thread(this);
      th.start();
    }
  }
  
  /*
   *  AcceptThread.run()
   */
  public void run() {
    Thread thisThread = Thread.currentThread();
    while(th == thisThread) {
      try {
        Socket sock = servSock.accept();
        System.out.println("ServerSocket accepted: " + sock.toString());
        BufferedReader reader = 
          new BufferedReader(new InputStreamReader(sock.getInputStream()));
        //System.out.println("reader created: " + reader.toString());
        PrintWriter writer = new PrintWriter(sock.getOutputStream());
        //System.out.println("writer created: " + writer.toString());
        ReaderThread rThread = new ReaderThread(sock,reader,mem);
        String ipstr = sock.getInetAddress().getHostAddress().toString();
        mem.asyncLock();
        makeSocketProcess.create((Membrane)mem,sock,rThread,writer,ipstr);
        Atom a1 = mem.newAtom(new Functor("connectOK",1));
        Atom a2 = mem.newAtom(new StringFunctor(ipstr));
        mem.newLink(a1,0,a2,0);
        mem.asyncUnlock();
        rThread.start();
        System.out.println("ReaderThread: started");
      } catch(IOException e) {
        e.printStackTrace();
      } catch(SecurityException e) {
        e.printStackTrace();
      }
      try {
        th.sleep(100);
      } catch(InterruptedException e) {
        e.printStackTrace();
      }
    }
    th = null;
  }
  
  /*
   *  AcceptThread.stop
   */
  public void stop() {
    th = null;
    if(!servSock.isClosed()) {
      try {
        servSock.close();
      } catch(IOException e) {
        e.printStackTrace();
      }
    }
    System.out.println("AcceptThread: stopped");
  }
}

/* 
 *  class: ReaderThread
 */
class ReaderThread implements Runnable {
  volatile Thread th = null;
  Socket sock;
  BufferedReader reader;
  final Membrane mem;
  
  /*
   *  ReaderThread.ReaderThread
   */
  ReaderThread(Socket sock, BufferedReader reader, Membrane mem) {
    this.sock = sock;
    this.reader = reader;
    this.mem = mem;
  }
  
  /*
   *  ReaderThread.start
   */
  public void start() {
    if(th == null) {
      th = new Thread(this);
      th.start();
    }
  }
  
  /*
   *  ReaderThread.run
   */
  public void run(){
    Thread thisThread = Thread.currentThread();
    while(th == thisThread) {
      try {
        if(reader.ready()) {
          System.out.println("reader: ready");
          String msg = reader.readLine();
          System.out.println("message received: " + msg);
          Iterator i1 = mem.atomIteratorOfFunctor(new ObjectFunctor(sock));
          if(i1.hasNext()) {
            Atom sAtom = (Atom)i1.next();
            Atom nameAtom = sAtom.nthAtom(0);
            Atom tempAtom = nameAtom.nthAtom(3);
            mem.asyncLock();
            Atom msgAtom = mem.newAtom(new StringFunctor(msg));
            Atom consAtom = mem.newAtom(new Functor(".",3));
            mem.newLink(consAtom,0,msgAtom,0);
            Functor nilFunc = new Functor("[]",1);
            if(tempAtom.getFunctor().equals(nilFunc)) {
              mem.newLink(consAtom,1,tempAtom,0);
              mem.newLink(consAtom,2,nameAtom,3);
            } else {
              while(!tempAtom.getFunctor().equals(nilFunc)) {
                tempAtom = tempAtom.nthAtom(1);
              }
              mem.newLink(consAtom,2,tempAtom.nthAtom(0),1);
              mem.newLink(consAtom,1,tempAtom,0);
            }
            mem.asyncUnlock();
          }
        }
      } catch(IOException e) {
        e.printStackTrace();
      }
      try {
        th.sleep(100);
      } catch(InterruptedException e) {
        e.printStackTrace();
      }
    }
    th = null;
  }
  
  /*
   *  ReaderThread.stop
   */
  public void stop() {
    th = null;
    try {
      reader.close();
    } catch(IOException e) {
      e.printStackTrace();
    }
    System.out.println("ReaderThread: sotopped");
  }
}

/*
 *  class: makeSocketProcess
 */
class makeSocketProcess {
  
  /*
   *  makeSocketProcess.create()
   */
  static void create(Membrane mem, Socket sock, ReaderThread rThread, PrintWriter writer, String ipstr) {
    Functor sFunc = new ObjectFunctor(sock);
    Functor rtFunc = new ObjectFunctor(rThread);
    Functor wFunc = new ObjectFunctor(writer);
    StringFunctor ipFunc = new StringFunctor(ipstr);
    Atom nameAtom = mem.newAtom(new Functor("socket "+ipstr,6));
    Atom sAtom = mem.newAtom(sFunc);
    Atom rtAtom = mem.newAtom(rtFunc);
    Atom wAtom = mem.newAtom(wFunc);
    Atom ipAtom = mem.newAtom(ipFunc);
    Atom nilIn = mem.newAtom(new Functor("[]",1));
    Atom nilOut = mem.newAtom(new Functor("[]",1));
    mem.newLink(nameAtom,0,sAtom,0);
    mem.newLink(nameAtom,1,rtAtom,0);
    mem.newLink(nameAtom,2,wAtom,0);
    mem.newLink(nameAtom,3,nilIn,0);
    mem.newLink(nameAtom,4,nilOut,0);
    mem.newLink(nameAtom,5,ipAtom,0);
  }
}
:].

{
module(socket2).

/* 
 *  module: init
 */
init@@ socket2.init(Port) :- int(Port) |
  [:/*inline*/
    int port = Integer.parseInt(me.nth(0));
    try {
      ServerSocket servSock = new ServerSocket(port);
      mem.perpetual = true;
      //System.out.println("ServerSocket created: " + servSock.toString());
      AcceptThread aThread = new AcceptThread(servSock,(Membrane)mem);
      Functor sFunc = new ObjectFunctor(servSock);
      Functor atFunc = new ObjectFunctor(aThread);
      Atom sAtom = mem.newAtom(sFunc);
      Atom atAtom = mem.newAtom(atFunc);
      Atom nameAtom = mem.newAtom(new Functor("daemon",2));
      mem.newLink(nameAtom,0,sAtom,0);
      mem.newLink(nameAtom,1,atAtom,0);
      aThread.start();
      mem.newAtom(new Functor("initOK",0));
      //System.out.println("AcceptThread: started");
    } catch(IOException e) {
      e.printStackTrace();
    }
    me.nthAtom(0).remove();
    me.remove();
  :](Port).

/*
 *  module: connect
 */
socket@@ socket2.connect(Host,Port),initOK :- string(Host),int(Port) |
  initOK,
  [:/*inline*/
    System.out.println("now connecting");
    String host = me.nth(0);
    int port = Integer.parseInt(me.nth(1));
    for(int j = 0; j < 10; j++) {
      try {
        InetAddress ip = InetAddress.getByName(host);
        String ipstr = ip.getHostAddress().toString();
        StringFunctor ipFunc = new StringFunctor(ipstr);
//        Iterator it = mem.atomIteratorOfFunctor(ipFunc);
Iterator it = mem.atomIteratorOfFunctor(new Functor("connectOK",1));
Atom tempAtom; boolean connected = false;
while(it.hasNext()) {
tempAtom = (Atom)it.next();
if(tempAtom.getFunctor().equals(ipFunc)) {
connected = true;break;
}
}
        // 接続が確立していない場合
//        if(!it.hasNext()) {
if(!connected){
          Socket sock = new Socket(ip,port);
          BufferedReader reader = 
            new BufferedReader(new InputStreamReader(sock.getInputStream()));
          //System.out.println("reader created: " + reader.toString());
          PrintWriter writer = new PrintWriter(sock.getOutputStream());
          //System.out.println("writer created: " + writer.toString());
          ReaderThread rThread = new ReaderThread(sock,reader,(Membrane)mem);
          makeSocketProcess.create((Membrane)mem,sock,rThread,writer,ipstr);
          rThread.start();
          System.out.println("ReaderThread: started");
          System.out.println("before connectOK");
          Atom a1 = mem.newAtom(new Functor("connectOK",1));
          Atom a2 = mem.newAtom(ipFunc);
          System.out.println("before link");
          mem.newLink(a1,0,a2,0);
          System.out.println("after connecting");
          break;
        // 接続が確立している場合
        } else {
          System.out.println("already connected");
          break;
        }
      } catch(IOException e) {
        e.printStackTrace();
      }
    }
    me.nthAtom(0).remove();
    me.nthAtom(1).remove();
    me.remove();
    System.out.println("connect: succeeded");
  :](Host,Port).

/*
 *  module: send
 */
socket2.send(Host,Msg) :- string(Host),string(Msg) |
  [:/*inline*/
    String host = me.nth(0);
    String msg = me.nth(1);
    Functor msgFunc = new StringFunctor(msg);
    Atom msgAtom = mem.newAtom(msgFunc);
    try {
      InetAddress ip = InetAddress.getByName(host);
      String ipstr = ip.getHostAddress().toString();
      Atom nameAtom = mem.newAtom(new Functor ("send",2));
      Atom ipAtom = mem.newAtom(new StringFunctor(ipstr));
      mem.newLink(nameAtom,0,ipAtom,0);
      mem.newLink(nameAtom,1,msgAtom,0);
      System.out.println("send ready");
    } catch(UnknownHostException e) {
      e.printStackTrace();
    }
    me.nthAtom(0).remove();
    me.nthAtom(1).remove();
    me.remove();
  :](Host,Msg).

send(Ipstr1,Msg),connectOK(Ipstr2) :- 
  Ipstr1=Ipstr2,string(Msg) |
  connectOK(Ipstr2),
  [:/*inline*/
    System.out.println("now sending");
    String ipstr = me.nth(0);
    String msg = me.nth(1);
    System.out.println("now sending: " + msg);
      Functor ipFunc = new Functor("socket "+ipstr,6);
      Iterator it = mem.atomIteratorOfFunctor(ipFunc);
      System.out.println("iterator ok");
      if(it.hasNext()) {
        Atom nameAtom = (Atom)it.next();
        //Atom nameAtom = ipAtom.nthAtom(0);
        ObjectFunctor wFunc = (ObjectFunctor)nameAtom.nthAtom(2).getFunctor();
        PrintWriter writer = (PrintWriter)wFunc.getObject();
        writer.println(msg);
        writer.flush();
        System.out.println("sended: " + msg);
      } else {
        System.out.println("not connected");
      }
    me.nthAtom(0).remove();
    me.nthAtom(1).remove();
    me.remove();
  :](Ipstr1,Msg).

/*
 *  module:close
 *  TODO: 接続先に通信路を閉じることを伝える
 */
close@@ socket2.close(Host) :- string(Host) |
  [:/*inline*/
    String host = me.nth(0);
    try {
      InetAddress ip = InetAddress.getByName(host);
      Functor nameFunc = new Functor("socket " + ip.getHostAddress().toString(),5);
      System.out.println("closing: socket " + ip.getHostAddress().toString());
      Iterator it = mem.atomIteratorOfFunctor(nameFunc);
      if(it.hasNext()) {
        Atom nameAtom = (Atom)it.next();
        ObjectFunctor sFunc = (ObjectFunctor)nameAtom.nthAtom(0).getFunctor();
        Socket socket = (Socket)sFunc.getObject();
        // TODO: 接続先に通信路を閉じることを伝える
        socket.close();
        Atom rtAtom = nameAtom.nthAtom(1);
        ObjectFunctor rtFunc = (ObjectFunctor)rtAtom.getFunctor();
        ReaderThread rThread = (ReaderThread)rtFunc.getObject();
        rThread.stop();
        Atom wAtom = nameAtom.nthAtom(2);
        ObjectFunctor wFunc = (ObjectFunctor)wAtom.getFunctor();
        PrintWriter writer = (PrintWriter)wFunc.getObject();
        writer.close();
        nameAtom.nthAtom(0).remove();
        rtAtom.remove();
        wAtom.remove();
        // TODO: リストも消去 or リストが空でないときはclose を呼べないようにする
        nameAtom.remove();
      } else {
        System.out.println("cannot close because not connected");
      }
    } catch(IOException e) {
      e.printStackTrace();
    }
    me.nthAtom(0).remove();
    me.remove();
  :](Host).

/*
 *  module: terminate
 */
terminate@@ socket2.terminate :-
  [:/*inline*/
    Iterator i = mem.atomIteratorOfFunctor(new Functor("daemon",2));
    if(i.hasNext()) {
      System.out.println("now terminating");
      Atom nameAtom = (Atom)i.next();
      Atom sAtom = nameAtom.nthAtom(0);
      Atom atAtom = nameAtom.nthAtom(1);
      ObjectFunctor atFunc = (ObjectFunctor)atAtom.getFunctor();
      AcceptThread aThread = (AcceptThread)atFunc.getObject();
      aThread.stop();
      sAtom.remove();
      atAtom.remove();
      nameAtom.remove();
      System.out.println("perpetualing");
      mem.perpetual = false;
      System.out.println("perpetual = false");
    }
    me.remove();
  :].

/*  
 *  module: get
 */
socket2.get(Host) :- string(Host) |
  [:/*inline*/
    String host = me.nth(0);
    try {
      InetAddress ip = InetAddress.getByName(host);
      String ipstr = ip.getHostAddress().toString();
      Atom nameAtom = mem.newAtom(new Functor ("get",1));
      Atom ipAtom = mem.newAtom(new StringFunctor(ipstr));
      mem.newLink(nameAtom,0,ipAtom,0);
      System.out.println("get ready");
    } catch(UnknownHostException e) {
      e.printStackTrace();
    } 
    me.nthAtom(0).remove();
    me.remove();
  :](Host).

//get(Ipstr1),socket(S,R,W,[H|T],Out,Ipstr2) :-
//  Ipstr1=Ipstr2,class(S,"java.net.Socket"),class(R,"ReaderThread"),class(W,"java.io.writer.PrintWriter"),string(H) |
O=[H|T] :- string(H) |
O=T,
//  socket(S,R,W,T,Out,Ipstr2),
  [:/*inline*/
    String msg = me.nth(0);
    // 以下は別ライブラリ化する
    LMNParser lp;
    compile.structure.Membrane m;
    Ruleset rs;
    try {
      lp = new LMNParser(new StringReader(msg));
      m = lp.parse();
      System.out.println("parse succeeded: " + m.toString());
      rs = RulesetCompiler.compileMembrane(m);
      System.out.println("ruleset generated: " + rs.toString());
      rs.react((Membrane)mem);
      System.out.println(mem.toString());
      System.out.println("react succeeded" + m.toString());
    } catch(ParseException e) {
      e.printStackTrace();
    }
      me.nthAtom(0).remove();
      me.remove();
  :](H).
}

