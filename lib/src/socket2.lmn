/*

NAME

	未定
	socket2 は冴えない

SYNOPSIS

	socekt2.init(acceptPort)
	  初期化
	socket2.connect(remoteHost)
	　通信路を確立
	socket2.send(remoteHost,messege)
	  メッセージを送信
	socket2.close(remoteHost)
	  通信路を閉じる
	socket2.terminate
	  終了
	サンプルはsample/okabe/socket2c.lmn とsample/okabe/socket2s.lmn にあります

AUTHOR

	Ryo Okabe

HISTORY

	1.0  2005/11/23(Wed)

*/

[:/*inline_define*/
import java.io.*;
import java.net.*;
import java.util.*;
import compile.*;
import compile.parser.LMNParser;
import compile.parser.ParseException;
import compile.parser.intermediate.RulesetParser;

/*
 *  class: AcceptThread
 */
class AcceptThread implements Runnable {
  volatile Thread th = null;
  ServerSocket servSock;
  final Membrane mem;
  
  /*
   *  constructor
   */
  AcceptThread(ServerSocket servSock, Membrane mem) {
    this.servSock = servSock;
    this.mem = mem;
  }
  
  /*
   *  method: start
   */
  public void start() {
    if(th == null) {
      th = new Thread(this);
      th.start();
    }
  }
  
  /*
   *  method: AcceptThread.run()
   */
  public void run() {
    Thread thisThread = Thread.currentThread();
    while(th == thisThread) {
      try {
        Socket sock = servSock.accept();
        System.out.println("socket accepted: " + sock.toString());
        BufferedReader reader = 
          new BufferedReader(new InputStreamReader(sock.getInputStream()));
        //System.out.println("reader created: " + reader.toString());
        PrintWriter writer = new PrintWriter(sock.getOutputStream());
        //System.out.println("writer created: " + writer.toString());
        ReaderThread rThread = new ReaderThread(sock,reader,mem);
        mem.asyncLock();
        makeSocketProcess.create((Membrane)mem,sock,sock.getInetAddress(),rThread,writer);
        mem.newAtom(new Functor("connectOK",0));
        mem.asyncUnlock();
        rThread.start();
        
        System.out.println("ReaderThread: started");
      } catch(IOException e) {
        e.printStackTrace();
      } catch(SecurityException e) {
        e.printStackTrace();
      }
      try {
        th.sleep(100);
      } catch(InterruptedException e) {
        e.printStackTrace();
      }
    }
    th = null;
  }
  
  /*
   *  method: stop
   */
  public void stop() {
    th = null;
    if(!servSock.isClosed()) {
      try {
        servSock.close();
      } catch(IOException e) {
        e.printStackTrace();
      }
    }
    System.out.println("acceptThread: stopped");
  }
}

/* 
 *  class ReaderThread
 */
class ReaderThread implements Runnable {
  volatile Thread th = null;
  Socket sock;
  BufferedReader reader;
  final Membrane mem;
  
  /*
   *  constructor
   */
  ReaderThread(Socket sock, BufferedReader reader, Membrane mem) {
    this.sock = sock;
    this.reader = reader;
    this.mem = mem;
  }
  
  /*
   *  method: start
   */
  public void start() {
    if(th == null) {
      th = new Thread(this);
      th.start();
    }
  }
  
  /*
   *  method: ReaderThread.run()
   */
  public void run(){
    Thread thisThread = Thread.currentThread();
    while(th == thisThread) {
      try {
        if(reader.ready()) {
          System.out.println("reader: ready");
          String msg = reader.readLine();
          System.out.println("message received: " + msg);
    LMNParser lp;
    compile.structure.Membrane m;
    Ruleset rs;
    try {
      lp = new LMNParser(new StringReader(msg));
      m = lp.parse();
      System.out.println("parse succeeded: " + m.toString());
      rs = RulesetCompiler.compileMembrane(m);
      System.out.println("ruleset generated: " + rs.toString());
      rs.react((Membrane)mem);
      System.out.println(mem.toString());
      System.out.println("react succeeded" + m.toString());
    } catch(ParseException e) {
      e.printStackTrace();
    }
    // TODO: リストにつなぐ
//          Iterator i1 = mem.atomIteratorOfFunctor(new ObjectFunctor(sock));
//          if(i1.hasNext()) {
//            System.out.println("hasNext()=true");
//            Atom sAtom = (Atom)i1.next();
//            System.out.println("sAtom");
//           Atom nameAtom = sAtom.nthAtom(0);
//            Atom headAtom = nameAtom.nthAtom(3);
//            mem.asyncLock();
//            System.out.println("asyncLock");
//            Atom msgAtom = mem.newAtom(new StringFunctor(msg));
//            Atom consAtom = mem.newAtom(new Functor(".",3));
//            mem.newLink(msgAtom,0,consAtom,0);
//            mem.newLink(consAtom,2,headAtom,1);
//            mem.newLink(consAtom,1,nameAtom,3);
//            mem.asyncUnlock();
//          }
        }
      } catch(IOException e) {
        e.printStackTrace();
      }
      try {
        th.sleep(100);
      } catch(InterruptedException e) {
        e.printStackTrace();
      }
    }
    th = null;
  }
  
  /*
   *  method: stop
   */
  public void stop() {
    th = null;
    try {
      reader.close();
    } catch(IOException e) {
      e.printStackTrace();
    }
    System.out.println("readerThread: sotopped");
  }
}

/*
 *  class: makeSocketProcess
 */
class makeSocketProcess {
  
  /*
   *  method: create
   */
  static void create(Membrane mem, Socket sock, InetAddress ip, ReaderThread rThread, PrintWriter writer) {
    Functor sFunc = new ObjectFunctor(sock);
    Functor rtFunc = new ObjectFunctor(rThread);
    Functor wFunc = new ObjectFunctor(writer);
    Atom nameAtom = mem.newAtom(new Functor("socket " + ip.getHostAddress().toString(),5));
    System.out.println("newFunctor: in create: socket " + ip.getHostAddress().toString());
    Atom sAtom = mem.newAtom(sFunc);
    Atom rtAtom = mem.newAtom(rtFunc);
    Atom wAtom = mem.newAtom(wFunc);
    //Atom consIn = mem.newAtom(new Functor(".",2));
    Atom nilIn = mem.newAtom(new Functor("[]",1));
    //Atom consOut = mem.newAtom(new Functor(".",2));
    Atom nilOut = mem.newAtom(new Functor("[]",1));
    mem.newLink(nameAtom,0,sAtom,0);
    mem.newLink(nameAtom,1,rtAtom,0);
    mem.newLink(nameAtom,2,wAtom,0);
    mem.newLink(nameAtom,3,nilIn,0);
    mem.newLink(nameAtom,4,nilOut,0);
    //mem.newLink(consIn,0,nilIn,0);
    //mem.newLink(consOut,0,nilOut,0);
    System.out.println("newAtom: socket " + ip.getHostAddress().toString());
  }
}
:].

{
module(socket2).

/* 
 *  module: init
 */
init@@ socket2.init(Port) :- int(Port) |
  [:/*inline*/
    int port = Integer.parseInt(me.nth(0));
    try {
      ServerSocket servSock = new ServerSocket(port);
      mem.perpetual = true;
      //System.out.println("servSock created: " + servSock.toString());
      AcceptThread aThread = new AcceptThread(servSock,(Membrane)mem);
      Functor sFunc = new ObjectFunctor(servSock);
      Functor atFunc = new ObjectFunctor(aThread);
      Atom sAtom = mem.newAtom(sFunc);
      Atom atAtom = mem.newAtom(atFunc);
      Atom nameAtom = mem.newAtom(new Functor("daemon",2));
      mem.newLink(nameAtom,0,sAtom,0);
      mem.newLink(nameAtom,1,atAtom,0);
      aThread.start();
      mem.newAtom(new Functor(initOK));
      System.out.println("AcceptThread: started");
    } catch(IOException e) {
      e.printStackTrace();
    }
    me.nthAtom(0).remove();
    me.remove();
  :](Port).

socket@@ socket2.connect(Host,Port),initOK :- string(Host),int(Port) |
  [:/*inline*/
    System.out.println("now connecting");
    String host = me.nth(0);
    int port = Integer.parseInt(me.nth(1));
    for(int j = 0; j < 10; j++) {
      try {
        InetAddress ip = InetAddress.getByName(host);
        System.out.println("new Functor: socket " + ip.getHostAddress().toString());
        Functor nameFunc = new Functor("socket " + ip.getHostAddress().toString(),5);
        Iterator it = mem.atomIteratorOfFunctor(nameFunc);
        System.out.println("searchFunctor: socket " + ip.getHostAddress().toString());
        if(!it.hasNext()) {
          Socket sock = new Socket(ip,port);
          System.out.println("newSocket: socket " + ip.getHostAddress().toString());
          BufferedReader reader = 
            new BufferedReader(new InputStreamReader(sock.getInputStream()));
          //System.out.println("reader created: " + reader.toString());
          PrintWriter writer = new PrintWriter(sock.getOutputStream());
          //System.out.println("writer created: " + writer.toString());
          ReaderThread rThread = new ReaderThread(sock,reader,(Membrane)mem);
          makeSocketProcess.create((Membrane)mem,sock,ip,rThread,writer);
          rThread.start();
          System.out.println("ReaderThread: started");
          mem.newAtom(new Functor ("connectOK",0));
          break;
        } else {
          System.out.println("already connected");
          break;
        }
      } catch(IOException e) {
        e.printStackTrace();
      }
    }
    me.nthAtom(0).remove();
    me.nthAtom(1).remove();
    me.remove();
    System.out.println("connected");
  :](Host,Port).

/*
 *  module: send
 *  TODO: message が命令列である場合と文字列である場合で区別できるようにする
 */
send@@ socket2.send(Host,Msg) :- string(Host),string(Msg) |
  [:/*inline*/
    String host = me.nth(0);
    String msg = me.nth(1);
    System.out.println("now sending: " + msg);
    try {
      InetAddress ip = InetAddress.getByName(host);
      System.out.println("new Functor: socket " + ip.getHostAddress().toString());
      Functor nameFunc = new Functor("socket " + ip.getHostAddress().toString(),5);
      Iterator it = mem.atomIteratorOfFunctor(nameFunc);
      System.out.println("searchFunctor: socket " + ip.getHostAddress().toString());
      if(it.hasNext()) {
        Atom nameAtom = (Atom)it.next();
        ObjectFunctor wFunc = (ObjectFunctor)nameAtom.nthAtom(2).getFunctor();
        PrintWriter writer = (PrintWriter)wFunc.getObject();
        writer.println(msg);
        writer.flush();
        System.out.println("sended: " + msg);
      } else {
        System.out.println("not connected");
      }
    } catch(IOException e) {
          e.printStackTrace();
    }
    me.nthAtom(0).remove();
    me.nthAtom(1).remove();
    me.remove();
  :](Host,Msg).

/*
 *  module:close
 *  TODO: 接続先に通信路を閉じることを伝える
 */
close@@ socket2.close(Host) :- string(Host) |
  [:/*inline*/
    String host = me.nth(0);
    try {
      InetAddress ip = InetAddress.getByName(host);
      Functor nameFunc = new Functor("socket " + ip.getHostAddress().toString(),5);
      System.out.println("closing: socket " + ip.getHostAddress().toString());
      Iterator it = mem.atomIteratorOfFunctor(nameFunc);
      if(it.hasNext()) {
        Atom nameAtom = (Atom)it.next();
        ObjectFunctor sFunc = (ObjectFunctor)nameAtom.nthAtom(0).getFunctor();
        Socket socket = (Socket)sFunc.getObject();
        // TODO: 接続先に通信路を閉じることを伝える
        socket.close();
        Atom rtAtom = nameAtom.nthAtom(1);
        ObjectFunctor rtFunc = (ObjectFunctor)rtAtom.getFunctor();
        ReaderThread rThread = (ReaderThread)rtFunc.getObject();
        rThread.stop();
        Atom wAtom = nameAtom.nthAtom(2);
        ObjectFunctor wFunc = (ObjectFunctor)wAtom.getFunctor();
        PrintWriter writer = (PrintWriter)wFunc.getObject();
        writer.close();
        nameAtom.nthAtom(0).remove();
        rtAtom.remove();
        wAtom.remove();
        // TODO: リストも消去 or リストが空でないときはclose を呼べないようにする
        nameAtom.remove();
      } else {
        System.out.println("cannot close because not connected");
      }
    } catch(IOException e) {
      e.printStackTrace();
    }
    me.nthAtom(0).remove();
    me.remove();
  :](Host).

/*
 *  module: terminate
 */
terminate@@ socket2.terminate :-
  [:/*inline*/
    Iterator i = mem.atomIteratorOfFunctor(new Functor("daemon",2));
    if(i.hasNext()) {
      System.out.println("now terminating");
      Atom nameAtom = (Atom)i.next();
      Atom sAtom = nameAtom.nthAtom(0);
      Atom atAtom = nameAtom.nthAtom(1);
      ObjectFunctor atFunc = (ObjectFunctor)atAtom.getFunctor();
      AcceptThread aThread = (AcceptThread)atFunc.getObject();
      aThread.stop();
      sAtom.remove();
      atAtom.remove();
      nameAtom.remove();
      System.out.println("perpetualing");
      mem.perpetual = false;
      System.out.println("perpetual = false");
    }
    me.remove();
  :].

/*  
 *  module: read
 *  TODO: get コマンドで取得できるようにする
 */
//read@@ socket(S,R,W,[H|T],Out) :-
//  class(S,"java.net.Socket"),class(R,"ReadThread"),class(W,"java.io.writer.PrintWriter"),string(H) |
//  socket(S,R,W,T,Out),
//  [:/*inline*/
//    String msg = me.nth(0);
//    // 以下は別ライブラリ化する
//    LMNParser lp;
//    compile.structure.Membrane m;
//    Ruleset rs;
//    try {
//      lp = new LMNParser(new StringReader(msg));
//      m = lp.parse();
//      System.out.println("parse succeeded: " + m.toString());
//      rs = RulesetCompiler.compileMembrane(m);
//      System.out.println("ruleset generated: " + rs.toString());
//      rs.react((Membrane)mem);
//      System.out.println(mem.toString());
//      System.out.println("react succeeded" + m.toString());
//    } catch(ParseException e) {
//      e.printStackTrace();
//    }
//      me.nthAtom(0).remove();
//      me.remove();
//  :](H).
}

