/*

NAME

	未定
	socket2 は冴えない

SYNOPSIS

	socekt2.init(acceptPort)
	  初期化
	socket2.send(remoteHost,remotePort,messege)
	  メッセージを送信
	socket2.close(remoteHost,remotePort)
	  ソケットを閉じる
	socket2.terminate
	  終了
	サンプルはsample/okabe/socket2c.lmn とsample/okabe/socket2s.lmn にあります

AUTHOR

	Ryo Okabe

HISTORY

	1.0  2005/11/23(Wed)

*/

[:/*inline_define*/
import java.io.*;
import java.net.*;
import java.util.*;
import compile.*;
import compile.parser.LMNParser;
import compile.parser.ParseException;
import compile.parser.intermediate.RulesetParser;

/*
 *  class: AcceptThread
 */
class AcceptThread implements Runnable {
  volatile Thread th = null;
  ServerSocket serverSock;
  HashMap connectTable;
  final Membrane mem;
  
  /*
   *  constructor
   */
  AcceptThread(ServerSocket serverSock, HashMap connectTable, Membrane mem) {
    this.serverSock = serverSock;
    this.connectTable = connectTable;
    this.mem = mem;
  }
  
  /*
   *  method: start
   */
  public void start() {
    if(th == null) {
      th = new Thread(this);
      th.start();
    }
  }
  
  /*
   *  method: run
   */
  public void run() {
    Thread thisThread = Thread.currentThread();
    while(th == thisThread) {
      try {
        Socket socket = serverSock.accept();
        System.out.println("socket accepted: " + socket.toString());
        synchronized(connectTable) {
          connectTable.put(socket.getInetAddress().toString() + " " + socket.getPort(),socket);
          System.out.println("connectTable put: " + socket.getInetAddress().toString() + " " + socket.getPort());
        }
        BufferedReader reader = 
          new BufferedReader(new InputStreamReader(socket.getInputStream()));
        //System.out.println("reader created: " + reader.toString());
        PrintWriter writer = new PrintWriter(socket.getOutputStream());
        //System.out.println("writer created: " + writer.toString());
        ReaderThread readerThread = new ReaderThread(socket,reader,mem);
        mem.asyncLock();
        makeSocketProcess.create((Membrane)mem,socket,readerThread,writer);
        mem.asyncUnlock();
        readerThread.start();
        System.out.println("readerThread: started");
      } catch(IOException e) {
        e.printStackTrace();
      } catch(SecurityException e) {
        System.out.println("RuntimeException: " + e.getMessage());
        e.printStackTrace();
      }
      try {
        th.sleep(100);
      } catch(InterruptedException e) {
        e.printStackTrace();
      }
    }
    th = null;
  }
  
  /*
   *  method: stop
   *  TODO: ここでServerSocket をclose するべきか？
   */
  public void stop() {
    th = null;
    System.out.println("acceptThread: stopped");
  }
}

/* 
 *  class ReaderThread
 */
class ReaderThread implements Runnable {
  volatile Thread th = null;
  Socket socket;
  BufferedReader reader;
  final Membrane mem;
  
  /*
   *  constructor
   */
  ReaderThread(Socket sock, BufferedReader reader, Membrane mem) {
    this.socket = socket;
    this.reader = reader;
    this.mem = mem;
  }
  
  /*
   *  method: start
   */
  public void start() {
    if(th == null) {
      th = new Thread(this);
      th.start();
    }
  }
  
  /*
   *  method: run
   *  TODO: message を別処理にする（文字列受信にも対応させるため）
   */
  public void run(){
    Thread thisThread = Thread.currentThread();
    LMNParser lp;
    compile.structure.Membrane m;
    Ruleset rs;
    while(th == thisThread) {
      try {
        if(reader.ready()) {
          System.out.println("reader: ready");
          String msg = reader.readLine();
          System.out.println("message received: " + msg);
          // TODO: 別処理にする
          lp = new LMNParser(new StringReader(msg));
          m = lp.parse();
          System.out.println("parse succeeded: " + m.toString());
          rs = RulesetCompiler.compileMembrane(m);
          System.out.println("ruleset generated: " + rs.toString());
          mem.asyncLock();
          rs.react(mem);
          mem.asyncUnlock();
          System.out.println("react succeeded" + m.toString());
        }
      } catch(IOException e) {
        e.printStackTrace();
      } catch(ParseException e) {
        e.printStackTrace();
      }
      try {
        th.sleep(100);
      } catch(InterruptedException e) {
        e.printStackTrace();
      }
    }
    th = null;
  }
  
  /*
   *  method: stop
   *  TODO: Socket, BufferedReader はここでclose するべきか？
   */
  public void stop() {
    th = null;
    try {
      reader.close();
    } catch(IOException e) {
      e.printStackTrace();
    }
    System.out.println("readerThread: sotopped");
  }
}

/*
 *  class: makeSocketProcess
 */
class makeSocketProcess {
  
  /*
   *  method: create
   */
  static void create(Membrane mem, Socket socket, ReaderThread reader, PrintWriter writer) {
    Functor func = new Functor("socket",5);
    Functor sFunc = new ObjectFunctor(socket);
    Functor rFunc = new ObjectFunctor(reader);
    Functor wFunc = new ObjectFunctor(writer);
    Atom atom = mem.newAtom(func);
    Atom socketAtom = mem.newAtom(sFunc);
    Atom readerAtom = mem.newAtom(rFunc);
    Atom writerAtom = mem.newAtom(wFunc);
    Atom nilIn = mem.newAtom(new Functor("[]",1));
    Atom nilOut = mem.newAtom(new Functor("[]",1));
    mem.newLink(atom,0,socketAtom,0);
    mem.newLink(atom,1,readerAtom,0);
    mem.newLink(atom,2,writerAtom,0);
    mem.newLink(atom,3,nilIn,0);
    mem.newLink(atom,4,nilOut,0);
    //System.out.println("socket-process created: " + socket.toString());
  }
}
:].

{
module(socket2).

/* 
 *  module: init
 *  TODO: bind に失敗したときの処理
 *        例外周辺
 */
init@@ socket2.init(Port) :- int(Port) |
  [:/*inline*/
    int port = Integer.parseInt(me.nth(0));
    try {
      ServerSocket serverSock = new ServerSocket(port);
      //System.out.println("serverSock created: " + serverSock.toString());
      HashMap<String,Socket> connectTable = new HashMap();
      //System.out.println("connectTable created: " + connectTable.toString());
      AcceptThread daemon = new AcceptThread(serverSock,connectTable,(Membrane)mem);
      Functor sFunc = new ObjectFunctor(serverSock);
      Functor cFunc = new ObjectFunctor(connectTable);
      Functor dFunc = new ObjectFunctor(daemon);
      Atom sAtom = mem.newAtom(sFunc);
      Atom cAtom = mem.newAtom(cFunc);
      Atom dAtom = mem.newAtom(dFunc);
      Atom atom = mem.newAtom(new Functor("connectTable",3));
      mem.newLink(atom,0,sAtom,0);
      mem.newLink(atom,1,cAtom,0);
      mem.newLink(atom,2,dAtom,0);
      daemon.start();
      System.out.println("daemon: started");
    } catch(IOException e) {
      e.printStackTrace();
    }
    me.nthAtom(0).remove();
    me.remove();
  :](Port).

/*
 *  module: send
 *  TODO: connect に失敗したときの処理
 *        例外周辺
 *  DONE: ループをまわす
 *  TODO: message が命令列である場合と文字列である場合で区別できるようにする
 */
send@@ socket2.send(Host,Port,Msg) :- string(Host),int(Port),string(Msg) |
  [:/*inline*/
    String host = me.nth(0);
    int port = Integer.parseInt(me.nth(1));
    String msg = me.nth(2);
    System.out.println("now sending: " + msg);
    Iterator i1 = mem.atomIteratorOfFunctor(new Functor("connectTable",3));
    // connectTable は各膜に高々１つ
    if(i1.hasNext()) {
      Atom atom = (Atom)i1.next();
      ObjectFunctor cFunc = (ObjectFunctor)atom.nthAtom(1).getFunctor();
      HashMap connectTable = (HashMap)cFunc.getObject();
      Socket socket;

      for(int j = 0; j < 10; j++){
        try {
          InetAddress ip = InetAddress.getByName(host);
          System.out.println("connectTable search: " + ip.toString() + " " + port);
          if(connectTable.containsKey(ip.toString() + " " + port)) {
            System.out.println("true");
            socket = (Socket)connectTable.get(ip.toString() + " " + port);
            Iterator i2 = mem.atomIteratorOfFunctor(new ObjectFunctor(socket));
            if(i2.hasNext()) {
              Atom sAtom = (Atom)i2.next();
              Atom socketAtom = sAtom.nthAtom(0);
              ObjectFunctor wFunc = (ObjectFunctor)socketAtom.nthAtom(2).getFunctor();
              PrintWriter writer = (PrintWriter)wFunc.getObject();
              writer.println(msg);
              writer.flush();
              System.out.println("sended: " + msg);
              break;
            }
          } else {
            System.out.println("false");
            // TODO: connect が失敗したときの処理
            //      →DONE
            socket = new Socket(host,port);
            //System.out.println("socket created: " + socket.toString());
            synchronized(connectTable) {
              connectTable.put(ip.toString() + " " + port,socket);
              System.out.println("connectTable put: " + ip.toString() + " " + port);
            }
            BufferedReader reader = 
              new BufferedReader(new InputStreamReader(socket.getInputStream()));
            //System.out.println("reader created: " + reader.toString());
            PrintWriter writer = 
              new PrintWriter(socket.getOutputStream());
            //System.out.println("writer created: " + writer.toString());
            ReaderThread readerThread = new ReaderThread(socket,reader,(Membrane)mem);
            makeSocketProcess.create((Membrane)mem,socket,readerThread,writer);
            readerThread.start();
            System.out.println("readerThread: started");
            writer.println(msg);
            writer.flush();
            System.out.println("sended: " + msg);
            break;
          }
        } catch(IOException e) {
          e.printStackTrace();
        }
      }
    }
    me.nthAtom(0).remove();
    me.nthAtom(1).remove();
    me.nthAtom(2).remove();
    me.remove();
  :](Host,Port,Msg).

/*
 *  module:close
 *  TODO: 接続先に通信路を閉じることを伝える
 */
close@@ socket2.close(Host,Port) :- string(Host),int(Port) |
  [:/*inline*/
    String host = me.nth(0);
    int port = Integer.parseInt(me.nth(1));
    Iterator i1 = mem.atomIteratorOfFunctor(new Functor("connectTable",3));
    // connectTable は各膜に高々１つ
    if(i1.hasNext()) {
      Atom atom = (Atom)i1.next();
      ObjectFunctor cFunc = (ObjectFunctor)atom.nthAtom(1).getFunctor();
      HashMap connectTable = (HashMap)cFunc.getObject();
      try {
        InetAddress ip = InetAddress.getByName(host);
        System.out.println("connectTable search: " + ip.toString() + " " + port);
        if(connectTable.containsKey(ip.toString() + " " + port)) {
          System.out.println("true");
          Socket socket = (Socket)connectTable.get(ip.toString() + " " + port);
          // TODO: 接続先に通信路を閉じることを伝える
          socket.close();
          Iterator i2 = mem.atomIteratorOfFunctor(new ObjectFunctor(socket));
          if(i2.hasNext()) {
            Atom sAtom = (Atom)i2.next();
            Atom socketAtom = sAtom.nthAtom(0);
            socketAtom.nthAtom(0).remove();
            Atom rAtom = socketAtom.nthAtom(1);
            ObjectFunctor rFunc = (ObjectFunctor)rAtom.getFunctor();
            ReaderThread readerThread = (ReaderThread)rFunc.getObject();
            readerThread.stop();
            rAtom.remove();
            Atom wAtom = socketAtom.nthAtom(2);
            ObjectFunctor wFunc = (ObjectFunctor)wAtom.getFunctor();
            PrintWriter writer = (PrintWriter)wFunc.getObject();
            writer.close();
            socketAtom.nthAtom(2).remove();
            socketAtom.nthAtom(3).remove();
            socketAtom.nthAtom(4).remove();
            socketAtom.remove();
            synchronized(connectTable) {
              connectTable.remove(ip.toString() + " " + port);
              System.out.println("connectTable remove: " + ip.toString() + " " + port);
            }
          }
        }
      } catch(IOException e) {
        e.printStackTrace();
      }
    }
    me.nthAtom(0).remove();
    me.nthAtom(1).remove();
    me.remove();
  :](Host,Port).

/*
 *  module: terminate
 *  TODO: ServerSocket を閉じるタイミング
 */
terminate@@ socket2.terminate :-
  [:/*inline*/
    Iterator i = mem.atomIteratorOfFunctor(new Functor("connectTable",3));
    // connectTable は各膜に高々１つ
    if(i.hasNext()) {
      Atom atom = (Atom)i.next();
      ObjectFunctor cFunc = (ObjectFunctor)atom.nthAtom(1).getFunctor();
      HashMap connectTable = (HashMap)cFunc.getObject();
      if(connectTable.isEmpty()) {
        System.out.println("connectTable: empty");
        Atom sAtom = atom.nthAtom(0);
        Atom dAtom = atom.nthAtom(2);
        ObjectFunctor sFunc = (ObjectFunctor)sAtom.getFunctor();
        ObjectFunctor dFunc = (ObjectFunctor)dAtom.getFunctor();
        ServerSocket serverSock = (ServerSocket)sFunc.getObject();
        // TODO: AcceptThread.stop() に移すべきか？
        if(!serverSock.isClosed()) {
          System.out.println("serverSock: not closed"); 
          try {
            serverSock.close();
          } catch(IOException e) {
            e.printStackTrace();
          }
        }
        //System.out.println("serverSock.isClosed(): " + serverSock.isClosed());
        AcceptThread daemon = (AcceptThread)dFunc.getObject();
        daemon.stop();
        sAtom.remove();
        atom.nthAtom(1).remove();
        dAtom.remove();
        atom.remove();
      }
    }
    me.remove();
  :].

// read data from socket
// should be changed to socket(S,R,In,Out)?
//socket2.socket(S,R,W,[H|T],Out) :-
//  class(S,"Socket"),class(R,"ReadThread"),class(W,"PrintWriter"),string(H) |
//  socket2.socket(S,R,W,T,Out),
//  [:/*inline*/
//    String msg = me.nth(0);
//    //In the future, compile and interpret "msg" here.
//    System.out.println(msg);
//  :](H).

// write data to socket
// should be changed to socket(S,R,In,Out)?
//socket2.socket(S,R,W,In,[H|T]) :-
//  class(S,"Socket"),class(R,"ReaderThread"),class(W,"PrintWriter"),string(H) |
//  socket2.socket(S,R,W,In,T),
//  [:/*inline*/
//    String msg = me.nth(0);
//    ObjectFunctor func = (ObjectFunctor)me.nthAtom(1).getFunctor();
//    PrintWriter writer = (PrintWriter)func.getObject();
//    writer.println(msg);
//    writer.flush();
//  :](H,W).

}


