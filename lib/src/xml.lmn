/*
 * Coyright(C) 2006 Ueda Laboratory LMNtal Group, All rights reserved. 
 * $Author$
 *
 * SYNOPSIS
 *  XMLライブラリ
 * 
 * HISTORY
 *	2006.1.23 作成開始
 *  2006.1.24 ノードの表現を膜に変更
 */

{
module(xml).

/**
 * xml.open(+Filename, -Res):
 * 与えられたファイル名のXMLファイルを読み込んでLMNtalデータ構造を生成します。
 * @param +Filename XMLファイル名
 * @param -Res ルートアトムを返します。
 * @example r=xml.open("sample.xml").
 */
H=xml.open(Filename) :- unary(Filename) | H=[:/*inline*/
	Atom a = LMNtalXML.open(me.nth(0), mem);
	mem.relink(a, 0, me, 1);
	mem.removeAtom(me.nthAtom(0));
	mem.removeAtom(me);
	:](Filename).
}.

[:/*inline_define*/
import java.io.FileInputStream;

import javax.xml.parsers.*;

import org.w3c.dom.*;

import runtime.*;

/**
 * XMLファイルを読んでLMNtalデータ構造を構築する
 * @author inui
 * @since 2006.1.23
 */
class LMNtalXML {
	protected static final Functor nameFunctor = new Functor("name", 1);
	protected static final Functor valueFunctor = new Functor("value", 1);
	
	protected AbstractMembrane mem;
	protected Document doc;
	protected String filename;

	/**
	 * コンストラクタ
	 * @param filename 読み込むXMLファイル
	 * @param mem データ構造を追加したい膜
	 */
	private LMNtalXML(String filename, AbstractMembrane mem) {
		this.filename = filename;
		this.mem = mem;
		try {
			DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
			DocumentBuilder db = dbf.newDocumentBuilder();
			//XML文書を読み込む
			doc = db.parse(new FileInputStream(filename));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	public static Atom open(String filename, AbstractMembrane mem) {
		LMNtalXML xml = new LMNtalXML(filename, mem);
		return xml.walkThrough();
	}
	
	/**
	 * ノードを受け取って対応するアトムを生成します
	 * @param node ノード
	 * @return このノードに対応するアトム
	 */
	private AbstractMembrane newNodeMembrane(Node node, AbstractMembrane mem) {
		AbstractMembrane m = mem.newMem();
		Atom nameAtom1 = m.newAtom(nameFunctor);
		Atom nameAtom2 = m.newAtom(new StringFunctor(node.getNodeName()+""));
		m.newLink(nameAtom1, 0, nameAtom2, 0);
		
		Atom valueAtom1 = m.newAtom(valueFunctor);
		Atom valueAtom2 = m.newAtom(new StringFunctor(node.getNodeValue()+""));
		mem.newLink(valueAtom1, 0, valueAtom2, 0);
		return m;
	}

	/**
	 * 全ノードを探索
	 * @return ルートノードを表すアトム
	 */
	private Atom walkThrough() {
		Node root = doc.getDocumentElement();
		AbstractMembrane m = mem.newMem();
		traverse(root, m);
		return m.newAtom(new Functor(filename, 1));
	}
	
	/**
	 * 有効なノードかどうか判定する
	 * @param node ノード
	 * @return 有効なノードならtrue
	 */
	private boolean isValidNode(Node node) {
		return !(node.getNodeType() == Node.TEXT_NODE && node.getNodeValue().trim().length() == 0);
	}
	
	/**
	 * 有効な子ノードの数を返す
	 * @param node ノード
	 * @return 子ノードの数
	 */
//	private int getValidChildNodesLength(Node node) {
//		int length = 0;
//		for (Node child = node.getFirstChild(); child != null; child = child.getNextSibling()) {
//			if (isValidNode(child)) length++;
//		}
//		return length;
//	}

	/**
	 * 再帰的にノードをたどる
	 * @param node ノード
	 * @param atom アトム
	 */
	private void traverse(Node node, AbstractMembrane mem) {
		for (Node child = node.getFirstChild(); child != null; child = child.getNextSibling()) {
			if (!isValidNode(child)) continue;
			
			AbstractMembrane m = newNodeMembrane(child, mem);
			
			traverse(child, m);
		}
	}

	public static void main(String args[]) {
		LMNtalXML xml = new LMNtalXML(args[0], new Membrane());
		xml.walkThrough();
	}
}
:]