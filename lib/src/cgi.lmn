/*
NAME
	CGI module

SYNOPSIS

AUTHOR
	Koji Hara
	Atsuyuki Inui

HISTORY
	2004/05/23(Sun)
	2006/07/23(Sun) 書き直した by inui

TODO
	//query_string を取得する部分だけを inline で書けば、他はライブラリを使ってかける。かく。
	cgi.use と cgi.use(S) の区別はライブラリ側で行う

*/

//{
//module(cgi).
//
///**
// * parse_query : unit -> Map
// * 
// */
//H=cgi.parse_query :- H=map.of_queue(queue.of_list([:/*inline*/
//	System.out.println("QS = "+Env.getExtendedOption("query_string"));
//	String q = Env.getExtendedOption("query_string");
//	String r[] = q.split("[&=]");
//	StringTokenizer st = new StringTokenizer(q, "&=");
//	List l = new ArrayList();
//	while(st.hasMoreTokens()) {
//		l.add(st.nextToken());
//	}
//	
//	util.Util.makeList(me.getArg(0), java.util.Arrays.asList(r));
//	util.Util.makeList(me.getArg(0), l);
//	
//	mem.removeAtom(me);
//	:])).
//
//
//}.

{
module(cgi).

/**
 * 初期化（パラメータが解析される）
 */
cgi.use :- r=seq.run({query=sys.getenv("QUERY_STRING")}, [
//cgi.use :-r=seq.run({query="name=inui&age=23"}, [
	{query=Query :- query2=string.split("&", Query).},
	{query2(Query) :- query3=list.map(split, Query).},
	{H=[[split, S]|Z] :- H=[string.split("=", S)|Z].}
	]).
cgi.use(S) :- string(S) | r=seq.run({query=S}, [
	{query=Query :- query2=string.split("&", Query).},
	{query2(Query) :- query3=list.map(split, Query).},
	{H=[[split, S]|Z] :- H=[string.split("=", S)|Z].}
	]).
r(R), {+R, query3(Query)}/ :- ground(Query) | query3(Query).

/**
 * パラメータを取得する
 */
H=cgi.param(Key), query3=[[""]] :- string(Key), H="".
H=cgi.param(Key), query3=Query :- string(Key), ground(Query) |
	H={param(Key), query3=Query}, query3(Query).
H={param(Key), L=[Key2, Value]}  :- string(Key), string(Key2), string(Value), ground(L), Key = Key2 | H=Value.
H={param(Key), L=[Key2, Value]}/ :- string(Key), string(Key2), string(Value), ground(L) | H="".

/**
 * デコード
 */
H=cgi.decode(S) :- H=[:/*inline*/
	String s = ((StringFunctor)me.nthAtom(0).getFunctor()).stringValue();
	Atom res = null;
//	try {
//		res = mem.newAtom(new StringFunctor(java.net.URLDecoder.decode(s, "EUC-JP")));
//	} catch (java.io.UnsupportedEncodingException e) {
//		//失敗したときはそのまま返す
//		res = mem.newAtom(new StringFunctor(s));
//	}
	res = mem.newAtom(new StringFunctor(java.net.URLDecoder.decode(s)));
	me.nthAtom(0).remove();
	mem.relink(res, 0, me, 1);
	me.remove();
	:](S).
H=cgi.decode(S, Enc) :- H=[:/*inline*/
	String s = ((StringFunctor)me.nthAtom(0).getFunctor()).stringValue();
	String enc = ((StringFunctor)me.nthAtom(1).getFunctor()).stringValue();
	Atom res = null;
	try {
		res = mem.newAtom(new StringFunctor(java.net.URLDecoder.decode(s, enc)));
	} catch (java.io.UnsupportedEncodingException e) {
		//失敗したときはそのまま返す
		res = mem.newAtom(new StringFunctor(s));
	}
	me.nthAtom(0).remove();
	me.nthAtom(1).remove();
	mem.relink(res, 0, me, 2);
	me.remove();
	:](S, Enc).

/**
 * エンコード
 */
H=cgi.encode(S) :- H=[:/*inline*/
	String s = ((StringFunctor)me.nthAtom(0).getFunctor()).stringValue();
	Atom res = null;
//	try {
//		res = mem.newAtom(new StringFunctor(java.net.URLEncoder.encode(s, "EUC-JP")));
//	} catch (java.io.UnsupportedEncodingException e) {
//		//失敗したときはそのまま返す
//		res = mem.newAtom(new StringFunctor(s));
//	}
	res = mem.newAtom(new StringFunctor(java.net.URLEncoder.encode(s)));
	me.nthAtom(0).remove();
	mem.relink(res, 0, me, 1);
	me.remove();
	:](S).

///////////////////////////////////////////////////////////////////////////
//とりあえず perl の CGI.pm を目指して作ってみる

/**
 * html のヘッダ部の文字列を生成する
 */
H=cgi.start_html(Title) :- H=string.replace([:
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-2022-JP">
<link rel="stylesheet" type="text/css" href="default.css">
<title>$Title</title>
</head>
<body>
<h1>$Title</h1>
:], "\\$Title", Title).

/**
 * html のフッタ部の文字列を生成する
 */
H=cgi.end_html :- H=[:
</body>
</html>
:].

/**
 * h1 タグを生成する
 */
H=cgi.h1(S) :- H=string.join("", ["<h1>", S, "</h1>"]).

/**
 * h2 タグを生成する
 */
H=cgi.h2(S) :- H=string.join("", ["<h2>", S, "</h2>"]).

/**
 * h3 タグを生成する
 */
H=cgi.h3(S) :- H=string.join("", ["<h3>", S, "</h3>"]).
}.
