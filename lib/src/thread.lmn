
/**
  Coyright(C) 2006 Ueda Laboratory LMNtal Group, All rights reserved.
  $Author: Kei MURAYAMA $

*/

{
module(thread).

	/*
		If the membrane using threads becomes stable,
		collect processes from threads.
	{
		system_ruleset.
		{thread(N,{$p,@p, thread.created}), $q,@q}/ :- int(N) | {$p,$q,@p,@q}.
	}.
	*/
	
	/*
		thread.create(N).
		Create N threads.
	*/
	thread.create(N) :- N>0 | thread.num(N), thread.cre(N).
	thread.cre(N) :- N>0 | thread.cre(N-1), thread(N,{}@"localhost").
	thread.cre(0) :- thread.created.

	/*
		thread.at(N, {atoms or rules}).
		Create atoms or rules at a thread numbered N.
	*/
	thread_at@@
	thread.at(N,M),thread.created :- int(N) | thread.created,M=[:/*inline*/
			int num = ((IntegerFunctor)me.nthAtom(0).getFunctor()).intValue();
			Membrane fromMem = me.nthAtom(1).nthAtom(0).nthAtom(1).getMem();
			Atom re = me.nthAtom(1).nthAtom(0).nthAtom(1);
			re.dequeue();
			me.nthAtom(1).nthAtom(0).remove();
			me.nthAtom(1).remove();
			Iterator it = me.getMem().atomIteratorOfFunctor(new SymbolFunctor("thread",2));
			while(it.hasNext()){
				Atom th = (Atom)(it.next());
				if(((IntegerFunctor)(th.nthAtom(0).getFunctor())).intValue()==num+1){
					Membrane toMem = th.nthAtom(1).nthAtom(0).nthAtom(1).getMem();
					toMem.moveCellsFrom(fromMem);
					toMem.copyRulesFrom(fromMem);
					toMem.activate();
					fromMem.getParent().removeMem(fromMem);
				}
			}

			me.nthAtom(0).remove();
			re.remove();
			me.remove();
			:](N).

	/*
		thread.any({atoms or rules}).
		Create atoms or rules at a thread randomly selected.
	*/
	thread_any@@
	thread.any(M),thread.created :- thread.created,M=[:/*inline*/
			Membrane fromMem = me.nthAtom(0).nthAtom(0).nthAtom(1).getMem();
			Atom re = me.nthAtom(0).nthAtom(0).nthAtom(1);
			re.dequeue();
			me.nthAtom(0).nthAtom(0).remove();
			me.nthAtom(0).remove();
			Iterator it = me.getMem().atomIteratorOfFunctor(new SymbolFunctor("thread",2));
			if(it.hasNext()){
				Atom th = (Atom)(it.next());
				Membrane toMem = th.nthAtom(1).nthAtom(0).nthAtom(1).getMem();
				toMem.moveCellsFrom(fromMem);
				toMem.copyRulesFrom(fromMem);
				toMem.activate();
				fromMem.getParent().removeMem(fromMem);
			}
			re.remove();
			me.remove();
			:].

	/*
		thread.all({atoms or rules}).
		Create atoms or rules at all threads.
	*/
	thread_all@@
	thread.all(M),thread.created  :- thread.created,M=[:/*inline*/
			Membrane fromMem = me.nthAtom(0).nthAtom(0).nthAtom(1).getMem();
			Atom re = me.nthAtom(0).nthAtom(0).nthAtom(1);
			re.dequeue();
			me.nthAtom(0).nthAtom(0).remove();
			me.nthAtom(0).remove();
			Iterator it = me.getMem().atomIteratorOfFunctor(new SymbolFunctor("thread",2));
			while(it.hasNext()){
				Atom th = (Atom)(it.next());
				Membrane toMem = th.nthAtom(1).nthAtom(0).nthAtom(1).getMem();
				toMem.copyCellsFrom2(fromMem);
				toMem.copyRulesFrom(fromMem);
				toMem.activate();
			}
			fromMem.getParent().removeMem(fromMem);
			re.remove();
			me.remove();
			:].
	
}.


/*
	example showing the use.
*/

%{
%	thread.create(4).
%	thread.all({norm(0)}).
%	generate(500).
%	generate(X) :- X>0 | thread.at(X mod 4,{n(integer.rnd(100))}), generate(X-1).
%	thread.all({norm(Y), n(X) :- int(X),Z=X*X+Y | norm(Z)}).
%	norm(N0), norm(N1) :- norm(N0+N1).
%}
