/* ***************************************** */
/* ** prefix notation to tree ************** */
/* ***************************************** */

/* initialize */
R = pre2tree(X) :- R = pre2tree([],X).

/* initialize for operator */
R = pre2tree(ST,[op(TY,AR)|CDR]) :- int(AR) | R = pre2tree(ST,[op(TY,AR,Q,Q)|CDR]).

/* initialize for number */
R = pre2tree(ST,[CAR|CDR]) :- int(CAR) | R = pre2tree(ST,[op(num,0,[CAR|N],N)|CDR]).

/* push operator */
R = pre2tree(ST,[op(TY,AR,Q,Z)|CDR]) :- R = pre2tree([op(TY,AR,Q,Z)|ST],CDR).

/* push operand into operator */
R = pre2tree([op(TY,AR,Q,Z)|ST],[opf(TY1,ARG)|CDR]) :-
	int(AR), AR=\=0, AR1=AR-1 |
    R = pre2tree([op(TY,AR1,Q,N)|ST],CDR), Z=[opf(TY1,ARG)|N].

/* pop operator(filled) (it will be used as operand) */
R = pre2tree([op(TY,AR,Q,Z)|ST],CDR) :-
	int(AR), AR=:=0 |
    R = pre2tree(ST,[opf(TY,Q)|CDR]), Z=[].

/* finalize */
R = pre2tree([],[opf(TY,ARG)]) :- R = opf(TY,ARG).


/* ***************************************** */
/* ** infix notation to tree *************** */
/* ***************************************** */


/* ***************************************** */
/* ** postfix notation to tree ************* */
/* ***************************************** */

/* initialize */
R = post2tree(X) :- R = post2tree([],X).

/* initialize for operator */
R = post2tree(ST,[op(TY,AR)|CDR]) :- R = post2tree(ST,[op(TY,AR,[])|CDR]).

/* initialize for number */
R = post2tree(ST,[CAR|CDR]) :- int(CAR) | R = post2tree(ST,[op(num,0,[CAR])|CDR]).

/* push operand(filled operator) to stack */
R = post2tree(ST,[op(TY,0,ARG)|CDR]) :- R = post2tree([opf(TY,ARG)|ST],CDR).

/* set operand into operator */
R = post2tree([OPR|ST],[op(TY,AR,ARG)|CDR]) :-
	int(AR), AR=\=0, AR1=AR-1 |
    R = post2tree(ST,[op(TY,AR1,[OPR|ARG])|CDR]).

/* finalize */
R = post2tree([opf(TY,ARG)],[]) :- R = opf(TY,ARG).


/* ***************************************** */
/* ** tree to prefix notation ************** */
/* ***************************************** */

/* length of list(list will be back from L2) */
R = length(L,L2) :- R = length(L,0,L2).
R = length([],N,L2) :- R = N, L2 = [].
R = length([CAR|CDR],N,L2) :- M=N+1 | R = length(CDR,M,N2), L2 = [CAR|N2].

/* initialize */
R = tree2pre(X) :- R = tree2pre(X,[]).

/* exchange of node */
R = tree2pre(opf(num,[X]),TAIL) :- int(X) | R = [X|TAIL].
R = tree2pre(opf(TY,ARG),TAIL) :- R = [op(TY,length(ARG,ARG2))|tree2prearg(ARG2,TAIL)].

/* recursion for argument */
R = tree2prearg([CAR|CDR],TAIL) :- R = tree2pre(CAR,N), N=tree2prearg(CDR,TAIL).
R = tree2prearg([],TAIL) :- R = TAIL.


/* ***************************************** */
/* ** tree to infix notation *************** */
/* ***************************************** */

/* initialize */
R = tree2in(X) :- R = tree2in(X,[]).

/* exchange of node */
R = tree2in(opf(num,[X]),TAIL) :- int(X) | R = [X|TAIL].
/* one term operater */
R = tree2in(opf(TY,[X]),TAIL) :- R = ['(',op(TY,1)|tree2in(X,[')'|TAIL])].
/* two or more term operator */
R = tree2in(opf(TY,[X|Y]),TAIL) :-
	R = ['('|tree2in(X,[op(TY,length(Y,1,Y2))|N])], N = tree2inarg(Y2,[')'|TAIL]).

/* recursion for argument */
R = tree2inarg([CAR|CDR],TAIL) :- R = tree2in(CAR,N), N = tree2inarg(CDR,TAIL).
R = tree2inarg([],TAIL) :- R = TAIL.


/* ***************************************** */
/* ** tree to postfix notation ************* */
/* ***************************************** */

/* initialize */
R = tree2post(X) :- R = tree2post(X,[]).

/* exchange of node */
R = tree2post(opf(num,[X]),TAIL) :- int(X) | R = [X|TAIL].
R = tree2post(opf(TY,ARG),TAIL) :- R = tree2postarg(ARG2,[op(TY,length(ARG,ARG2))|TAIL]).

/* recursion for argument */
R = tree2postarg([CAR|CDR],TAIL) :- R = tree2post(CAR,N), N=tree2postarg(CDR,TAIL).
R = tree2postarg([],TAIL) :- R = TAIL.


/* ***************************************** */
/* ** evaluate tree ************************ */
/* ***************************************** */

/* evaluate arguments */
R = eval(opf(OP,ARG)) :- R = evaled(opf(OP,evalarg(ARG))).
R = evalarg([CAR|CDR]) :- R = [eval(CAR)|evalarg(CDR)].
R = evalarg([]) :- R = [].

/* evaluate operator */
R = evaled(opf(num,[X])) :- int(X) | R = X.
R = evaled(opf('+',[X,Y])) :- Z=X+Y | R = Z.
R = evaled(opf('*',[X,Y])) :- Z=X*Y | R = Z.
R = evaled(opf('-',[X,Y])) :- Z=X-Y | R = Z.


/* ***************************************** */
/* ** user program ************************* */
/* ***************************************** */

//pre = eval(pre2tree([op('+',2),op('*',2),2,3,op('-',2),4,5])).
in = tree2in(post2tree([5,9,8,op('+',2),4,6,op('*',2),op('*',2),7,op('+',2),op('*',2)])).
