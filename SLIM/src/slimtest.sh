#!/bin/bash

# slimtest.sh
# 2007/09/13 sasaki

# ---- 概要 ----
# SLIMの吐き出した結果が正しいかどうかを判定するスクリプトです.
#
# 広戸くんのハッシュコード算出器を用いて, 与えられたLMNtalコードをJava処理系上で実行して
# 得られるグラフ構造のハッシュ値h_aと, SLIM上で実行して得られるグラフ構造のハッシュ値h_b
# をそれぞれn回計算し(nの値はデフォルトで1), n回とも h_a = h_b であったならば
# "success", そうでない場合は "failure" を返します.
#
# ---- 使用例 ----
#   (hoge.lmn) {a, a:-b}.
#   (SLIMの吐き出した結果 (slim.out)) {b, @601}
#   のもとで
#   $ ./slimtest.sh hoge.lmn slim.out
#   success
#
# (注) lmntal実行ファイルへのパスを通しておいてください

arg1=$1
arg2=$2
calchash="__tmp_mhash.lmn"

# -*- if the result is doubtful, make the value of "n" a greater one -*-
n=1

if [ ! -f "$arg1" ] || [ ! -f "$arg2" ]; then
	echo Usage:
	printf "\t$0 [LMNtal Source] [Result (generated by SLIM)]\n"
	exit 1
fi

if [ -f "$calchash" ]; then
	echo File open error: remove "$calchash" before executing this program
	exit 1
fi

lmn_source="$arg1"
result_slim="$arg2"

# ----------------------- #
#  build hash calculator  #
# ----------------------- #
build_mhash_lmn() {
	echo "/* (c) Kohei HIROTO 07/01/16 */{module(mhash). mhash.use:-. [:/*inline_define*/ import java.util.*; import util.*; class MembraneHashCodeCalculator {static int calculate(Membrane m) {return calculate(m, new HashMap<Membrane, Integer>());}private static int calculate(Membrane m, Map<Membrane, Integer> m2hc) {final long MAX_VALUE = Integer.MAX_VALUE;long add = 3412;long mult = 3412;Atom a = null;Membrane mm = null;QueuedEntity q = null;Set<QueuedEntity> contents = new HashSet<QueuedEntity>(), toCalculate = new HashSet<QueuedEntity>(), calculated = new HashSet<QueuedEntity>();for (Iterator i = m.atomIterator(); i.hasNext(); ) {a = (Atom) i.next();if (a.getFunctor().isOutsideProxy() || a.getFunctor().isInsideProxy()) {continue;}contents.add(a);}for (Iterator i = m.memIterator(); i.hasNext(); ) {mm = (Membrane) i.next();contents.add(mm);m2hc.put(mm, calculate(mm, m2hc));}while (!contents.isEmpty()) {q = contents.iterator().next();contents.remove(q);long mol = -1, mol_add = 0, mol_mult = 41, temp = 0;toCalculate.clear();calculated.clear();toCalculate.add(q);while (!toCalculate.isEmpty()) {q = toCalculate.iterator().next();calculated.add(q);toCalculate.remove(q);if (q instanceof Atom) {a = (Atom) q;temp = a.getFunctor().hashCode();int arity = a.getFunctor().getArity();for (int k = 0; k < arity; k++) {temp *= 31;Link link = a.getArg(k);if (link.getAtom().getFunctor().isInsideProxy()) {Atom inside = link.getAtom();int pos = link.getPos() + 1;temp += (inside.getFunctor().hashCode() * pos);} else if (link.getAtom().getFunctor().isOutsideProxy()) {int t = 0;mm = link.getAtom().nthAtom(0).getMem();if (!calculated.contains(mm)) {toCalculate.add(mm);}while (link.getAtom().getFunctor().isOutsideProxy()) {link = link.getAtom().nthAtom(0).getArg(1);mm = link.getAtom().getMem();t += m2hc.get(mm);t *= 13;}t *= link.getAtom().getFunctor().hashCode();t *= link.getPos() + 1;temp += t;} else {Atom linked = link.getAtom();if (!calculated.contains(linked)) {toCalculate.add(linked);}int pos = link.getPos() + 1;temp += (linked.getFunctor().hashCode() * pos);}}} else {Membrane mt = (Membrane) q;final int thisMembsHC = m2hc.get(mt);temp = thisMembsHC;Link link = null;for (Iterator i = mt.atomIteratorOfFunctor(Functor.INSIDE_PROXY); i.hasNext(); ) {Atom inside = (Atom) i.next();int s = 0;link = inside.nthAtom(0).getArg(1);if (link.getAtom().getFunctor().isOutsideProxy()) {mm = link.getAtom().nthAtom(0).getMem();if (!calculated.contains(mm)) {toCalculate.add(mm);}} else {a = link.getAtom();if (!calculated.contains(a)) {toCalculate.add(a);}}while (link.getAtom().getFunctor().isOutsideProxy()) {link = link.getAtom().nthAtom(0).getArg(1);s += m2hc.get(link.getAtom().getMem());s *= 13;}s += link.getAtom().getFunctor().hashCode();s *= link.getPos() + 1;int t = 0;link = inside.getArg(1);while (link.getAtom().getFunctor().isOutsideProxy()) {link = link.getAtom().nthAtom(0).getArg(1);t += m2hc.get(link.getAtom().getMem());t *= 13;}t *= link.getAtom().getFunctor().hashCode();t *= link.getPos() + 1;temp += thisMembsHC^t * s;}}mol_add += temp;mol_add %= MAX_VALUE;mol_mult *= temp;mol_mult %= MAX_VALUE;}mol = mol_add^mol_mult;contents.removeAll(calculated);add += mol;add %= MAX_VALUE;mult *= mol;mult %= MAX_VALUE;}return (int) (mult^add);}}:].H = mhash.hashCode(Memb, MR) :- H=[:/*inline*/Atom a = me.nthAtom(0).nthAtom(0);Membrane m = (Membrane) (a.getMem());int hashCode = MembraneHashCodeCalculator.calculate(m);Atom result = mem.newAtom(new IntegerFunctor(hashCode));mem.relinkAtomArgs(result, 0, me, 2);mem.unifyAtomArgs(me, 0, me, 1);me.remove();:](Memb, MR).}." > $calchash
}
build_mhash_lmn


# -------------- #
#  Main Routine  #
# -------------- #

#
# result_java
#    is the result of executing source LMNtal program on our
#    Java implementation.
lmntal "$lmn_source" > result_java

#
# remove all the rule contexts and then reshape the graph structure like below
#    e.g.
#        result_java: {a}, b. => Mem1={{a}, b}, hc(R1)=mhash.hashCode(Mem1,R1).
# this reshaped result_java (and result_slim) is inputed toward the
# hash value calculator and so we get the target hash value as hashvalue_java
echo Mem1=\{`sed -e "s/\(,[[:blank:]]*@[[:alnum:]]\{1,\}@*\)//g" result_java`\}, hc\(R1\)=mhash.hashCode\(Mem1,R1\). > result_java
echo Mem2=\{`sed -e "s/\(,[[:blank:]]*@[[:alnum:]]\{1,\}@*\)//g" "$result_slim"`\}, hc\(R2\)=mhash.hashCode\(Mem2,R2\). > result_slim


succflag=0

while [ "$succflag" -lt "$n" ]
do
	lmntal "$calchash" result_java > hashval_java
	set `sed -e "s/hc[[:blank:]]*(.[[:alnum:]]\{1,\},[[:blank:]]*\([[:digit:]]\{1,\}\))./\1/" hashval_java`
	hashval_java=$1

	lmntal "$calchash" result_slim > hashval_slim
	set `sed -e "s/hc[[:blank:]]*(.[[:alnum:]]\{1,\},[[:blank:]]*\([[:digit:]]\{1,\}\))./\1/" hashval_slim`
	hashval_slim=$1
	
	if [ "$hashval_java" -eq "$hashval_slim" ]; then
		succflag=$(($succflag+1))
	else
		break;
	fi
done

if [ "$succflag" -eq "$n" ]; then
	echo "success"
else
	echo "failure"
fi

rm -f result_java
rm -f result_slim
rm -f hashval_java
rm -f hashval_slim
rm -f "$calchash"

exit 0
