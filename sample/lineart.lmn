%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% LINE ART              by kudo
%
% 2004/ 9/ 6
%
% おなじみ「ラインアート」のようなもの。
% 一定時間ごとに線を描画するリーダーと、
% それを追いかけて消していくアンカーが、
% それぞれ二端点の直交座標で表現される。
% 端点はウィンドウの端に来ると反射する。
% 初期、反射時に速度はランダムで決まる。
% 色は一定に変化するが初期値は赤に固定。
% 線数、ウィンドウの大きさ、速度の幅は、
% それぞれソースの最初で定義されている。
% また線数分の端点座標を保持しているが、
% そのリストの先頭がアンカーに近い側だ。
%
% 原因はよくわからないがしばらくすると、
% 重くなりメモリオーバーになってしまう。
% 特に見かけ上増えているものは無いので、
% 何がメモリ上にあるのやら、わからない。
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% start -> initialize_leader -> initialize_all -> initializing_all -> initialized_all -> wait % 初期化
% wait -> next
% next -> run1 -> run2 -> run3 -> run4 ->             % 座標データの更新
% judge1h -> judge2h -> judge3h -> judge4h -> judgedh %
% judgedh -> judge1t
% judge1t -> judge2t -> judge3t -> judge4t -> judgedt % 反射判定
% judgedt -> recolor -> recolored -> draw             % 色変更
% draw -> wait
% exit -> terminated
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% leader = { headp(x(),y())  % 端点1の座標
%            tailp(x(),y())  % 端点2の座標
%            headv(x(),y())  % 端点1の速度
%            tailv(x(),y())  % 端点2の速度
%            color((),(),()} % 色
%
% anchor = { headp(x(),y())   % 端点1の座標
%            tailp(x(),y())}  % 端点2の座標
%
% points = [
%          { headp(x(),y())   % 端点1の座標
%            tailp(x(),y())}, % 端点2の座標
%            ...
%          ,last]
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{

io.use.

dust = {}.

counter(15).        % number of line
screen_width(640).  % width of screen
screen_height(480). % height of screen
velocity(15).       % max velocity of leader or anchor

points = [last].
leader = {not_initialized}.
anchor = {not_initialized}.

color_phase(0).

initialize_leader, dust = {$d,@d}, leader = {$l,@l}, anchor = {$a,@a}, screen_width(W), screen_height(H), velocity(V) :-
int(W), int(H), int(V) |
initialize_all, screen_width(W), screen_height(H), velocity(V),
leader = {headp(x(integer.rnd(W-1)), y(integer.rnd(H-1))), headv(x(integer.rnd(V) + 1), y(integer.rnd(V) + 1)),
          tailp(x(integer.rnd(W-1)), y(integer.rnd(H-1))), tailv(x(integer.rnd(V) + 1), y(integer.rnd(V) + 1)),
          color(255,0,0)},
dust = {$d,$l,$a}.

initialize_all, points = LAST_LIST, last = POINTS, counter(CN) :- int(CN)|
initializing_all, points = [last], count(CN), counter(CN),
d = LAST_LIST, n = POINTS.

initializing_all, points = LIST, count(CN), leader = { headp(x(LHPX), y(LHPY)), tailp(x(LTPX), y(LTPY)),$l,@r}/ :-
int(CN), int(LHPX), int(LHPY), int(LTPX), int(LTPY), CN > 0|
initializing_all,
points = [{headp(x(LHPX),y(LHPY)), tailp(x(LTPX),y(LTPY))}|LIST],
 leader = {headp(x(LHPX),y(LHPY)), tailp(x(LTPX),y(LTPY)),$l},
count(CN - 1).

initializing_all, points = [{headp(x(PHPX), y(PHPY)), tailp(x(PTPX), y(PTPY)), $p}|REST], count(0) :-
int(PHPX), int(PHPY), int(PTPX), int(PTPY)|
initialized_all,
 anchor = {headp(x(PHPX),y(PHPY)),tailp(x(PTPX),y(PTPY))},
points = [{headp(x(PHPX),y(PHPY)),tailp(x(PTPX),y(PTPY)),$p}|REST].

initialized_all :- wait.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

next :- run1.

run1, % アンカーの座標を更新(リストの先頭から貰う)
 anchor = {headp(x(AHPX), y(AHPY)), tailp(x(ATPX), y(ATPY)), $a},
points = [{headp(x(PHPX), y(PHPY)), tailp(x(PTPX), y(PTPY)), $p}|REST] :-
	int(AHPX), int(AHPY), int(ATPX), int(ATPY),
	int(PHPX), int(PHPY), int(PTPX), int(PTPY)|
run2,
       anchor = {headp(x(PHPX), y(PHPY)), tailp(x(PTPX), y(PTPY)), $a},
points_after = [{headp(x(PHPX), y(PHPY)), tailp(x(PTPX), y(PTPY)), $p}|[lastafter]], points = REST.

run2, % リストの中身を更新(一つずつ前にずらす(後ろの要素から貰う))
points = [{headp(x(PHPX), y(PHPY)), tailp(x(PTPX), y(PTPY)), $p}|REST],
     X = [{headp(x(OHPX), y(OHPY)), tailp(x(OTPX), y(OTPY)), $o}|[lastafter]] :-
	int(PHPX), int(PHPY), int(PTPX), int(PTPY),
	int(OHPX), int(OHPY), int(OTPX), int(OTPY)|
run2,
     X = [{headp(x(PHPX), y(PHPY)), tailp(x(PTPX), y(PTPY)), $o},
          {headp(x(PHPX), y(PHPY)), tailp(x(PTPX), y(PTPY)), $p}|[lastafter]], points = REST.

run2, points = [last], points_after = LIST, X = lastafter :- run3, points = LIST, X = last.

run3, % リストの末尾を更新(リーダーから貰う)
    P = [{headp(x(PHPX), y(PHPY)), tailp(x(PTPX), y(PTPY)), $p}|[last]],
leader = {headp(x(LHPX), y(LHPY)), tailp(x(LTPX), y(LTPY)), $l} :-
	int(PHPX), int(PHPY), int(PTPX), int(PTPY),
	int(LHPX), int(LHPY), int(LTPX), int(LTPY)|
run4,
    P = [{headp(x(LHPX), y(LHPY)), tailp(x(LTPX), y(LTPY)), $p}|[last]],
leader = {headp(x(LHPX), y(LHPY)), tailp(x(LTPX), y(LTPY)), $l}.

run4,
leader = {headp(x(HPX), y(HPY)), headv(x(HVX), y(HVY)),
        tailp(x(TPX), y(TPY)), tailv(x(TVX), y(TVY)), $l } :-
int(HPX),int(HPY),int(HVX),int(HVY),
int(TPX),int(TPY),int(TVX),int(TVY)|
judge,
leader = {headp(x(HPX + HVX), y(HPY + HVY)), headv(x(HVX), y(HVY)),
          tailp(x(TPX + TVX), y(TPY + TVY)), tailv(x(TVX), y(TVY)), $l }.

judge :- judge1h.

judge1h, screen_width(W), velocity(V),
         leader = {headp(x(X    ), y(Y)), headv(x(VX                 ), y(VY)), $l[Y, VY], @l}/ :- X >= W, int(VX), int(V) |
judge2h, leader = {headp(x(W - 1), y(Y)), headv(x(-1 - integer.rnd(V)), y(VY)), $l[Y, VY]},screen_width(W), velocity(V).
judge1h, leader = {headp(x(X), y(Y)), $l[Y], @l}/, screen_width(W) :- X < W |
judge2h, leader = {headp(x(X), y(Y)), $l[Y]    } , screen_width(W).

judge2h, leader = {headp(x(X), y(Y)), headv(x(VX                ), y(VY)), $l[Y, VY], @l}/, velocity(V) :-
 X =< 0, int(VX), int(V) |
judge3h, leader = {headp(x(0), y(Y)), headv(x(integer.rnd(V) + 1), y(VY)), $l[Y, VY]}, velocity(V).
judge2h, leader = {headp(x(X), y(Y)), $l[Y], @l}/ :- X > 0|
judge3h, leader = {headp(x(X), y(Y)), $l[Y]    }.

judge3h, leader = {headp(x(X), y(Y    )), headv(x(VX), y(VY                 )), $l[X, VX], @l}/,
 screen_height(H), velocity(V) :- Y >= H, int(VY), int(V) |
judge4h, leader = {headp(x(X), y(H - 1)), headv(x(VX), y(-1 - integer.rnd(V))), $l[X, VX]}, screen_height(H), velocity(V).
judge3h, leader = {headp(x(X), y(Y)), $l[X], @l}/, screen_height(H) :- Y < H |
judge4h, leader = {headp(x(X), y(Y)), $l[X]    } , screen_height(H).

judge4h, leader = {headp(x(X), y(Y)), headv(x(VX), y(VY                )), $l[X, VX], @l}/, velocity(V) :-
 Y =< 0, int(VY), int(V) |
judgedh, leader = {headp(x(X), y(0)), headv(x(VX), y(integer.rnd(V) + 1)), $l[X, VX]}, velocity(V).
judge4h, leader = {headp(x(X), y(Y)), $l[X], @l}/ :- Y > 0|
judgedh, leader = {headp(x(X), y(Y)), $l[X]    }.

judgedh :- judge1t.

judge1t, leader = {tailp(x(X    ), y(Y)), tailv(x(VX                 ), y(VY)), $l[Y, VY], @l}/,
 screen_width(W), velocity(V) :- X >= W, int(VX), int(V) |
judge2t, leader = {tailp(x(W - 1), y(Y)), tailv(x(-1 - integer.rnd(V)), y(VY)), $l[Y, VY]}, screen_width(W), velocity(V).
judge1t, leader = {tailp(x(X), y(Y)), $l[Y], @l}/, screen_width(W) :- X < W |
judge2t, leader = {tailp(x(X), y(Y)), $l[Y]    } , screen_width(W).

judge2t, leader = {tailp(x(X), y(Y)), tailv(x(VX                ), y(VY)), $l[Y, VY], @l}/, velocity(V) :-
 X =< 0, int(VX), int(V) |
judge3t, leader = {tailp(x(0), y(Y)), tailv(x(integer.rnd(V) + 1), y(VY)), $l[Y, VY]}, velocity(V).
judge2t, leader = {tailp(x(X), y(Y)), $l[Y], @l}/ :- X > 0|
judge3t, leader = {tailp(x(X), y(Y)), $l[Y]    }.

judge3t, leader = {tailp(x(X), y(Y    )), tailv(x(VX), y(VY                 )), $l[X, VX], @l}/,
 screen_height(H), velocity(V) :- Y >= H, int(VY), int(V) |
judge4t, leader = {tailp(x(X), y(H - 1)), tailv(x(VX), y(-1 - integer.rnd(V))), $l[X, VX]}, screen_height(H), velocity(V).
judge3t, leader = {tailp(x(X), y(Y)), $l[X], @l}/, screen_height(H) :- Y < H |
judge4t, leader = {tailp(x(X), y(Y)), $l[X]    } , screen_height(H).

judge4t, leader = {tailp(x(X), y(Y)), tailv(x(VX), y(VY                )), $l[X, VX], @l}/, velocity(V) :-
 Y =< 0, int(VY), int(V) |
judgedt, leader = {tailp(x(X), y(0)), tailv(x(VX), y(integer.rnd(V) + 1)), $l[X, VX]}, velocity(V).
judge4t, leader = {tailp(x(X), y(Y)), $l[X], @l}/ :- Y > 0|
judgedt, leader = {tailp(x(X), y(Y)), $l[X]    }.

judgedt, leader = {$l,@l}/ :- recolor, leader = {$l}.

recolor,  leader = {color(R, G,      B), $l[R, B]}, color_phase(CP) :- int(G), CP / 5 = 0 |
recolored,leader = {color(R, G + 51, B), $l[R, B]}, color_phase(CP + 1).

recolor,  leader = {color(R,      G, B), $l[G, B]}, color_phase(CP) :- int(R), CP / 5 = 1 |
recolored,leader = {color(R - 51, G, B), $l[G, B]}, color_phase(CP + 1).

recolor,  leader = {color(R, G, B     ), $l[R, G]}, color_phase(CP) :- int(B), CP / 5 = 2 |
recolored,leader = {color(R, G, B + 51), $l[R, G]}, color_phase(CP + 1).

recolor,  leader = {color(R, G,      B), $l[R, B]}, color_phase(CP) :- int(G), CP / 5 = 3 |
recolored,leader = {color(R, G - 51, B), $l[R, B]}, color_phase(CP + 1).

recolor,  leader = {color(R,      G, B), $l[G, B]}, color_phase(CP) :- int(R), CP / 5 = 4 |
recolored,leader = {color(R + 51, G, B), $l[G, B]}, color_phase(CP + 1).

recolor,  leader = {color(R, G, B     ), $l[R, G]}, color_phase(CP) :- int(B), CP / 5 = 5 |
recolored,leader = {color(R, G, B - 51), $l[R, G]}, color_phase(CP + 1).

recolored, color_phase(CP) :- CP >= 30 | draw, color_phase(0).
recolored, color_phase(CP) :- CP <  30 | draw, color_phase(CP).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Java Inline Code
%

[:/*inline_define*/

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

// フレーム

class LineArtFrame extends JFrame implements MouseListener{
	
	// 所属膜
	
	final Membrane mem;

	// 枠に関する数値
	
	final int SCREEN_WIDTH;
	final int SCREEN_HEIGHT;
	final int FRAMEBAR_LEFT;
	final int FRAMEBAR_TOP;
    final int FRAMEBAR_RIGHT;
    final int FRAMEBAR_BOTTOM;
	
	boolean flgAction;
	boolean flgScreenClear;

	//コンストラクタ
	
	public LineArtFrame(Membrane targetMem, int screen_width, int screen_height){

		flgAction = false;
		flgScreenClear = true;
		
		setTitle("Line Art");
		setResizable(false);
		addMouseListener(this);
		this.mem = targetMem;
		setVisible(true);
		Insets ins = getInsets();
		FRAMEBAR_LEFT = ins.left;
		FRAMEBAR_RIGHT = ins.right;
		FRAMEBAR_TOP = ins.top;
		FRAMEBAR_BOTTOM = ins.bottom;
		SCREEN_WIDTH = screen_width;
		SCREEN_HEIGHT = screen_height;
		//ウィンドウサイズを設定(描画領域がVGAになるように)
		
		setBounds(100, 100, SCREEN_WIDTH + FRAMEBAR_LEFT + FRAMEBAR_RIGHT, SCREEN_HEIGHT + FRAMEBAR_TOP + FRAMEBAR_BOTTOM);
		
	}

	public void drawLine(int x1, int y1, int x2, int y2, Color color){
		gr.setColor(color);
		gr.drawLine(FRAMEBAR_LEFT + x1, FRAMEBAR_TOP + y1, FRAMEBAR_LEFT + x2, FRAMEBAR_TOP +y2);
	}
	
	Image img;
	Graphics gr;
	
	public void update(Graphics g){
		if(img == null){
			img = createImage(SCREEN_WIDTH + FRAMEBAR_LEFT, SCREEN_HEIGHT + FRAMEBAR_TOP);
			gr = img.getGraphics();
		}
		if(flgScreenClear){
			gr.setColor(Color.black);
			gr.fillRect(FRAMEBAR_LEFT + 0, FRAMEBAR_TOP + 0, SCREEN_WIDTH, SCREEN_HEIGHT);
			flgScreenClear = false;
		}
		g.drawImage(img, 0, 0, this);
	}
	
	public void mouseEntered(MouseEvent e){}
	public void mouseExited(MouseEvent e){}
	public void mousePressed(MouseEvent e){}
	public void mouseReleased(MouseEvent e){}
	public void mouseClicked(MouseEvent e){
		switch(e.getButton()){
		/*case MouseEvent.BUTTON1://左クリックで再スタート
			mem.asyncLock();
			mem.newAtom(new Functor("refresh",0));
			mem.asyncUnlock();
			flgAction = true;
			break;*/
		case MouseEvent.BUTTON3://右クリックで終了
			
			flgAction = true;
			mem.asyncLock();
			mem.newAtom(new Functor("exit",0));
			mem.asyncUnlock();
			break;
		}
	}

	public void waiting(){
		if(flgAction)return;
		repaint();
		try{
			Thread.sleep(100);
		}catch(InterruptedException e){}
		//mem.asyncLock();
		mem.newAtom(new Functor("next",0));
		//mem.asyncUnlock();
	}

}

:].

start.

start, screen_width(W), screen_height(H) :- int(W), int(H) | [:/*inline*/
	int width = Integer.parseInt(me.nth(0));
	int height = Integer.parseInt(me.nth(1));
	LineArtFrame frame = new LineArtFrame((Membrane)mem, width, height);
	Atom tmpa1 = mem.newAtom(new Functor("frame", 1));
	Atom tmpa2 = mem.newAtom(new ObjectFunctor(frame));
	mem.newLink(tmpa1, 0, tmpa2, 0);
	mem.removeAtom(me.nthAtom(0));
	mem.removeAtom(me.nthAtom(1));
	mem.removeAtom(me);
	mem.makePerpetual();
:](W, H), initialize_leader, screen_width(W), screen_height(H).

wait, frame(F) :- class(F, "LineArtFrame") |
	frame(F), [:/*inline*/
	ObjectFunctor framefunc = (ObjectFunctor)me.nthAtom(0).getFunctor();
	LineArtFrame frame = (LineArtFrame)framefunc.getObject();
	frame.waiting();
	mem.removeAtom(me.nthAtom(0));
	mem.removeAtom(me);
:](F).

% リーダーとアンカーを描画する.
draw, frame(F), leader = {headp(x(LHPX), y(LHPY)), tailp(x(LTPX), y(LTPY)), color(R,G,B), $l},
                anchor = {headp(x(AHPX), y(AHPY)), tailp(x(ATPX), y(ATPY)), $a}
	:- class(F, "LineArtFrame"),
	int(LHPX), int(LHPY), int(LTPX), int(LTPY),
	int(AHPX), int(AHPY), int(ATPX), int(ATPY),
	int(R), int(G), int(B) |
	frame(F),[:/*inline*/
	ObjectFunctor framefunc = (ObjectFunctor)me.nthAtom(0).getFunctor();
	LineArtFrame frame = (LineArtFrame)framefunc.getObject();
	int lhx = Integer.parseInt(me.nth(1));
	int lhy = Integer.parseInt(me.nth(2));
	int ltx = Integer.parseInt(me.nth(3));
	int lty = Integer.parseInt(me.nth(4));
	int ahx = Integer.parseInt(me.nth(5));
	int ahy = Integer.parseInt(me.nth(6));
	int atx = Integer.parseInt(me.nth(7));
	int aty = Integer.parseInt(me.nth(8));
	int r = Integer.parseInt(me.nth(9));
	int g = Integer.parseInt(me.nth(10));
	int b = Integer.parseInt(me.nth(11));
	frame.drawLine(lhx,lhy,ltx,lty,new Color(r,g,b));
	frame.drawLine(ahx,ahy,atx,aty,Color.black);
	mem.removeAtom(me.nthAtom(0));
	mem.removeAtom(me.nthAtom(1));
	mem.removeAtom(me.nthAtom(2));
	mem.removeAtom(me.nthAtom(3));
	mem.removeAtom(me.nthAtom(4));
	mem.removeAtom(me.nthAtom(5));
	mem.removeAtom(me.nthAtom(6));
	mem.removeAtom(me.nthAtom(7));
	mem.removeAtom(me.nthAtom(8));
	mem.removeAtom(me.nthAtom(9));
	mem.removeAtom(me.nthAtom(10));
	mem.removeAtom(me.nthAtom(11));
	mem.removeAtom(me);
	:](F, LHPX, LHPY, LTPX, LTPY, AHPX, AHPY, ATPX, ATPY, R, G, B),wait,
	leader = {headp(x(LHPX), y(LHPY)), tailp(x(LTPX), y(LTPY)), color(R, G, B), $l},
	anchor = {headp(x(AHPX), y(AHPY)), tailp(x(ATPX), y(ATPY)),$a}.

% 終了.
exit, frame(F) :- class(F, "LineArtFrame") |
	[:/*inline*/
	ObjectFunctor framefunc = (ObjectFunctor)me.nthAtom(0).getFunctor();
	LineArtFrame frame = (LineArtFrame)framefunc.getObject();
	frame.setVisible(false);
	frame.dispose();
	mem.removeAtom(me.nthAtom(0));
	mem.removeAtom(me);
	:](F),terminated.

}.

{terminated,$p,@p} :- {$p}.
