printseq{

printseq1@@
stdout(X, Y), R = io_print(Y, Z) :- string(Z) |  R = stdout(io.print(X, Z)).

printseq2@@
stdout(X, Y), R = io_print_line(Y, Z) :- string(Z) | R = stdout( io.print_line(X, Z) ).
}.

outputInit{
io.use.
outport(stdout(io.stdout)).

outport(X), rulesetList(Y) :- outport = print_rulesetList (X, Y).

printRulesetListNil@@
R = print_rulesetList(X, []) :- R = X.

printRulesetListInit@@
R = print_rulesetList(X, 
  [initRuleset{ ruleset($n), 
  ruleList = [ rule{ compiledRule($insts) } ] } | T])
  :- int($n) 
  |  R = print_rulesetList(
       	 print_insts(
	 io_print_line(
       	 io_print_line(
       	 io_print(X, "Compiled Ruleset @"), str.from($n)),
	 	     "Compiled Rule\n\t--atommatch:\n\t--memmatch:\n\t--body:L0:"),	 
	 	     $insts),
	 	     T ).

printRulesetList@@
R = print_rulesetList(X, 
  [ruleset{ ruleset($n), ruleList($initRS), @initRS } | T])
  :- int($n) 
  |  R = print_rulesetList(
       	 print_ruleList(
       	 io_print_line(
       	 io_print(X, "Compiled Ruleset @"), str.from($n)),
	   	     $initRS),
	   	     T).


printRuleListNil@@
R = print_ruleList(X, []) :- R = X.


printRuleList@@
R = print_ruleList(X, 
  [ { optimizedRule($insts), +A } | T]),
  optimized_rule(A)
  :- R = print_ruleList(
         print_insts(
	 io_print(X, "Compiled Rule\n\t--atommatch:\n\t--memmatch:\n"),
	 	     $insts),
		     T).	     
	 
}.

/*
outputRuleSet{

outputRuleSet@@
outport(X), optimized_ruleset({ruleset($n), $rules})
  :- int($n)
  |  outport =
       print_ruleset(
       io_print_line(
       io_print(X, "Compiled Ruleset @"), str.from($n))
       , optimized_ruleset({$rules}) ).

printRuleset1@@
R = print_ruleset(X, optimized_ruleset({})) :- R = X.
printRuleset2@@
R = print_ruleset(X, 
  optimized_ruleset({optimizedRule($insts). $rules[], @rules}))
  :- ground($insts)
  |  R = print_ruleset(
         print_insts(
	 io_print(X, "Compiled Rule \n\t--atommatch:\n\t--memmatch:\n"),
                      $insts),
	              optimized_ruleset({$rules[]})).
}.
*/

outputInsts{


print_insts_nil@@
R = print_insts(X, []) :- R = X.

print_insts@@
R = print_insts(X, [[$inst, OpList] | T ])
  :- unary($inst)
  | R = print_insts(
              io_print_line(
    	      io_print(
	      io_print(
              io_print(X, "\t\t"),
	      		  str.from($inst) ),
			  "\t" ), 
			  list_to_string(OpList)),
			  T).



list_to_string1@@
Ret = list_to_string( [] ) :- Ret = "[]".
list_to_string2@@
Ret = list_to_string( [X | T] )
 :- Ret = str.concat("[", inner_list_to_string([ X | T ])).


inner_list_to_string1@@
Ret = inner_list_to_string([]) :- Ret = "]".

inner_list_to_string2@@
Ret = inner_list_to_string([ I, J | T])
 :- Ret = str.concat( str.concat(elm_to_string(I), ", "),
   inner_list_to_string([J | T])).

inner_list_to_string3@@
Ret = inner_list_to_string([ I | [] ])
 :- Ret = str.concat( elm_to_string(I), inner_list_to_string([]) ).


elm_to_string1@@
Ret = elm_to_string(null) :- Ret = "null".

elm_to_string2@@
Ret = elm_to_string($i) :- int($i) | Ret = str.from($i).
Ret = elm_to_string(rulesetNum($i))
 :- int($i)
 | Ret = str.concat("@", str.from($i)).

elm_to_string3@@
Ret = elm_to_string(intFunctor($f, $i))
 :- int($f), int($i)
| Ret = str.concat( str.concat(str.from($f), "_"), str.from($i)).

elm_to_string_proxyFunctor@@
Ret = elm_to_string(proxyFunctor($f, $i))
 :- unary($f), int($i)
 | Ret = str.concat( str.concat( $f, "_"), str.from($i)).


elm_to_string_stringFunctor@@
Ret = elm_to_string(stringFunctor($f, $i))
 :- unary($f), int($i)
 | Ret = str.concat( str.concat( str.concat("\"", str.from($f)),
 "\"_"), str.from($i)).

elm_to_string_moduleFunctor@@
Ret = elm_to_string(moduleFunctor($f1, $f2, $i))
 :- unary($f1), unary($f2), int($i)
 | Ret = str.concat( str.concat( str.concat( str.concat(
     str.concat( "'", str.from($f1)), "'.'"), str.from($f2)),
     "'_"), str.from($i)).

elm_to_string4@@
Ret = elm_to_string(functor($f, $i))
 :- unary($f), int($i)
| Ret = str.concat(str.concat(str.concat("'", str.from($f)), "'_"),
  str.from($i)).

elm_to_string5@@
Ret = elm_to_string($i) :- string($i) 
  | Ret = str.concat( str.concat("\"", $i), "\"").


}.

outputSlash{
do.
printslash@@
do, outport(X) :- outport = io_print(X, "\nInline\n//").

printseq_slash@@
stdout(X, Y), R = io_print(Y, Z) :- string(Z) |  R = stdout(io.print(X, Z)).

}.

deleteIO{
freeIO@@
outport(X) :- io.free_port(io.close_port(X)).

delete_stdout@@
stdout(X, Y) :- X = Y.
}.



//seq.use.
io.use.
str.use.


/*
rulesets{$p[], @p}, 
outputInitRule1{$q[], @q}, outputInitRule2{@q2},
outputRuleSet{@r},
outputInsts{@insts},
outputSlash{$slash[], @slash},
deleteIO{@dio}
 :- ret = seq_run({seq_run, $p[]}, 
         [ {$q[], @q}, {@q2, @insts}, {@r,  @insts},
	 {$slash[], @slash}, {@dio} ]).
*/

rulesets{$p[], @p},
outputInit{$q, @q},
outputInsts{@insts},
outputSlash{$slash[], @slash},
deleteIO{@dio},
printseq{@printseq}
:- ret = seq_run( {$p[], @printseq, @p, $q, @q, @insts }, 
   [{$slash[], @slash}, {@dio}] ).

H=seq_run({$p, @r}/, [ {$z, @p} | Rest ]) :- H=seq_run({$p, $z, @p}, Rest).

H=seq_run({@p. $p.}/, []) :- H={$p}.
