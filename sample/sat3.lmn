% 改訂satソルバ
% 生成、検証を同時並行的に。
% ルールの順序による優先度を利用。
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 問題「簡単な例」
%c(1, {notx(1),notx(2)        }).
%c(2, {   x(1),notx(2),   x(1)}).
%m(2).   % 節の数
%var(2). % 変数の数
%gen_var(2).

unsolved.    % 解かれたかどうかのフラグ

preparing_space = {
unsolvable.
z(0).
}.

%%%%LMNtal rule%%%%

% 変数生成
preparing_space={$s[]     },gen_var(N)  :- int(N),N>0|
preparing_space={$s[],a(N)},gen_var(N-1).
preparing_space={$s[]},gen_var(N) :- int(N),N=0|
          space={$s[]}.

% 検証(複製に優先する)

% こっちが先
unsolved,m(M),space={ unsolvable,z(Z),$s[]} :- int(Z),int(M),Z=M |
  solved,m(M),space={   solvable,     $s[]},              % zがmに等しくなれば解
[[/*inline*/
	Atom l = mem.newAtom(new Functor(Long.toString(new GregorianCalendar().getTimeInMillis()),1));
	Atom e = mem.newAtom(new Functor("endtime",1));
	mem.newLink(l,0,e,0);
]].

% こっちが後
unsolved,c(M,{   x(Nx),$c[]}),space={  t(Nt),z(Z  )     ,$s[]} :- int(M),int(Nx),int(Nt),int(Z),Nx=Nt,Z=M-1|
unsolved,c(M,{   x(Nx),$c[]}),space={  t(Nt),z(Z+1)     ,$s[]}.
unsolved,c(M,{notx(Nx),$c[]}),space={  f(Nf),z(Z  )     ,$s[]} :- int(M),int(Nx),int(Nf),int(Z),Nx=Nf,Z=M-1|
unsolved,c(M,{notx(Nx),$c[]}),space={  f(Nf),z(Z+1)     ,$s[]}.

% 複製生成
unsolved,space={a(N),$v[]}                   :- int(N) |
unsolved,space={t(N),$v[]}, space={f(N),$v[]}.


%%%%%%%%%%%%%%%%%%% 以下 Java %%%%%%%%%%%%%%
[[/*inline_define*/
import java.io.*;
import java.util.*;
import java.lang.*;
]].

input.

% ファイルから読み込み
input :-
[[/*inline*/
	int n=0,m=0;
	int c_counter=0;
	try{
		BufferedReader bf = new BufferedReader(new InputStreamReader(new FileInputStream("c:/kudo/data.cnf")));
		while(bf.ready()){
			StringTokenizer st =new StringTokenizer(bf.readLine());
			String first = st.nextToken();
			if(first.equals("c"))continue;
			else if(first.equals("p")){
				if(!st.nextToken().equals("cnf")){System.out.println("give me cnf.");}
				else{
					n = Integer.parseInt(st.nextToken());
					m = Integer.parseInt(st.nextToken());
				}
				break;
			}
		}

		AbstractMembrane cmem[]= new AbstractMembrane[m];
		for(int i=0;i<m;i++){
			Atom c = mem.newAtom(new Functor("c",2));
			Atom c_m = mem.newAtom(new IntegerFunctor(i+1));
			cmem[i] = mem.newMem();
			Atom in = cmem[i].newAtom(Functor.INSIDE_PROXY);
			Atom out = mem.newAtom(Functor.OUTSIDE_PROXY);
			Atom plus = cmem[i].newAtom(new Functor("+",1));
			mem.newLink(c,0,c_m,0);
			mem.newLink(c,1,out,1);
			mem.newLink(out,0,in,0);
			mem.newLink(in,1,plus,0);
		}

		Atom v = mem.newAtom(new Functor("var",1));
		Atom v_n = mem.newAtom(new IntegerFunctor(n));
		mem.newLink(v,0,v_n,0);
		v = mem.newAtom(new Functor("gen_var",1));
		v_n = mem.newAtom(new IntegerFunctor(n));
		mem.newLink(v,0,v_n,0);
		Atom mm = mem.newAtom(new Functor("m",1));
		Atom mm_v = mem.newAtom(new IntegerFunctor(m));
		mem.newLink(mm,0,mm_v,0);

		while(bf.ready()){
			StringTokenizer st = new StringTokenizer(bf.readLine());
			while(st.hasMoreTokens()){
				int fv = Integer.parseInt(st.nextToken());
				Atom x,x_n;
				if(fv > 0){
					x = cmem[c_counter].newAtom(new Functor("x",1));
					x_n = cmem[c_counter].newAtom(new IntegerFunctor(fv));
					cmem[c_counter].newLink(x,0,x_n,0);
				}else if(fv < 0){
					x = cmem[c_counter].newAtom(new Functor("notx",1));
					x_n = cmem[c_counter].newAtom(new IntegerFunctor(-fv));
					cmem[c_counter].newLink(x,0,x_n,0);
				}else c_counter++;
			}
		}
		bf.close();
	}catch(IOException e){System.out.println("error : read file.");};
	Atom l=mem.newAtom(new Functor(Long.toString(new GregorianCalendar().getTimeInMillis()),1));
	Atom s=mem.newAtom(new Functor("starttime",1));
	mem.newLink(l,0,s,0);
	mem.removeAtom(me);
]].
% ファイルに出力

% 出力を最後に書くことで、解けない場合にも特に判定は要らない。

solved,var(V),m(M),starttime(S),endtime(E)
:-
int(V),int(M),unary(S),unary(E) |
[[/*inline*/
	System.out.println("solved.");
	long time = Long.parseLong(me.nth(3)) - Long.parseLong(me.nth(2));
	System.out.println("solving time : " + time);
	try{
		String tmpfile = "";
		FileWriter fw = new FileWriter("c:/kudo/satresult.txt",true);
		//String s_str = "s cnf 1 " + me.nth(0) + " " + me.nth(1) + "\n";
		String s_str = "1\t" + time + "\n";
		fw.write(s_str,0,s_str.length());
		fw.close();
	}catch(IOException e){System.out.println("error : write file.");}
	mem.removeAtom(me.nthAtom(0));
	mem.removeAtom(me.nthAtom(1));
	mem.removeAtom(me);
]](V,M,S,E).

unsolved,var(V),m(M),starttime(S)
:-
int(V),int(M),unary(S)|
[[/*inline*/
	System.out.println("unsolved.");
	long time = new GregorianCalendar().getTimeInMillis() - Long.parseLong(me.nth(2));
	System.out.println("solving time : " + time);
	try{
		FileWriter fw = new FileWriter("c:/kudo/satresult.txt",true);
		//String s_str = "s cnf 2 " + me.nth(0) + " " + me.nth(1) + "\n";
		String s_str = "2\t" + time + "\n";
		fw.write(s_str,0,s_str.length());
		fw.close();
	}catch(IOException e){System.out.println("oh! IOException.");}
	mem.removeAtom(me.nthAtom(0));
	mem.removeAtom(me.nthAtom(1));
	mem.removeAtom(me);
]](V,M,S).