% type reconstruction for the typed lambda calculus
% 2009-05-27 by Kazunori Ueda
%
% type variable representation
%   uninstantiated: {u, +Ref1, +Ref2, ...}

proof{
% (var)      ----------------
%            忙, x:而 |- x:而
%
var@@sequent({$g,type($x,T1)},type($y,T2)) :- $x==$y |
    unify(T1,T2), remove({$g}).

% (con)      ---------------
%             忙 |- c^而:而
%
con@@sequent(G,type($x,T)) :- int($x) |
    unify(T,int), remove(G).

% (nil)      ------------------------
%               忙 |- nil : list(而)
%
nil@@sequent(G,type([],T)) :-
    unify(T,list({u})), remove(G).

%            忙 |- M_1:而   忙 |- M_2: list(而)
% (list)     --------------------------------
%                忙 |- M_1::M_2 : list(而)
%
list@@sequent(G,type([X|Xs],T)) :-
    copy_env(G,G1,G2),
    sequent(G1,type(X,{u,+T1})),
    sequent(G2,type(Xs,{u,+T2,+T3})),
    unify(list(T1),T2), unify(T3,T).

%         忙 |- L:bool  忙 |- M:而  忙 |- N:而
% (if)    ------------------------------------
%            忙 |- (if L then M else N): 而
/* no if yet */

%                  忙, x:而' |- M:而
% (abs)      -----------------------------
%               忙 |- (竹x.M): 而' ◥ 而
%
abs@@sequent(G,type(abs($x,M),T)) :- unary($x) |
    add_env($x,G,{},E,T1),
    sequent(E,type(M,T2)), {u,+T1,+T3}, {u,+T2,+T4},
    unify(T,arrow(T3,T4)).    

%            忙 |- M: 而'◥而  忙 |- N: 而'
% (app)      -----------------------------
%                   忙 |- (M N): 而
%
app@@sequent(G,type(app(M,N),T)) :-
    copy_env(G,G1,G2),
    sequent(G1,type(M,arrow(T1,T))),
    sequent(G2,type(N,T2)), {u,+T1,+T2}.

%            忙 |- N:而'  忙, x:而' |- M:而
% (let)      ------------------------------
%               忙 |- (let x=N in M):而
% 
/* no let yet */

a_e1@@add_env($x,{},{$g},E,T1) :- unary($x) | E={$g,type($x,T1)}.
a_e2@@add_env($x,{type($y,T0),$g0},{$g},E,T1) :- $x=$y |
    E={$g,type($x,T1),$g0}, remove({type($y,T0)}).
a_e3@@add_env($x,{type($y,T0),$g0},{$g},E,T1) :- $x\=$y |
    add_env($x,{$g0},{type($y,T0),$g},E,T1).

c_e1@@copy_env(G,G1,G2) :- copy_env(G,{},G1,{},G2).
c_e2@@copy_env({},G10,G1,G20,G2) :- G1=G10, G2=G20.
c_e3@@copy_env({type($x,L),$g},{$g1},G1,{$g2},G2), {+L,$v} :-
    unary($x) |
    copy_env({$g},{type($x,L1),$g1},G1,{type($x,L2),$g2},G2),
    {+L1,+L2,$v}.
rem1@@remove({}) :- .
rem2@@remove({type($x,L),$g}), {+L,$v} :- unary($x) |
    remove({$g}), {$v}.
    
//sequent({},type(abs(x,x),{u,+A})), A=ans, lock.
sequent({},type([7],{u,+A})), A=ans, lock.
//sequent({},type([[]],{u,+A})), A=ans, lock.
//sequent({},type([y],{u,+A})), A=ans, lock.
//sequent({}, type(abs(f,abs(x,app(f,app(f,x)))),{u,+A})), A=ans, lock.
//sequent({}, type(abs(f,abs(x,app(f,x))),{u,+A})), A=ans, lock.
//sequent({}, type(abs(x,app(x,x)),{u,+A})), A=ans, lock.
}.

proof{$p,@p}/ :- $p.

% unification over type expressions
% v: typevar, t: type

% v=v; simply remove it
u_vv@@unify(V1,V2), {+V1,+V2,$v} :- {$v}.

% v=t (t\=v); occurs check, then replace v's other occurrences with t
u_vt1@@unify({u,$v1},{u,$v2}) :- {u,$v1,$v2}.   % needs no occurs check
u_vt2@@unify({u,$v1},int), lock :- unify_vt({u,$v1},int).
u_vt3@@unify({u,$v1},list(T1)), lock :- unify_vt({u,$v1},list(T1)).
u_vt4@@unify({u,$v1},arrow(S,T1)), lock :- unify_vt({u,$v1},arrow(S,T1)).

% needs locking during the occurs check
% Res is ok({$v}) or fail({$v})
u_oc@@unify_vt({u,$v},T1) :-
    T2=occurs_check({u,$v},T1,Res,V), unify2(Res,V,T2).
    
u2_no@@unify2(no,{u,$v1},T2) :- fail({u,$v1},T2), lock.
u2_ok1@@unify2(ok,V,T), {u,+V} :- rm=T, lock.
u2_ok2@@unify2(ok,V,T), {u,+V,+V1} :- V1=T, lock.
u2_ok3@@unify2(ok,V,T), {u,+V,+V1,$v} :-
    cp(T1,T2)=T, V1=T1, unify2(ok,{u,$v},T2).

rm1@@rm=int :- .
rm2@@rm=list(V) :- rm=V.
rm3@@rm=arrow(V1,V2) :- rm=V1, rm=V2.
rm4@@rm={u,$v} :- {u,$v}.

cp1@@cp(T1,T2)=int :- T1=int, T2=int.
cp2@@cp(T1,T2)=list(V) :-
    T1=list(V1), T2=list(V2), cp(V1,V2)=V.
cp3@@cp(T1,T2)=arrow(U,V) :-
    T1=arrow(U1,V1), T2=arrow(U2,V2), cp(U1,U2)=U, cp(V1,V2)=V.
cp4@@cp(V1,V2)={u,$v} :- {u,+V1,+V2,$v}.

u_tv1@@unify(int,{$v}) :- unify({$v},int).
u_tv2@@unify(list(S),{$v}) :- unify({$v},list(S)).
u_tv3@@unify(arrow(T1,T2),{$v}) :- unify({$v},arrow(T1,T2)).

u_cc@@unify(int,int) :- .
u_ll@@unify(list(T1),list(T2)) :- unify(T1,T2).
u_aa@@unify(arrow(S1,T1),arrow(S2,T2)) :-
    unify(S1,S2), unify(T1,T2).

oc_vv@@T2=occurs_check(V0,V1,Res,V), {u,+V0,+V1,$v} :-
    Res=no, V={u,+T2,$v}.
oc_vw@@T2=occurs_check({u,$v1},{u,$v2},Res,V) :-
    T2={u,$v2}, Res=ok, V={u,$v1}.
oc_vc@@T2=occurs_check({u,$v1},int,Res,V) :- T2=int, Res=ok, V={u,$v1}.
oc_vl@@T2=occurs_check({u,$v1},list(V0),Res,V) :-
    T2=list(occurs_check({u,$v1},V0,Res,V)).
oc_va@@T2=occurs_check({u,$v1},arrow(V0,V1),Res,V) :-
    T2=arrow(occurs_check({u,$v1},V0,Res0,V2), 
             occurs_check(Res0,V2,V1,Res,V)).
oc_ok@@T2=occurs_check(ok,V2,V1,Res,V) :- T2=occurs_check(V2,V1,Res,V).
oc_no@@T2=occurs_check(no,V2,V1,Res,V) :- T2=V1, Res=no, V=V2.


//unify({u},arrow({u,+V},V)), lock.
//unify(arrow(A0,B0),arrow(B,A)), {u,+A0,+A}, {u,+B0,+B}, lock.
//unify({u},{u}), lock.
/*
lock, ans(L3),
list(L87,unify(L43)),
list(L97,unify(L48)),
unify(list(L51),L55), unify(L57,L4),
{u, +L3, +L4}, {u, +L51, +L43},
{u, +L55, +L57, +L48}, {u, +L87}, {u, +L97}
*/
