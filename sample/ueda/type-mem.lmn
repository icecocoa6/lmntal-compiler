% type reconstruction for the typed lambda calculus
% 2009-05-08 by Kazunori Ueda

% (var)      ----------------
%            忙, x:而 |- x:而
%
var@@sequent({$g,type($x,T1)},type($y,T2)) :- $x==$y |
    unify(T1,T2), remove({$g}).

% (con)      ---------------
%             忙 |- c^而:而
%
con@@sequent({$g},type($x,T)) :- int($x) |
    unify(T,int), remove({$g}).

% (nil)      ------------------------
%               忙 |- nil : list(而)
%
nil@@sequent({$g},type([],T)) :-
   unify(T,list({u})), remove({$g}).

%            忙 |- M_1:而   忙 |- M_2: list(而)
% (list)     --------------------------------
%                忙 |- M_1::M_2 : list(而)
%
list@@sequent({$g},type([X|Xs],T)) :-
    copy_env({$g},E1,E2),
    sequent(E1,type(X,{u,+T1})),
    sequent(E2,type(Xs,{u,+T2,+T3})),
    unify(list(T1),T2), unify(T3,T).

%         忙 |- L:bool  忙 |- M:而  忙 |- N:而
% (if)    ------------------------------------
%            忙 |- (if L then M else N): 而
/* no if yet */

%                  忙, x:而' |- M:而
% (abs)      -----------------------------
%               忙 |- (竹x.M): 而' ◥ 而
%
abs@@sequent({$g},type(abs($x,M),T)) :- unary($x) |
    add_env($x,{$g},{},E,T1),
    sequent(E,type(M,T2)), {u,+T1,+T3}, {u,+T2,+T4},
    unify(T,arrow(T3,T4)).
    
add_env($x,{},{$g},E,T1) :- unary($x) | E={$g,type($x,T1)}.
add_env($x,{type($y,T0),$g0},{$g},E,T1) :- $x=$y |
    E={$g,type($y,T),$g0}, T=unify(T0,T1).
add_env($x,{type($y,T0),$g0},{$g},E,T1) :- $x\=$y |
    add_env($x,{$g0},{type($y,T0),$g},E,T1).    

%            忙 |- M: 而'◥而  忙 |- N: 而'
% (app)      -----------------------------
%                   忙 |- (M N): 而
%
app@@sequent({$g},type(app(M,N),T)) :-
    copy_env({$g},E1,E2),
    sequent(E1,type(M,arrow(T1,T))),
    sequent(E2,type(N,T2)), {u,+T1,+T2}.

%            忙 |- N:而'  忙, x:而' |- M:而
% (let)      ------------------------------
%               忙 |- (let x=N in M):而
% 
/* no let yet */

c_e@@copy_env(E,E1,E2) :- copy_env(E,{},E1,{},E2).
c_e@@copy_env({},E10,E1,E20,E2) :- E1=E10, E2=E20.
c_e@@copy_env({type($x,L),$e},{$e1},E1,{$e2},E2), {+L,$v} :-
    unary($x) |
    copy_env({$e},{type($x,L1),$e1},E1,{type($x,L2),$e2},E2),
    {+L1,+L2,$v}.
rm@@remove({}) :- .
rm@@remove({type($x,L),$e}), {+L,$v} :- unary($x) |
    remove({$e}), {$v}.
    
% unification over type expressions
% v: typevar, t: type

u@@unify(T1,T2) :- del=unify(T1,T2).
% v=v; simply remove it
u_vv@@T=unify(V1,V2), {+V1,+V2,$v} :- T={$v}.

% v=t (t\=v); occurs check, then replace v's other occurrences with t
u_vt@@T=unify({u,$v1},{u,$v2}) :- T={u,$v1,$v2}.   % needs no occurs check
u_vt@@T=unify({u,$v1},{i,$v2}) :- T=unify_vt({u,$v1},{i,$v2}).
u_vt@@T=unify({u,$v1},int) :- T=unify_vt({u,$v1},int).
u_vt@@T=unify({u,$v1},list(T1)) :- T=unify_vt({u,$v1},list(T1)).
u_vt@@T=unify({u,$v1},arrow(S,T1)) :- T=unify_vt({u,$v1},arrow(S,T1)).

u_ic@@T=unify({i,$v1,-T1},int) :- T={i,$v1,-T2}, T2=unify(T1,int).
u_ic@@T=unify({i,$v1,-T1},list(S)) :- T={i,$v1,-T2}, T2=unify(T1,list(S)).
u_ic@@T=unify({i,$v1,-T1},arrow(S1,S2)) :-
    T={i,$v1,-T2}, T2=unify(T1,arrow(S1,S2)).

% needs locking during the occurs check
% Res is ok({$v}) or fail({$v})
u_oc@@T=unify_vt({u,$v},T1), lock :-
    T2=occurs_check({u,$v},T1,Res,V), T=unify2(Res,V,T2).
    
u2_no@@T=unify2(no,{u,$v1},T2) :- T=fail({u,$v1},T2), lock.
% T2 may be an instantiated variable.
u2_ok@@T=unify2(ok,{u,$v1},T2), {i,$v2,+T2} :- T={i,$v1,$v2}, lock.
u2_ok@@T=unify2(ok,{u,$v1},T2), {u,$v2,+T2} :- T={u,$v1,$v2}, lock.
u2_ok@@T=unify2(ok,{u,$v1},int) :- T={i,$v1,-T1}, T1=int, lock.
u2_ok@@T=unify2(ok,{u,$v1},list(S)) :- T={i,$v1,-T1}, T1=list(S), lock.
u2_ok@@T=unify2(ok,{u,$v1},arrow(S1,S2)) :-
    T={i,$v1,-T1}, T1=arrow(S1,S2), lock.

u_tv@@T=unify({i,$v1},{u,$v2}) :- T=unify({u,$v2},{i,$v1}).
% the following three rules handle both u and i cases
u_tv@@T=unify(int,{$v}) :- T=unify({$v},int).
u_tv@@T=unify(list(S),{$v}) :- T=unify({$v},list(S)).
u_tv@@T=unify(arrow(T1,T2),{$v}) :- T=unify({$v},arrow(T1,T2)).

u_cc@@T=unify(int,int) :- T=int.
u_ll@@T=unify(list(T1),list(T2)) :- T=list(unify(T1,T2)).
u_aa@@T=unify(arrow(S1,T1),arrow(S2,T2)) :-
    T=arrow(unify(S1,S2), unify(T1,T2)).
    
deref@@{i,-U,+V} :- U=V.

oc_vv@@T2=occurs_check(V0,V1,Res,V), {u,+V0,+V1,$v} :-
    Res=no, V={u,+T2,$v}.
oc_vwu@@T2=occurs_check({u,$v1},{u,$v2},Res,V) :-
    T2={u,$v2}, Res=ok, V={u,$v1}.
oc_vwi@@T2=occurs_check({u,$v1},{i,$v2,-T},Res,V) :-
    T2={i,$v2,-T3}, T3=occurs_check({u,$v1},T,Res,V).
oc_vc@@T2=occurs_check({u,$v1},int,Res,V) :- T2=int, Res=ok, V={u,$v1}.
oc_vl@@T2=occurs_check({u,$v1},list(V0),Res,V) :-
    T2=list(occurs_check({u,$v1},V0,Res,V)).
oc_va@@T2=occurs_check({u,$v1},arrow(V0,V1),Res,V) :-
    T2=arrow(occurs_check({u,$v1},V0,Res0,V2), 
             occurs_check(Res0,V2,V1,Res,V)).
oc_ok@@T2=occurs_check(ok,V2,V1,Res,V) :- T2=occurs_check(V2,V1,Res,V).
oc_no@@T2=occurs_check(no,V2,V1,Res,V) :- T2=V1, Res=no, V=V2.

d@@del={$v} :- {$v}.
d@@del=int :- .
d@@del=list(T) :- del=T.
d@@del=arrow(S,T) :- del=S, del=T.

// sequent({},type(abs(x,x),{u,ans})), lock.
// sequent({},type([7],{u,ans})), lock.
// sequent({},type([x,y,3],{u,ans})), lock.
// sequent({}, type(abs(f,abs(x,app(f,app(f,x)))),{u,ans})), lock.
// sequent({}, type(abs(x,app(x,x)),{u,ans})), lock.
// unify({u,ans},arrow({u,+V},V)), lock.
// unify(arrow(A0,B0),arrow(B,A)), {u,+A0,+A}, {u,+B0,+B}, lock.
// unify({u},{u}), lock.