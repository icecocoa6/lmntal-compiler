% type reconstruction for the typed lambda calculus
% 2009-05-27 by Kazunori Ueda
%
% type variable representation
%   uninstantiated: v{+Ref1, +Ref2, ...}

proof{
% (var)      ----------------
%            忙, x:而 |- x:而
%
var@@sequent(tenv{$g,type($x,T1)},type($y,T2)) :- $x==$y |
    unify(T1,T2), remove(tenv{$g}).

% (con)      ---------------
%             忙 |- c^而:而
%
con@@sequent(G,type($x,T)) :- int($x) |
    unify(T,int), remove(G).

% (nil)      ------------------------
%               忙 |- nil : list(而)
%
nil@@sequent(G,type([],T)) :-
    unify(T,list(v{})), remove(G).

%            忙 |- M_1:而   忙 |- M_2: list(而)
% (list)     --------------------------------
%                忙 |- M_1::M_2 : list(而)
%
list@@sequent(G,type([X|Xs],T)) :-
    copy_env(G,G1,G2),
    sequent(G1,type(X,v{+T1})),
    sequent(G2,type(Xs,v{+T2,+T3})),
    unify(list(T1),T2), unify(T3,T).

%         忙 |- L:bool  忙 |- M:而  忙 |- N:而
% (if)    ------------------------------------
%            忙 |- (if L then M else N): 而
/* no if yet */

%                  忙, x:而' |- M:而
% (abs)      -----------------------------
%               忙 |- (竹x.M): 而' ◥ 而
%
abs@@sequent(G,type(abs($x,M),T)) :- unary($x) |
    add_env($x,G,tenv{},E,T1),
    sequent(E,type(M,T2)), v{+T1,+T3}, v{+T2,+T4},
    unify(T,arrow(T3,T4)).    

%            忙 |- M: 而'◥而  忙 |- N: 而'
% (app)      -----------------------------
%                   忙 |- (M N): 而
%
app@@sequent(G,type(app(M,N),T)) :-
    copy_env(G,G1,G2),
    sequent(G1,type(M,arrow(T1,T))),
    sequent(G2,type(N,T2)), v{+T1,+T2}.

%            忙 |- N:而'  忙, x:而' |- M:而
% (let)      ------------------------------
%               忙 |- (let x=N in M):而
% 
/* no let yet */

a_e1@@add_env($x,tenv{},tenv{$g},E,T1) :- unary($x) |
    E=tenv{$g,type($x,T1)}.
a_e2@@add_env($x,tenv{type($y,T0),$g0},tenv{$g},E,T1) :- $x=$y |
    E=tenv{$g,type($x,T1),$g0}, remove(tenv{type($y,T0)}).
a_e3@@add_env($x,tenv{type($y,T0),$g0},tenv{$g},E,T1) :- $x\=$y |
    add_env($x,tenv{$g0},tenv{type($y,T0),$g},E,T1).

c_e1@@copy_env(G,G1,G2) :- copy_env(G,tenv{},G1,tenv{},G2).
c_e2@@copy_env(tenv{},G10,G1,G20,G2) :- G1=G10, G2=G20.
c_e3@@copy_env(tenv{type($x,L),$g},tenv{$g1},G1,tenv{$g2},G2), v{+L,$v} :-
    unary($x) |
    copy_env(tenv{$g},tenv{type($x,L1),$g1},G1,tenv{type($x,L2),$g2},G2),
    v{+L1,+L2,$v}.
rem1@@remove(tenv{}) :- .
rem2@@remove(tenv{type($x,L),$g}), v{+L,$v} :- unary($x) |
    remove(tenv{$g}), v{$v}.
    
//sequent(tenv{},type(abs(x,x),v{+A})), A=ans, lock.
//sequent(tenv{},type([7],v{+A})), A=ans, lock.
//sequent(tenv{},type([[]],v{+A})), A=ans, lock.
//sequent(tenv{},type([y],v{+A})), A=ans, lock.
//sequent(tenv{}, type(abs(f,abs(x,app(f,app(f,x)))),v{+A})), A=ans, lock.
sequent(tenv{}, type(abs(f,abs(x,app(f,x))),v{+A})), A=ans, lock.
//sequent(tenv{}, type(abs(x,app(x,x)),v{+A})), A=ans, lock.
}.

proof{$p,@p}/ :- $p.

% unification over type expressions
% v: typevar, t: type

% v=v; simply remove it
u_vv@@unify(V1,V2), v{+V1,+V2,$v} :- v{$v}.

% v=t (t\=v); occurs check, then replace v's other occurrences with t
u_vt1@@unify(v{$v1},v{$v2}) :- v{$v1,$v2}.   % needs no occurs check
u_vt2@@unify(v{$v1},int), lock :- unify_vt(v{$v1},int).
u_vt3@@unify(v{$v1},list(T1)), lock :- unify_vt(v{$v1},list(T1)).
u_vt4@@unify(v{$v1},arrow(S,T1)), lock :- unify_vt(v{$v1},arrow(S,T1)).

% needs locking during the occurs check
% Res is ok({$v}) or fail({$v})
u_oc@@unify_vt(v{$v},T1) :-
    T2=occurs_check(v{$v},T1,Res,V), unify2(Res,V,T2).
    
u2_no@@unify2(no,v{$v1},T2) :- fail(v{$v1},T2), lock.
u2_ok1@@unify2(ok,V,T), v{+V} :- rm=T, lock.
u2_ok2@@unify2(ok,V,T), v{+V,+V1} :- V1=T, lock.
u2_ok3@@unify2(ok,V,T), v{+V,+V1,+V2,$v} :-
    cp(T1,T2)=T, V1=T1, unify2(ok,v{+V2,$v},T2).

rm1@@rm=int :- .
rm2@@rm=list(V) :- rm=V.
rm3@@rm=arrow(V1,V2) :- rm=V1, rm=V2.
rm4@@rm=v{$v} :- v{$v}.

cp1@@cp(T1,T2)=int :- T1=int, T2=int.
cp2@@cp(T1,T2)=list(V) :-
    T1=list(V1), T2=list(V2), cp(V1,V2)=V.
cp3@@cp(T1,T2)=arrow(U,V) :-
    T1=arrow(U1,V1), T2=arrow(U2,V2), cp(U1,U2)=U, cp(V1,V2)=V.
cp4@@cp(V1,V2)=v{$v} :- v{+V1,+V2,$v}.

u_tv1@@unify(int,v{$v}) :- unify(v{$v},int).
u_tv2@@unify(list(S),v{$v}) :- unify(v{$v},list(S)).
u_tv3@@unify(arrow(T1,T2),v{$v}) :- unify(v{$v},arrow(T1,T2)).

u_cc@@unify(int,int) :- .
u_ll@@unify(list(T1),list(T2)) :- unify(T1,T2).
u_aa@@unify(arrow(S1,T1),arrow(S2,T2)) :-
    unify(S1,S2), unify(T1,T2).

oc_vv@@T2=occurs_check(V0,V1,Res,V), v{+V0,+V1,$v} :-
    Res=no, V=v{+T2,$v}.
oc_vw@@T2=occurs_check(v{$v1},v{$v2},Res,V) :-
    T2=v{$v2}, Res=ok, V=v{$v1}.
oc_vc@@T2=occurs_check(v{$v1},int,Res,V) :- T2=int, Res=ok, V=v{$v1}.
oc_vl@@T2=occurs_check(v{$v1},list(V0),Res,V) :-
    T2=list(occurs_check(v{$v1},V0,Res,V)).
oc_va@@T2=occurs_check(v{$v1},arrow(V0,V1),Res,V) :-
    T2=arrow(occurs_check(v{$v1},V0,Res0,V2), 
             occurs_check(Res0,V2,V1,Res,V)).
oc_ok@@T2=occurs_check(ok,V2,V1,Res,V) :- T2=occurs_check(V2,V1,Res,V).
oc_no@@T2=occurs_check(no,V2,V1,Res,V) :- T2=V1, Res=no, V=V2.


//unify({u},arrow({u,+V},V)), lock.
//unify(arrow(A0,B0),arrow(B,A)), {u,+A0,+A}, {u,+B0,+B}, lock.
//unify({u},{u}), lock.
/*
lock, ans(L3),
list(L87,unify(L43)),
list(L97,unify(L48)),
unify(list(L51),L55), unify(L57,L4),
{u, +L3, +L4}, {u, +L51, +L43},
{u, +L55, +L57, +L48}, {u, +L87}, {u, +L97}
*/