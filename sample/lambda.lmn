[[


LAMBDA_EXPR ::= TERM | (lambda TERM LAMBDA_EXPR) | (LAMBDA_EXPR LAMBDA_EXPR)

X \in type LAMBDA_EXPR <==>
    { c(X). term(TERM T). }
|   { c(X). lambda(TERM T, LAMBDA_EXPR L). }
|   { c(X). apply(LAMBDA_EXPR L1, LAMBDA_EXPR L2). }

X \in type LAMBDA_EXPR <==>
    term(TERM T, X)
|   lambda(TERM T, LAMBDA_EXPR L, X)
|   apply(LAMBDA_EXPR L1, LAMBDA_EXPR L2, X)

h = (lambda x (lambda y (y x)))
=> h = lambda( x, lambda(y, apply(y, x) ) )


[コンビネータを使った式]への変換ルール

(lambda x x) => (lambda x x)
(lambda x P) => (lambda x (lambda y x)) P
(lambda x (P Q)) => (lambda x (lambda y (lambda z (x z (y z))))) (lambda x P) (lambda x Q)

↑が反応し終わったらこれをやる
(lambda x x) => COM_I
(lambda x (lambda y x)) => COM_K
(lambda x (lambda y (lambda z (x z (y z))))) => COM_S

]].
//-----------------------------------------------------------------------------------------------

handle = lambda(term(x), lambda(term(y), apply(term(y), term(x)), s1 ), s0 ).
//handle = lambda(term(x), term(x) ).
//handle = lambda(term(x), lambda(term(y), term(x)) ).
//handle = lambda(term(x), lambda(term(y), lambda(term(z), apply(apply(term(x), term(z)), apply(term(y), term(z)))))).

//(lambda x x) => (lambda x x)
//(lambda x P) => (lambda x (lambda y x)) P      x not free in P
( H = lambda(term(T), P, s0) :- unary(T) | H=lambda(term(T), local(T, P), s1) ).
( H = local_res(lambda(term(T), P, S), 1) :- unary(T), unary(S) | H=apply(lambda(term(x), lambda(term(y), x, s1), s1), P) ).

//(lambda x (P Q)) => (lambda x (lambda y (lambda z (x z (y z))))) (lambda x P) (lambda x Q)
( H = lambda(term(T), apply(P, Q), S) :- unary(T), unary(S) | H=apply(apply(lambda(term(x), lambda(term(y), lambda(term(z), apply(apply(x, z), apply(y, z)), s1), s1), s1), lambda(term(T), P, S)), lambda(term(T), Q, S)) ).


// (lambda x x) => COM_I
//(H = lambda(term(T), P) :- unary(T), unary(P), T=P | H=com_I).

// (lambda x (lambda y x)) => COM_K
//(H = lambda(term(T1), lambda(term(T2), T3)) :- unary(T1), unary(T2), unary(T3), T1=T3 | H=com_K).

// (lambda x (lambda y (lambda z (x z (y z))))) => COM_S
//(H = lambda(term(T1), lambda(term(T2), lambda(term(T3), apply(apply(T4, T5), apply(T6, T7))))) :-
// unary(T1), unary(T2), unary(T3), unary(T4), unary(T5), unary(T6), unary(T7), T1=T4, T2=T6, T3=T5, T3=T7 | H=com_S).



//----------------------------------------------------------------------
// local(X, P) : X が P 内で束縛されているかどうか
//----------------------------------------------------------------------
( H=local(X, term(T)) :- unary(X), unary(T), X=T | H=local_res(term(T), 1) ).
( H=local(X, term(T)) :- unary(X), unary(T), X\=T | H=local_res(term(T), 0) ).

( H=local(X, apply(P, Q)) :- unary(X) | H=apply(local(X, P), local(X, Q)) ).
( H=apply(local_res(P, R1), local_res(Q, R2)) :- R1*R2=:=1 | H=local_res(apply(P, Q), 1) ).
( H=apply(local_res(P, R1), local_res(Q, R2)) :- R1*R2=:=0 | H=local_res(apply(P, Q), 0) ).

( H=local(X, lambda(term(T), P, S)) :- unary(X), unary(T), T=X | H=local_res(lambda(term(T), P, S), 1) ).
( H=local(X, lambda(term(T), P, S)) :- unary(X), unary(T), T\=X | H=lambda(term(T), local(X, P), S), 1).
( H=lambda(T, local_res(P, R), S) :- int(R) | H=local_res(lambda(T, P, S), R) ).


//S=lambda(x, lambda(y, apply(term(y), term(x)) ) ).
//S=apply(term(x), lambda(y, term(y))).
//h=local(x, S).


