[[


LAMBDA_EXPR ::= TERM | (lambda TERM LAMBDA_EXPR) | (LAMBDA_EXPR LAMBDA_EXPR)

X \in type LAMBDA_EXPR <==>
    { c(X). term(TERM T). }
|   { c(X). lambda(TERM T, LAMBDA_EXPR L). }
|   { c(X). apply(LAMBDA_EXPR L1, LAMBDA_EXPR L2). }

X \in type LAMBDA_EXPR <==>
    term(TERM T, X)
|   lambda(TERM T, LAMBDA_EXPR L, X)
|   apply(LAMBDA_EXPR L1, LAMBDA_EXPR L2, X)

h = (lambda x (lambda y (y x)))
=> h = lambda( x, lambda(y, apply(y, x) ) )


----------------------------------------------------------------------
ラムダ式→コンビネータのみからなる式     YET
----------------------------------------------------------------------

[コンビネータを使った式]への変換ルール

(lambda x x) => (lambda x x)
(lambda x P) => (lambda x (lambda y x)) P
(lambda x (P Q)) => (lambda x (lambda y (lambda z (x z (y z))))) (lambda x P) (lambda x Q)

↑が反応し終わったらこれをやる
(lambda x x) => COM_I
(lambda x (lambda y x)) => COM_K
(lambda x (lambda y (lambda z (x z (y z))))) => COM_S

【例】
	lambda f (f 5) (lambda n (mult n n))
	C (lambda f f) 5 (lambda n (mult n n))
	C I 5 (lambda n (mult n n))
	C I 5 (S (lambda n (mult n)) (lambda n n))
	C I 5 (S (lambda n (mult n)) I)
//	C I 5 (S B mult (lambda n n) I)
//	C I 5 (S B mult I I)
	どうやらこうなるらしい
	C I 5 (S mult I)


----------------------------------------------------------------------
コンビネータのみからなる式→評価結果     DONE
----------------------------------------------------------------------
I P     -> P
K P Q   -> P
S P Q R -> P R (Q R)
B P Q R -> P Q R
C P Q R -> P R Q

【例】
	C I 5 (S mult I)
	I (S mult I) 5
	S mult I 5
	mult 5 I 5
	mult 5 5

]].
//-----------------------------------------------------------------------------------------------


//handle = lambda(term(x), lambda(term(y), apply(term(y), term(x)), s1 ), s0 ).
//handle = lambda(term(x), term(x) ).
//handle = lambda(term(x), lambda(term(y), term(x)) ).
//handle = lambda(term(x), lambda(term(y), lambda(term(z), apply(apply(term(x), term(z)), apply(term(y), term(z)))))).

//(lambda x x) => (lambda x x)
//(lambda x P) => (lambda x (lambda y x)) P      x not free in P
//( H = lambda(term(T), P, s0) :- unary(T) | H=lambda(term(T), local(T, P), s1) ).
//( H = local_res(lambda(term(T), P, S), 1) :- unary(T), unary(S) | H=apply(lambda(term(x), lambda(term(y), x, s1), s1), P) ).

//(lambda x (P Q)) => (lambda x (lambda y (lambda z (x z (y z))))) (lambda x P) (lambda x Q)
//( H = lambda(term(T), apply(P, Q), S) :- unary(T), unary(S) | H=apply(apply(lambda(term(x), lambda(term(y), lambda(term(z), apply(apply(x, z), apply(y, z)), s1), s1), s1), lambda(term(T), P, S)), lambda(term(T), Q, S)) ).


// (lambda x x) => COM_I
//(H = lambda(term(T), P) :- unary(T), unary(P), T=P | H=com_I).

// (lambda x (lambda y x)) => COM_K
//(H = lambda(term(T1), lambda(term(T2), T3)) :- unary(T1), unary(T2), unary(T3), T1=T3 | H=com_K).

// (lambda x (lambda y (lambda z (x z (y z))))) => COM_S
//(H = lambda(term(T1), lambda(term(T2), lambda(term(T3), apply(apply(T4, T5), apply(T6, T7))))) :-
// unary(T1), unary(T2), unary(T3), unary(T4), unary(T5), unary(T6), unary(T7), T1=T4, T2=T6, T3=T5, T3=T7 | H=com_S).



//----------------------------------------------------------------------
// local(X, P) : X が P 内で束縛されているかどうか
//----------------------------------------------------------------------
//( H=local(X, term(T)) :- unary(X), unary(T), X=T | H=local_res(term(T), 1) ).
//( H=local(X, term(T)) :- unary(X), unary(T), X\=T | H=local_res(term(T), 0) ).
//
//( H=local(X, apply(P, Q)) :- unary(X) | H=apply(local(X, P), local(X, Q)) ).
//( H=apply(local_res(P, R1), local_res(Q, R2)) :- R1*R2=:=1 | H=local_res(apply(P, Q), 1) ).
//( H=apply(local_res(P, R1), local_res(Q, R2)) :- R1*R2=:=0 | H=local_res(apply(P, Q), 0) ).
//
//( H=local(X, lambda(term(T), P, S)) :- unary(X), unary(T), T=X | H=local_res(lambda(term(T), P, S), 1) ).
//( H=local(X, lambda(term(T), P, S)) :- unary(X), unary(T), T\=X | H=lambda(term(T), local(X, P), S), 1).
//( H=lambda(T, local_res(P, R), S) :- int(R) | H=local_res(lambda(T, P, S), R) ).


//S=lambda(x, lambda(y, apply(term(y), term(x)) ) ).
//S=apply(term(x), lambda(y, term(y))).
//h=local(x, S).


//----------------------------------------------------------------------
// week reduction of combinator -> 完成。
//----------------------------------------------------------------------
( // I P -> P
	{ c(H), l(L), r(EX_P) }, 
	{ c(L), v(com_I) }
	:-
	H=EX_P
).
( // K P Q -> P
	{ c(H), l(L), r(EX_Q) }, 
		{ c(L), l(LL), r(EX_P) }, 
			{ c(LL), v(com_I) }, 
	:-
	H=EX_P, EX_Q=n
).

( // S P Q R -> P R (Q R)
	{ c(H), l(L), r(EX_R) },
		{ c(L), l(LL), r(EX_Q) },
			{ c(LL), l(LLL), r(EX_P) },
				{ c(LLL), v(com_S) },
		{ c(EX_R), $p }
	:-
	{ c(H), l(L), r(R) }, 
		{ c(L), l(EX_P), r(EX_R) }, 
	{ c(R), l(EX_Q), r(EX_R2) }, 
		{ c(EX_R), c(EX_R2), $p }
).

( // B P Q R -> P Q R
	{ c(H), l(L), r(EX_R) },
		{ c(L), l(LL), r(EX_Q) },
			{ c(LL), l(LLL), r(EX_P) },
				{ c(LLL), v(com_B) }
	:-
	{ c(H), l(EX_P), r(R) },
	{ c(R), l(EX_Q), r(EX_R) }
).
( // C P Q R -> P R Q
	{ c(H), l(L), r(EX_R) },
		{ c(L), l(LL), r(EX_Q) },
			{ c(LL), l(LLL), r(EX_P) },
				{ c(LLL), v(com_C) }
	:-
	{ c(H), l(L), r(EX_Q) },
	{ c(L), l(EX_P), r(EX_R) }
).


//----------------------------------------------------------------------
// てすと
//----------------------------------------------------------------------
//// com_S 2 3 4444444
//h(H).
//{c(H), l(L), r(R)}.
//{ c(L), l(LL), r(LR) }.
//	{ c(LL), l(LLL), r(LLR) }.
//		{ c(LLL), v(com_S) }.
//		{ c(LLR), v(2) }.
//	{ c(LR), v(3) }.
//{ c(R), v(4444444) }.


//// C I 5 (S mult I)
h(H).
{c(H),l(L),r(R)}.
	{c(L),l(LL),r(LR)}.
		{c(LL),l(LLL),r(LLR)}.
			{c(LLL),v(com_C)}.
			{c(LLR),v(com_I)}.
		{c(LR),v(5)}.
	{c(R),l(RL),r(RR)}.
		{c(RL),l(RLL),r(RLR)}.
			{c(RLL),v(com_S)}.
			{c(RLR),v(mult)}.
		{c(RR),v(com_I)}.

