/*
----------------------------------------------------------------------
Lambda calculus simulator
                                              Koji Hara
                                              2004/12/21(Tue) 21:26:18
----------------------------------------------------------------------


----------------------------------------------------------------------
概要
----------------------------------------------------------------------
ラムダ計算の定義そのまま。

束縛変数は参照で表すので書き換え時にコピーは不要。
ただし、組み込み関数などによって式が unary になったらコピーしている。

----------------------------------------------------------------------
内部表現
----------------------------------------------------------------------

LAMBDA_EXPR ::= 
        Var
      | [LAMBDA_EXPR, LAMBDA_EXPR]
      | lambda(Term, LAMBDA_EXPR)

Var ::= 
        自由変数       : アトム
      | 束縛変数の定義 : { c(R0), c(R1), ..., c(Rn) }
      | 束縛変数の出現 : c(R0), c(R1), ..., c(Rn)

----------------------------------------------------------------------
TODO
----------------------------------------------------------------------
apply の順番がランダム。これはいいんだろうか。

*/

// ----------------------------------------------------------------------
// Lambda 計算のルール
// ----------------------------------------------------------------------
// apply
H=[lambda(arg({$p}), M) | Expr] :- {$p, value=V}, val(Expr, V), H=M.

// apply(M, empty) == M  ... 適用は apply(Expr, Expr) で表すべきだが、[Expr, Expr] で表してるため単位元が [Expr] になってしまう。これを変換。
val([Expr], V) :- val(Expr, V).

// unay になったときだけ参照を解決（値のコピー）
H=ref(R), {c(R), value=V, $p}, val(Expr, V) :- unary(Expr) | H=Expr, {value=V, $p}, val(Expr, V).

// ----------------------------------------------------------------------
// 「組み込み関数」
// ----------------------------------------------------------------------
integer.use.
// mult
H=[mult, A, B] :- H='*'(A, B).


// ----------------------------------------------------------------------
// サンプルコード
// ----------------------------------------------------------------------

// (lambda x . mult x x) 5   =>  25
//r=[lambda(arg({c(A),c(B)}), [mult, ref(A), ref(B)]), 5].

// (lambda x . mult x x) (lambda x . mult x x) 5   =>  625
r=[lambda(arg({c(A),c(B)}), [mult, ref(A), ref(B)]), lambda(arg({c(C),c(D)}), [mult, ref(C), ref(D)]), 5].


