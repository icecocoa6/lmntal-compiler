% rms2.lmn
% mutexありver
% リファクタリング前

{

mutex(free).
input{

task{r(2), c(1), d(6),  t(6),  p(2), mutex(0)}.
task{r(0), c(3), d(8),  t(8),  p(1) }.
task{r(0), c(5), d(12), t(12), p(0), mutex(0)}.
	
init@@	task{r(R), c(C), d(D), t(T), $t}  	:-  int(R), int(C),
											                         int(D), int(T)					|
				task{r(R, R), c(C, C), d(D, D), t(T, T), $t}, n(T).

init@@	task{r(R), c(C), d(D), t(T), $t}				:-  int(R), int(C), int(D), int(T)					|
				task{r(R, R), c(C, C), d(D, D), t(T, T), $t}, n(T).

lcm0@@  n(X), n(Y)	  :- X >= Y               | lcm(X, Y).
lcm1@@	lcm(X, Y)		  :- X >= Y, P = X * Y    | gcd(X, Y), lcm(P).
gcd1@@  gcd(X, Y)		  :- Y2 = X mod Y, Y2=\=0 | gcd(Y, Y2).		
gcd2@@	gcd(X, Y)	  	:- (X mod Y) =:=0       | gcd(Y).
lcm2@@  gcd(X),lcm(Y)	:- D = Y / X            |	n(D).
}.

output@@	spawn{@r}, input{$p, @p, n(N)}/		:-  int(N)	|
					spawn{@r, $p, time(0)}, limit(N).

schej{
	run1@@ time(T),  task{c(C1, C2), d(D1, D2), $t}
   	 									:-	int(T),  int(C1), int(C2),
	    										int(D1), int(D2),
	 		    								(C1 > 0), (C12 = C1 - 1),
	 				    						(T2  = T  + 1), T2 =< D1		|
		  c1_time(T2), task{c(C12, C2), d(D1, D2), $t}.
		
	run0@@ time(T), task{c(C1, C2), d(D1, D2), $t}
	 		  							:-	int(T),  int(C1), int(C2),
	 			    							int(D1), int(D2), T+1 > D1,
	 					    					C1 =\= 0		|
		   d_time(T), dead{c(C1, C2), d(D1, D2), $t}.
}.

output@@ schej{$p, @p, time(T), task{c(0, C2), $t}}/,
		 sleep{$s, @s}
										:-	int(T), int(C2),
											\+($t=(mutex(M), $tt))				|
		 schej{$p, @p, time(T)},
		 sleep{$s, @s, task{c(C2, C2), $t}}.

output@@ schej{$p, @p, time(T), task{c(0, C2), mutex(USE), $t}}/,
		 sleep{$s, @s},
		 mutex(USE)
										:-	int(T),	 int(C2)	|
		 schej{$p, @p, time(T)},
		 sleep{$s, @s, task{c(C2, C2), mutex(0), $t}},
		 mutex(free).

output@@ schej{$p, @p, d_time(T), dead{$t}}/,
		 death{$s, @s}
										:-	int(T)							|
		 schej{$p, @p},
		 death{$s, @s, time(T), task{$t}}.

spawn{
	rel@@ time(T), task{r(R1, R2), $t}
										:-	int(T), int(R1), int(R2),
											(T >= R1)	|
		 r_time(T), r_task{r(R1, R2), $t}.
}.

output@@ spawn{$s, @s, r_time(T), r_task{$t}}/,
		 ready{$r, @r}
										:-	int(T)	|
		 spawn{$s, @s, time(T)},
		 ready{$r, @r, task{$t}}.

ready{
	ch1@@ time(T), task{d(D1, D2), $t}
										:-	int(T), int(D1), int(D2),
		  									(D1 =< T)			 			|
	  	d_time(T), dead{d(D1, D2), $t}
}.
output@@ ready{$r, @r, d_time(T), dead{$d}}/,
		 death{$p}
										:-	int(T)							|
		 ready{$r, @r},
		 death{$p, time(T), dead{$d}}.		

death{}.

sleep{
	ch2@@ task{r(R1, R2), t(T1, T2), d(D1, D2), $t},
		  time(P)
										:-	int(P),	 int(R1), int(R2),
											int(T1), int(T2), int(D1),
											int(D2), (P >= T1),
											(T3 = T1 + T2),
											(R3 = T1 + R2),	(D3 = T1 + D2)	|
		  wake{r(R3, R2), t(T3, T2), d(D3, D2), $t},
		w_time(P).
}.

output@@ sleep{$s, @s, w_time(T), wake{$w}}/,
		 spawn{$r, @r}
										:-	int(T)	|
		 sleep{$s, @s, time(T)},
		 spawn{$r, @r, task{$w}}.


select@@	ready{task{$t}, $r, @r},
			schej{time(T), @s}
										:-  int(T), \+($t=(mutex(M), $tt))	|
			ready{$r, @r},
			schej{time(T), wait{$t}, @s}.

			ready{task{mutex(M), $t}, $r, @r},
			schej{time(T), @s},
			mutex(free)
										:-  int(T), int(M)	|
			ready{$r, @r},
			schej{time(T), wait{mutex(USE), $t}, @s},
			mutex(USE).
			
			ready{task{mutex(USE), $t}, $r, @r},
			schej{time(T), @s},
			mutex(USE)
										:-  int(T)		|
			ready{$r, @r},
			schej{time(T), wait{mutex(USE), $t}, @s},
			mutex(USE).			
			
			ready{$r, @r, task{p(P1), $t}},
			schej{time(T), wait{p(P2), c(C1, C2), $w}, @s}
										:-	int(T),  int(P1), int(P2),
											int(C1), int(C2),
											\+($t=(mutex(M), $tt)),
											\+($w=(mutex(MM), $ww)),											
											(P1 > P2), (C1 > 0)	|
			ready{$r, @r, task{p(P2), c(C1, C2), $w}},
			schej{time(T), wait{p(P1), $t}, @s}.
			
			ready{$r, @r, task{p(P1), mutex(M), $t}},
			schej{time(T), wait{p(P2), c(C1, C2), $w}, @s},
			mutex(free)
										:-	int(T),  int(P1), int(P2),
											int(C1), int(C2), int(M),
											\+($w=(mutex(MM), $ww)),
											(P1 > P2), (C1 > 0)	|
			ready{$r, @r, task{p(P2), c(C1, C2), $w}},
			schej{time(T), wait{p(P1), mutex(USE), $t}, @s},
			mutex(USE).

			ready{$r, @r, task{p(P1), mutex(USE), $t}},
			schej{time(T), wait{p(P2), c(C1, C2), $w}, @s},
			mutex(USE)
										:-	int(T),  int(P1), int(P2),
											int(C1), int(C2),
											\+($w=(mutex(M), $ww)),
											(P1 > P2), (C1 > 0)	|
			ready{$r, @r, task{p(P2), c(C1, C2), $w}},
			schej{time(T), wait{p(P1), mutex(USE), $t}, @s},
			mutex(USE).

			ready{$r, @r, task{p(P1), $t}},
			schej{time(T), wait{p(P2), c(C1, C2), mutex(USE), $w}, @s},
			mutex(USE)
										:-	int(T),  int(P1), int(P2),
											int(C1), int(C2), C1 =:= C2,
											\+($t=(mutex(M), $tt)),
											(P1 > P2), (C1 > 0)	|
			ready{$r, @r, task{p(P2), c(C1, C2), mutex(0), $w}},
			schej{time(T), wait{p(P1), $t}, @s},
			mutex(free).

			ready{$r, @r, task{p(P1), $t}},
			schej{time(T), wait{p(P2), c(C1, C2), mutex(USE), $w}, @s},
			mutex(USE)
										:-	int(T),  int(P1), int(P2),
											int(C1), int(C2), C1 =\= C2,
											\+($t=(mutex(M), $tt)),
											(P1 > P2), (C1 > 0)	|
			ready{$r, @r, task{p(P2), c(C1, C2), mutex(USE), $w}},
			schej{time(T), wait{p(P1), $t}, @s},
			mutex(USE).

			ready{$r, @r, task{p(P1), mutex(USE), $t}},
			schej{time(T), wait{p(P2), c(C1, C2), mutex(M), $w}, @s},
			mutex(USE)
										:-	int(T),  int(P1), int(P2),
											int(C1), int(C2), int(M),
											C1 =:= C2,
											(P1 > P2), (C1 > 0)	|
			ready{$r, @r, task{p(P2), mutex(M), c(C1, C2), $w}},
			schej{time(T), wait{p(P1), mutex(USE), $t}, @s},
			mutex(USE).
			
s2ready@@	schej{$s, @s, c1_time(T)},
			ready{$p, @p}
										:-	int(T)	|
			schej{$s, @s},
			ready{$p, @p, time(T)}.
			
r2sleep@@	ready{$r, @r, time(T)}/,
			sleep{$s, @s}
										:-	int(T)	|
			ready{$r, @r},
			sleep{$s, @s, time(T)}.
			
s2spawn@@	sleep{$s, @s, time(T)}/,
			spawn{$r, @r}
										:-	int(T)	|
			sleep{$s, @s},
			spawn{$r, @r, time(T)}.
				
s2schej@@	spawn{$sp, @sp, time(T)}/
										:-	int(T)	|
			spawn{$sp, @sp}, time(T).
			
control@@
			time(T), limit(L)		:-	int(T), T >= L |
			end_time(T).
			
			time(T), limit(L), schej{@s}
									:-	int(T), T <  L |
			limit(L), schej{time(T), @s}.
			
			time(T), limit(L), schej{task{$t}, @s}
									:-	int(T), T <  L |
			limit(L), schej{time(T), wait{$t}, @s}.

passed@@	schej{time(T), @t},
			ready{@r}
										:-	int(T), T2 = (T + 1)	|
			schej{c1_time(T2), @t},
			ready{@r}.

}.

emptive@@	{schej{wait{$w}, $s, @s}, $p, @p}/	:-
			    {schej{task{$w}, $s, @s}, $p, @p}.