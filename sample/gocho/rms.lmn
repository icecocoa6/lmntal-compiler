% rms.lmn 
% 		2008.09.10
%
% Rate Monotonic Sceduling
%
%		0. Safety: スケジューリング完了である最終状態が存在する
%		1. Safety : 常にRate Monotonicに基づく、への否定(優先度逆転)状態が存在する
%		2. Safety : property0が成り立たないなんらかの最終状態が存在する(デッドロック探索)

selOK @@ {$p,@p, schej{$s,@s, wait{$w}}}/ :- {$p,@p, schej{$s,@s, task{$w}}}.
{
input{
  task{r(1), c(1), d(6), t(6),  p(2,a)}.
  task{r(0), c(3), d(8), t(8),  p(1,b)}.
  task{r(0), c(4), d(12),t(12), p(0,c)}.
  //全タスクの周期の最小公倍数が総周期
  input @@ task{r(R), c(C), d(D), t(T), $t} :- int(R),int(C),int(D),int(T) |
           task{r(R,R), c(C,C), d(D,D), t(T,T), $t}, n(T).
  _lcm0 @@ n(X), n(Y)    :- X>=Y               | lcm(X,Y).
  _lcm1 @@ lcm(X,Y)      :- X>=Y, P=X*Y        | gcd(X,Y), lcm(P).
  _lcm2 @@ gcd(X,Y)      :- Z=(X mod Y), Z=\=0 | gcd(Y,Z).
  _lcm3 @@ gcd(X,Y)      :- (X mod Y)=:=0      | gcd(Y).
  _lcm4 @@ gcd(X),lcm(Y) :- Z=Y/X              | n(Z).
}.
i_OUT @@ spawn{@r}, input{$p[],@p,n(N)}/ :- int(N) |
         spawn{@r,$p[],time(0)}, lim(N), input{$p[]}.


// task処理周りの膜
schej{
  schj0 @@ time(T), task{c(C,CC), d(D,DD),$t} :- int(CC),int(DD), C=\=0, Y=T+1, Y>D |
           dime(T), dead{c(C,CC),d(DD,DD),$t}. //デッドラインを越える場合
  schj1 @@ time(T), task{c(C,CC), d(D,DD),$t} :- int(CC),int(DD),C>0,X=C-1,Y=T+1,Y=<D |
           cime(Y), task{c(X,CC), d(D,DD),$t}. //schj1の適用ごとに、Tsc2rの適用へ
}.
s0OUT @@ schej{$s,@s, dead{$t}}/ :- death{$s,@s, dead{$t}}. //終了
s1OUT @@ schej{$p,@p, time(T), task{c(C,CC),$t}}/, sleep{$s,@s} :- int(T),int(C),int(CC) |
		     schej{$p,@p, time(T)}, sleep{task{c(CC,CC), $t},$s,@s}. //task: sleep膜へ
tSC2R @@ schej{$s,@s, cime(T)}, ready{$r,@r} :- int(T) |
         schej{$s,@s}, ready{$r,@r, time(T)}.
				


// release timeの監視
spawn{
  spawn @@ time(T), task{r(R,RR),$t} :- int(RR),T>=R | rime(T), rask{r(R,RR),$t}.
}.
spOUT @@ spawn{$s,@s, rime(T), rask{$t}}/, ready{$r,@r} :- int(T) |
         spawn{$s,@s, time(T)}, ready{$r,@r, task{$t}}. //task: 再活性⇒ready膜へ
tSP2O @@ spawn{$s,@s, time(T)}/ :- int(T)	| spawn{$s,@s}, time(T). // time: 膜外へ

// デッドラインの監視
ready{
  ready @@ time(T), task{d(D,DD),$t}	:- int(DD), D<T |
           dime(T), dead{d(D,DD),$t}
}.
r_OUT @@ ready{$r,@r, dead{$t}}/ :- death{$r,@r, dead{$t}}. //終了
tR2SL @@ ready{$r,@r, time(T)}/, sleep{$s,@s} :- int(T)	|
         ready{$r,@r}, sleep{$s,@s, time(T)}. // time: デッドライン検査終了後にsleep膜へ

rSEL0 @@ ready{$r,@r, task{$t}}, schej{@s, time(T)}	:- int(T)	|
         ready{$r,@r}, schej{@s, time(T), wait{$t}}.
rSEL1 @@ ready{$r,@r, task{p(P,N),$t}}, schej{time(T), wait{p(PP,NN), c(C,CC),$w},@s}
										:-	int(T),int(CC),unary(N),unary(NN),P>PP,C>0 |
         ready{$r,@r, task{p(PP,NN), c(C,CC),$w}}, schej{time(T), wait{p(P,N),$t},@s}.


// 実行周期を監視
sleep{
  sleep @@ task{r(R,RR), t(T,TT), d(D,DD),$t}, time(P) :- int(R),int(D), P>=T, X=T+TT, Y=TT+RR, Z=T+DD |
          wake{r(Y,RR), t(X,TT), d(Z,DD),$t}, wime(P).
}.
slOUT @@ sleep{$s,@s, wime(T), wake{$w}}/, spawn{$r,@r} :-	int(T) |
         sleep{$s,@s, time(T)}, spawn{$r,@r, task{$w}}. //task: 起床⇒spawn膜へ
tSL2S @@ sleep{$s,@s, time(T)}/, spawn{$r,@r} :- int(T) |
         sleep{$s,@s}, spawn{$r,@r, time(T)}. //time: 各taskの周期検査終了⇒spawn膜へ

// OUT部
END_T @@ lim(L), time(T) :- T=:=L | end(T).
tO2S0 @@ lim(L), time(T), schej{@s} :- T<L | lim(L), schej{@s, time(T)}.
tO2S1 @@ lim(L), time(T), schej{@s, task{$t}} :- T<L |
         lim(L), schej{@s, time(T), wait{$t}}.
passT @@ schej{time(T),@t}, ready{@r} :- X=T+1	|	schej{cime(X),@t}, ready{@r}.
}.
