% rms.lmn 
% 		2008.09.10
%
% Rate Monotonic Sceduling
%
%		0. Safety: スケジューリング完了である最終状態が存在する
%		1. Safety : 常にRate Monotonicに基づく、への否定(優先度逆転)状態が存在する
%		2. Safety : property0が成り立たないなんらかの最終状態が存在する(デッドロック探索)
/*
selOK @@ {$p,@p, schej{$s,@s, wait{$w}}}/ :- {$p,@p, schej{$s,@s, task{$w}}}.
{*/
state(input).

init{
  integer.use.
  task{r(1), c(1), d(6), t(6)}.
  task{r(0), c(3), d(8), t(8)}.
  task{r(0), c(4), d(12),t(12)}.
  
  init1 @@ task{$t, t(T)} :- int(T) | task{$t, tt(T)}, n(T). //uniq使いたい
  init2 @@ n(M), n(N) :- n=integer.lcm(M,N).  
}.
i_OUT @@ state(input), init{$p[],@p}/ :- state(spawn), $p[].


job=[].

/*

// task処理周りの膜
schej{
  schj0 @@ time(T), task{c(C,CC), d(D,DD),$t} :- int(CC),int(DD), C=\=0, Y=T+1, Y>D |
           dime(T), dead{c(C,CC),d(DD,DD),$t}. //デッドラインを越える場合
  schj1 @@ time(T), task{c(C,CC), d(D,DD),$t} :- int(CC),int(DD),C>0,X=C-1,Y=T+1,Y=<D |
           cime(Y), task{c(X,CC), d(D,DD),$t}. //schj1の適用ごとに、Tsc2rの適用へ
}.
s0OUT @@ schej{$s,@s, dead{$t}}/ :- death{$s,@s, dead{$t}}. //終了
s1OUT @@ schej{$p,@p, time(T), task{c(C,CC),$t}}/, sleep{$s,@s} :- int(T),int(C),int(CC) |
		     schej{$p,@p, time(T)}, sleep{task{c(CC,CC), $t},$s,@s}. //task: sleep膜へ
tSC2R @@ schej{$s,@s, cime(T)}, ready{$r,@r} :- int(T) |
         schej{$s,@s}, ready{$r,@r, time(T)}.
				


// release timeの監視
spawn{
  spawn @@ time(T), task{r(R,RR),$t} :- int(RR),T>=R | rime(T), rask{r(R,RR),$t}.
}.
spOUT @@ spawn{$s,@s, rime(T), rask{$t}}/, ready{$r,@r} :- int(T) |
         spawn{$s,@s, time(T)}, ready{$r,@r, task{$t}}. //task: 再活性⇒ready膜へ
tSP2O @@ spawn{$s,@s, time(T)}/ :- int(T)	| spawn{$s,@s}, time(T). // time: 膜外へ

// デッドラインの監視
ready{
  ready @@ time(T), task{d(D,DD),$t}	:- int(DD), D<T |
           dime(T), dead{d(D,DD),$t}
}.
r_OUT @@ ready{$r,@r, dead{$t}}/ :- death{$r,@r, dead{$t}}. //終了
tR2SL @@ ready{$r,@r, time(T)}/, sleep{$s,@s} :- int(T)	|
         ready{$r,@r}, sleep{$s,@s, time(T)}. // time: デッドライン検査終了後にsleep膜へ

rSEL0 @@ ready{$r,@r, task{$t}}, schej{@s, time(T)}	:- int(T)	|
         ready{$r,@r}, schej{@s, time(T), wait{$t}}.
rSEL1 @@ ready{$r,@r, task{p(P,N),$t}}, schej{time(T), wait{p(PP,NN), c(C,CC),$w},@s}
										:-	int(T),int(CC),unary(N),unary(NN),P>PP,C>0 |
         ready{$r,@r, task{p(PP,NN), c(C,CC),$w}}, schej{time(T), wait{p(P,N),$t},@s}.


// 実行周期を監視
sleep{
  sleep @@ task{r(R,RR), t(T,TT), d(D,DD),$t}, time(P) :- int(R),int(D), P>=T, X=T+TT, Y=TT+RR, Z=T+DD |
          wake{r(Y,RR), t(X,TT), d(Z,DD),$t}, wime(P).
}.
slOUT @@ sleep{$s,@s, wime(T), wake{$w}}/, spawn{$r,@r} :-	int(T) |
         sleep{$s,@s, time(T)}, spawn{$r,@r, task{$w}}. //task: 起床⇒spawn膜へ
tSL2S @@ sleep{$s,@s, time(T)}/, spawn{$r,@r} :- int(T) |
         sleep{$s,@s}, spawn{$r,@r, time(T)}. //time: 各taskの周期検査終了⇒spawn膜へ

// OUT部
END_T @@ lim(L), time(T) :- T=:=L | end(T).
tO2S0 @@ lim(L), time(T), schej{@s} :- T<L | lim(L), schej{@s, time(T)}.
tO2S1 @@ lim(L), time(T), schej{@s, task{$t}} :- T<L |
         lim(L), schej{@s, time(T), wait{$t}}.
passT @@ schej{time(T),@t}, ready{@r} :- X=T+1	|	schej{cime(X),@t}, ready{@r}.
}.
*/