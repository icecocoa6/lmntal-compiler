% edf.lmn
% 		2008.12.10
%
% Earliest Deadline First Scheduling
% 
% dynamic allocation priority to task
%    that have deadline nearset of all tasks.


{
input{

task{r(0), c(1), d(2),  t(4), name(a)}.
task{r(0), c(3), d(3),  t(4), name(b)}.
task{r(0), c(4), d(10), t(12),name(c)}.

init@@	task{r(R),    c(C),    d(D),    t(T), $t}
										:-  int(R), int(C), int(D), int(T)					|
				task{r(R, R), c(C, C), d(D, D), t(T, T), $t}, n(T).
lcm0@@  n(X), n(Y)	  :- X >= Y               | lcm(X, Y).
lcm1@@	lcm(X, Y)		  :- X >= Y, P = X * Y    | gcd(X, Y), lcm(P).
gcd1@@  gcd(X, Y)		  :- Y2 = X mod Y, Y2=\=0 | gcd(Y, Y2).		
gcd2@@	gcd(X, Y)	  	:- (X mod Y) =:=0       | gcd(Y).
lcm2@@  gcd(X),lcm(Y)	:- D = Y / X            |	n(D).
}.
output@@	spawn{@r}, input{$p, @p, n(N)}/		:-  int(N)	|
					spawn{@r, $p, time(0)}, limit(N).

schej{
	run1@@ time(T),  task{c(C1, C2), d(D1, D2), $t}
	 											:-	int(T),  int(C1), int(C2), int(D1), int(D2),
	 													(C1 > 0), (C12 = C1 - 1),
	 													(T2  = T  + 1), T2 =< D1		|
			c1_time(T2), task{c(C12, C2), d(D1, D2), $t}.
		
	run0@@ time(T), task{c(C1, C2), d(D1, D2), $t}
	 											:-	int(T),  int(C1), int(C2),
	 													int(D1), int(D2), T+1 > D1,
	 													C1 =\= 0		|
			 d_time(T), dead{c(C1, C2), d(D1, D2), $t}.
}.
output@@ schej{$p, @p, time(T), task{c(C1, C2), $t}}/,
		 		 sleep{$s, @s}
												:-	int(T), int(C1), int(C2)		|
				 schej{$p, @p, time(T)},
				 sleep{$s, @s, task{c(C2, C2), $t}}.
output@@ schej{$p, @p, d_time(T), dead{$t}}/,
		 		 death{$s, @s}
												:-	int(T)							|
		 		 schej{$p, @p},
		 		 death{$s, @s, time(T), task{$t}}.

spawn{
	rel@@ time(T),   task{r(R1, R2), $t}
												:-	int(T), int(R1), int(R2), (T >= R1)	|
		  r_time(T), r_task{r(R1, R2), $t}.
}.

output@@ spawn{$s, @s, r_time(T), r_task{$t}}/,
				 ready{$r, @r}
												:-	int(T)	|
		 		 spawn{$s, @s, time(T)},
		 		 ready{$r, @r, task{$t}}.

ready{
	ch1@@ time(T), task{d(D1, D2), $t}
												:-	int(T), int(D1), int(D2), (D1 =< T)		|
			d_time(T), dead{d(D1, D2), $t}
}.
output@@ ready{$r, @r, d_time(T), dead{$d}}/,
				 death{$p}
												:-	int(T)							|
		 		 ready{$r, @r},
		 		 death{$p, time(T), dead{$d}}.		

death{}.

sleep{
	ch2@@ task{r(R1, R2), t(T1, T2), d(D1, D2), $t},
		  	time(P)
												:-	int(P),	 int(R1), int(R2),
														int(T1), int(T2), int(D1),
														int(D2), (P >= T1),
														(T3 = T1 + T2),
														(R3 = T1 + R2),	(D3 = T1 + D2)	|
			  wake{r(R3, R2), t(T3, T2), d(D3, D2), $t},
			w_time(P).
}.
output@@ sleep{$s, @s, w_time(T), wake{$w}}/,
				 spawn{$r, @r}
												:-	int(T)	|
		 		 sleep{$s, @s, time(T)},
		 		 spawn{$r, @r, task{$w}}.

select@@ ready{task{$t}, $r, @r},
				 schej{time(T), @s}
												:-  int(T)	|
				 ready{$r, @r},
				 schej{time(T), wait{$t}, @s}.
			
				ready{$r, @r,  task{d(D01, D02), $t}},
				schej{time(T), wait{d(D11, D12), c(C1, C2), $w}, @s}
												:-	int(T),   int(D01), int(D02),
														int(D11), int(D12), int(C1), int(C2),
														(D01 < D11), (C1 > 0)	|
				ready{$r, @r,  task{d(D11, D12), c(C1, C2), $w}},
				schej{time(T), wait{d(D01, D02), $t}, @s}.

s2ready@@	schej{$s, @s, c1_time(T)},
					ready{$p, @p}
												:-	int(T)	|
					schej{$s, @s},
					ready{$p, @p, time(T)}.
			
r2sleep@@	ready{$r, @r, time(T)}/,
					sleep{$s, @s}
												:-	int(T)	|
					ready{$r, @r},
					sleep{$s, @s, time(T)}.
			
s2spawn@@	sleep{$s, @s, time(T)}/,
					spawn{$r, @r}
												:-	int(T)	|
					sleep{$s, @s},
					spawn{$r, @r, time(T)}.

s2schej@@	spawn{$sp, @sp, time(T)}/
												:-	int(T)	|
					spawn{$sp, @sp}, time(T).
			
control@@
			time(T), limit(L)	:-	int(T), T >= L | end_time(T).		
			time(T), limit(L), schej{@s} :-	int(T), T <  L |
			limit(L), schej{time(T), @s}.
			
			time(T), limit(L), schej{task{$t}, @s}
									:-	int(T), T <  L |
			limit(L), schej{time(T), wait{$t}, @s}.

passed@@ schej{time(T), @t},
				 ready{@r}
										:-	int(T), T2 = (T + 1)	|
				 schej{c1_time(T2), @t},
				 ready{@r}.
}.

emptive@@	{schej{wait{$w}, $s, @s}, $p, @p}/	:-
					{schej{task{$w}, $s, @s}, $p, @p}.