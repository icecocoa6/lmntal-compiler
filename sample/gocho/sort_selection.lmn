%  sort_selection.lmn
%
%	選択整列法

{
	% プロセス
	data([10, 1, 5, 20, 3, 19, 7, 8,  0, 2]).
	min.

	% ルール
	init_min@@	data([X |R]), min	:- data(R), min(X).
	m_change@@	F=[X |R], min(M)  :- M>X | 	F=[M |R], min(X).
}.

sort([]).
m_output@@
	{min(M), data([X |R]), $p[R], @p}/, sort(S)	:- int(M), int(X) |
	{min(X), data(R),      $p[R], @p},  sort([M |S]).
		
sort_end@@	{min(M), data([]), $p, @p}/, sort(S)     	:- int(M) |
		{min,    data([]), $p, @p},  sort([M |S]).

%% 性質ルール
% <>[]p. p:左＞右
/*
ltl1@@	t0_init{$p, @p} :- t0_init{$p, @p}.

ltl2@@	t0_init{L=[X1, X2 |R], $p[L, R], @p}	:-	(X1 > X2)	|
	  	 accept{L=[X1, X2 |R], $p[L, R], @p}.

ltl3@@	 accept{L=[X1, X2 |R], $p[L, R], @p}	:-	(X1 > X2)	|
	  	 accept{L=[X1, X2 |R], $p[L, R], @p}.
	  	 */