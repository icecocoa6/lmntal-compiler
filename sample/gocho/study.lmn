% 中間命令列の勉強用

// list構造を探す。
// 環状構造を探す。
// tree構造を探す。
// 階層構造を探す。
// それぞれ、長さ指定or不定長で。
{	
	a(X, Z, H, Q).
 	a(2).
 	a(d, L1).
 	d(L1, x).
 	a(d(e(w), d), L27).
 	any(10, L27, a(b, c)).
 	list([1, a(2, 1), 3, 4]).
	data([1,2,3,4,5 |tail]).
 	data([1,2,3,4,1000]).
 	some([1,a,b,c(L32),30]).
 	test(L32, 2).
 	RING=[1,1,1,1 |RING].
	{	
		a(X, Y).
		F=[1, 2, 3, 4, 5, 6, 7 |F].
		a(0, a).
		a(0, 1).
		{	
			a(Y, Z, Q).
			list([(1,0), (2,0), (3,E)]).
			a(3, 1).
			{	
				+E.
				+H.
			}.
		}.
	}.

}.
/*
rule@@	{a(X, S), $p, @p}, out{$o} :- int(X), int(S) |
		{$p, @p}, {a(X, S), $o, @p}.*/
	
rule2@@
{data(Y), '.'(A, X, Y),  '.'(B, X2, X), '[]'(X2), $p, @p},
 	:- unary(A), int(B), \+($p=(ok, $pp)) | 
{data(Y), '.'(A, X, Y),  '.'(B, X2, X), '[]'(X2), ok, $p, @p}.

/*
{data(A), $p[A], @p}	:- {test(A), $p[A], @p}.
*/
//膜をまたぐリンクを含まない2価のアトムaを削除するルール
/*a@@ {a(A, B), $p} :- ground(A), ground(B) |
	$p}.
*/

/*
a(2), a(2), a(1, L2), a(L1), a(L1, L2).
[1,2,3].
data([a(Y), b(2), c(3)]).
RING=[a, b, c(X) | RING].
c(X, Y).

data([a(Y1), b(2), c(3)]).
RING2=[a, b, c(X1) | RING2].
c(X1, Y1, Z1).
{+Z1}.
*//* お尻が'[]'のリストだけ抜き出して名称変更。*/
//できないこと[なんでもいいからとにかくリスト][リンク先に膜があるリスト]
/*{{
data=[a(1),a(2),a(3)].
data=[a, b, c].
data=[a(10, 5), a(1, 20), a(L0)].
hello. a(10, L1). a(L1, 2, L2). a(L2, 5).
{+L0}.
}.
output{}.
rule@@ {'[]'(A), $p, @p},
	   output{$o}	:- ground(A) |
	   {$p, @p},
	   output{'yeah!'(A), $o}.
}.
end@@ {output{$o}, $p[], @p}/ :- output{$o}. */
/* 大きさ5のわっかをみつける。不定長のわっかを探すには･･･ */
/*stop{
	input{
		A=[1,2,3 |A].
		B=[1,2,3,4,5 |B].
		C=[1,2,3,4 |C].
		D=[a,b,c,d,e,f,g |D].
		E=[a, 1, a(2), b(3, 4), a(L) |E], +L.
		data([a(1),a(2),a(3) |nil]).
		list([a, b, c |edge]).
		data([a(10, 5), a(1, 20), a(L0)]).
		{+L0}.
		hello. a(10, L1). a(L1, 2, L2). a(L2, 5).
	}.
	output{}.
	rule@@ output{$p}, input{data(A), $q, @q} :-  ground(A) |
	 	   output{$p, data(A)}, input{$q, @q}.
}.
end@@ stop{output{$o[]}, $p[], @p}/ :- output{$o[]}.
*/
/*
{head=[1, 2, 3, 4]}.
unko@@	{F=[L,R |P], $p[F,P], @p}	:-
		{F=[R,L |P], $p[F,P], @p}.
*//*
p{
input{
	a(10). a(b, 2).
	a(3). a(1, L, 3).
	b(3). b(1, L).
	mem1{a(3), a(2, d(a(4)))}.
	mem1{a(a), a(3), mem2{test. a(5)}}.
}.
output{}.
rule@@	input{a(A), $p}, output{$q}	:- int(A)	|
		input{$p}, output{a(A), $q}.
}.
end@@ p{output{$q}, $p[], @p}/ :- p{output{$q}}.
*/