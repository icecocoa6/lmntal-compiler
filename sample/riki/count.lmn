% マルチヘッドの書き換え,膜の計算の停止,1個も存在しないチェック  で4則演算
% 式一つ一つにルールを書く必要がある
% 条件分岐はできる. どの分岐にいるかを示すアトム + 分岐内の式のルールはそれをマッチ
% ループは…初期化を頑張ればできるかも知れない

% 存在しないチェックは,膜が停止していることを確認するか, 
% 状態の違いからチェック対象が増えないことがわかっていなければいけない.
% 以下の例ではyは前者, tは後者

% y_stopみたいなアトムを作って依存性を解決すれば 停止の確認はなくせそう
% 初期状態では 定数であるx_stop, y_stopはあり、これから計算するz_stopはなし
% 引数が全部stopした状態で計算が終われば出力先もstop
% 下の例ではxはstopしていなくても計算を進められる が z_stopは出ないまま
% 逆にyがstopするまでは計算はすすめられない

% x,x_stop,y,y_stopをリストにして…てモデルの方が綺麗
% 演算子1つ(1種でなく)ごとにルール書くのと,引数使うのは同じこと.
% 1個も存在しないチェックが微妙だが 専用のatomをはさめばまぁいいだろう
% 状態は自分の引数  条件分岐が困るか

% 負数は相当つらい
% 符号アトムを作れば不可能ではない気がするが2引数なら+-4通りのルールを並べることに.

% a_bit2_on, b_bit2_on, carry_bit2_on :- c_bit2_on, carry_bit3_on.
% a_bit2_on, b_bit2_off, carry_bit2_off :- c_bit2_on, carry_bit3_off.
%   .....
% なんだかなぁ

% 変なモデルを考える必要なんてない気がする
% どう贔屓目に見てもリスト書き換えの方が綺麗

{  % z = x * y
% xがあれば実行
{$p, s0, x } :- {$p, s1, x}.
% yをzに加えつつtにコピー
{$p, s1, y} :- {$p, s1, z, t}.
% yが無くなったらxを1減らす  yが増えないことを確認
{$p, s1, x}/ :- \+($p=(y,$q)) | {$p, s2}.
% tからyへ移動
{$p, s2, t} :- {$p, s2, y}.
{$p, s2} :- \+($p=(t,$q)) | {$p, s0}.

{x,x,x, y,y,y, s0}.
}.

/*
{  % z = x + y
{$p, x} :- {$p, z}.
{$p, y} :- {$p, z}.

{x,x,x, y,y,y,y}.
}.

{  % z = x - y
{$p, x, y} :- {$p}.
% yがなければxをzに移動, yが増えないことを確認.
{$p, x}/ :- \+($p=(y,$q)) | {$p, z}.

{x,x,x,x, y,y}.
}.

{  % z = x / y
% yをtにバックアップしつつxをyで消す
{$p, s1, x, y} :- {$p, s1, t}.
% yが全部消えればzを1増やす yが増えないことを確認
{$p, s1}/ :- \+($p=(y,$q)) | {$p, s2, z}.
% tからyに戻す
{$p, s2, t} :- {$p, s2, y}.
{$p, s2} :- \+($p=(t,$q)) | {$p, s1}.

{x,x,x,x,x,x,x, y,y, s1}.
}.
*/
