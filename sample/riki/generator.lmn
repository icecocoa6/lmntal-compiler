
{
module(settings).

R=type_size('INTEGER') :- R=4.

R='FP' :- R=12.
R='SP' :- R=13.
R='LNK' :- R=14.
R='PC' :- R=15.
R='Z' :- R=16.
R='N' :- R=17.
R='NEXT' :- R=18.
}.

%% General Rules
{
module(general).
system_ruleset.

dup(A, B, C) :- int(A) |  B=A, C=A.
%dup_ref({$p}, B, C) :- |  {+B,+C, $p}.
dup(A, B, C, D) :- int(A) | B=A, C=A, D=A.
%dup_ref({$p}, B, C, D) :- |  {+B,+C,+D, $p}.
dup(A, B, C, D, E) :- int(A) | B=A, C=A, D=A, E=A.

//del(X) :- ground(X) | .

%%% List

// H=append([], B) :- H=B.
// H=append([Value|Next], B) :- H=[Value|append(Next, B)].
H=append(A, B) :- H=appendl([A,B]).
H=append(A, B, C) :- H=appendl([A,B,C]).
H=append(A, B, C, D) :- H=appendl([A,B,C,D]).

R=appendl([]) :- R=[].
R=appendl([[]|T0]) :- R=appendl(T0).
R=appendl([[H|T]|T0]) :- R=[H|appendl([T|T0])].

Len=length([Head|Tail], H) :- H=[Head|Tail0],  Len=length(Tail,Tail0)+1.
Len=length([],H) :- H=[], Len=0.

H=reverse(List) :- H=reverse(List, []).
H=reverse([], List) :- H=List.
H=reverse([Car|Cdr], List) :- H=reverse(Cdr, [Car|List]).

H=nth(0, [Car|Cdr]) :- ground(Cdr) | H=Car.
H=nth(I, [Car|Cdr]) :- ground(Car), I>0 | H=nth(I-1, Cdr).

R=fold({i(X,K), {$p[X,K,O]}, o(O)}, Knil, []) :- R=Knil.
R=fold({i(X,K), {$p[X,K,O]}, o(O)}, Knil, [H|T]) :-
  R=fold({i(X,K), {$p[X,K,O]}, o(O)}, $p[H,Knil], T).

R=foldr({i(X,K), {$p[X,K,O]}, o(O)}, Knil, []) :- R=Knil.
R=foldr({i(X,K), {$p[X,K,O]}, o(O)}, Knil, [H|T]) :-
  Y=foldr({i(X,K), {$p[X,K,O]}, o(O)}, Knil, T),
  $p[H,Y,R].

map({i(I), {$p[I,O]}, o(O)}, [], R) :- R = [].
map({i(I), {$p[I,O]}, o(O)}, [H0|T], R0) :-
    R0 = [H|R], $p[H0,H],
    map({i(I), {$p[I,O]}, o(O)}, T, R).

%%% Arithmetic

'+'(A,B,C) :- D=A+B | D=C.
'-'(A,B,C) :- D=A-B | D=C.
'*'(A,B,C) :- D=A*B | D=C.
'/'(A,B,C) :- D=A/B | D=C.

R=inc(A) :- int(A) | R=A+1.
R=dec(A) :- int(A) | R=A-1.

%%% Tuple

break2(t(L0,L1), R0, R1) :- L0=R0, L1=R1.
break3(t(L0,L1,L2), R0, R1, R2) :- L0=R0, L1=R1, L2=R2.

}.

%% Permanent Global Value Module
%% グローバルといっても階層の影響を受ける
{
module(pglobal).

create_pglobal(Name, V) :- pgval(Name, V).
R=pglobal_get(Name0), pgval(Name1, V) :- Name0=Name1 |
  dup_ref(V, V0, V1),
  R=V0,
  pgval(Name1, V1).
}.


%% Ground Key & Ground Value Map Module
%% キーと値がgroundのMap
{
module(ground_map).

Map=create_gmap :- gmap{+Map}.

gmap_put(Map, $key, $val), gmap{+Map, $p} :-  ground($key), ground($val) |
  gmap{t($key, $val), $p}.

Val=gmap_peek(Map, $key0), gmap{+Map, t($key1, $val), $p} :-
    $key0=$key1, ground($val) |
  Val=$val, gmap{t($key1, $val), $p}.

// Val=gmap_get(Map, $key0), gmap{+Map, t($key1, $val), $p} :-
//     $key0=$key1 |
//   Val=$val, gmap{$p}.

dup_ref(gmap{$p}, B, C) :- |  gmap{+B,+C, $p}.
dup_ref(gmap{$p}, B, C, D) :- |  gmap{+B,+C,+D, $p}.
del_ref(L), gmap{+L,$p} :- gmap{$p}.

}.

{
module(symbol).

//-----------------------------------------------------------------------
// Symbol Table
//-----------------------------------------------------------------------

syms_new @@
R=syms_new :- R=sym{}.

syms_put(Tbl, var{$p}), sym{+Tbl, $q} :- |
  sym{ var{$p}, $q}.

R=sym(offset, Ref, $id),
sym{+Ref, var{name(L0), offset(L1), $q}, $p},
$name[L0], $offset[L1] :-
    $name=$id, ground($offset) |
  sym{ var{name(L2), offset(L3), $q}, $p},
  $name[L2], $offset[L3],
  R=$offset.

R=sym(pass_type, Syms, $id),
sym{+Syms, var{name(L0), pass_type(L1), $q}, $p}, $name[L0], $pass_type[L1] :-
    $name=$id, ground($pass_type) |
  sym{ var{name(L2), pass_type(L3), $q}, $p},
  $name[L2], $pass_type[L3],
  R=$pass_type.

dup_ref(sym{$p}, B, C) :-   sym{+B,+C, $p}.
dup_ref(sym{$p}, B, C, D) :-  sym{+B,+C,+D, $p}.
del_ref(L), sym{+L,$p} :- sym{$p}.

}.

%% Procedure Declaration Table Module
%% 手続きの宣言の表
{
module(pdecl).

pdecl.use :-
  pglobal.use,
  ground_map.use,
  general.use.

gen_pdecl_tbl :-
  create_pglobal(g_decl_tbl, create_gmap).

R=get_pdecl_tbl :- R=pglobal_get(g_decl_tbl).

put_pdecl(Name0, I, var(Name1, PassType, Type)) :- gmap_put(get_pdecl_tbl, t(Name0, I), t(Name1, PassType, Type)).
put_pdecl(Name, Args)  :- ground(Name) |
  fold({i(Arg,Idx),
         {dup(Idx, Idx0, Idx1),
          put_pdecl(Name, Idx0, Arg),
          O=Idx1+1.},
        o(O)},
       0,
       Args, del).

R=proc_pass_type(Name, I) :- break3(gmap_peek(get_pdecl_tbl, t(Name, I)), del, R, del).

}.

%% Procedure Address Table Module
%% 手続きのアドレス表
{
module(paddr).

paddr.use :-
  pglobal.use,
  ground_map.use.

gen_paddr_tbl :-
  create_pglobal(g_paddr_tbl, create_gmap).

R=get_paddr_tbl :- R=pglobal_get(g_paddr_tbl).

set_paddr(Tbl, Name, Addr) :- gmap_put(Tbl, Name, Addr).
set_paddr(Name, Addr) :-
  set_paddr(get_paddr_tbl, Name, Addr).

Pos=proc_pos(Tbl, Name) :- Pos = gmap_peek(Tbl, Name).
Pos=proc_pos(Name) :-
  Pos = proc_pos(get_paddr_tbl, Name).
}.

{
module(module_gen).

module_gen.use :-
  general.use,
  symbol.use,
  settings.use,
  pdecl.use,
  paddr.use,
  syntax.use.

module_gen.init :-
  gen_paddr_tbl,
  gen_pdecl_tbl.

//----------------------------------------------------------------------

R=code_size(Insts, Insts0) :- R=length(Insts, Insts0).

//----------------------------------------------------------------------
//コード生成
//----------------------------------------------------------------------


integer @@
R=code_exp( int(X), SP, NewSP, SymTbl) :-  int(SP), int(X) |
  dup(inc(SP), SP0_1, NewSP),
  del_ref(SymTbl),
  R=[inst('MOVI', [SP0_1, 0, X])].

ident @@
R=code_exp( id(X), SP, NewSP, SymTbl) :-  int(SP), ground(X) |
  dup_ref(SymTbl, Syms0, Syms1),
  R=code_ident(X, sym(pass_type, Syms0, X), SP, NewSP, Syms1).

R=code_ident(X,'VALUE', SP, NewSP, SymTbl) :-  |
  dup(inc(SP), SP0_1, SP0_2),
  R=[inst('LDW', [SP0_1, 'FP', sym(offset, SymTbl, X)])], NewSP=SP0_2.

R=code_ident(X,'VAR', SP, NewSP, SymTbl) :- int(SP)  |
  dup(inc(SP), SP0_1, SP0_2, SP0_3, SP0_4),
  R=[inst('LDW', [SP0_1, 'FP', sym(offset, SymTbl, X)]),
     inst('LDW', [SP0_2+1, SP0_4, 0])],
  NewSP=SP0_3+1.

number @@
R=code_exp( number(A), SP, NewSP, SymTbl) :- int(SP) |
  del_ref(SymTbl),
  dup(inc(SP), SP0_1, SP0_2),
  R=[inst('MOVI', [SP0_1, 0, A])],
  NewSP = SP0_2.

paren @@
R=code_exp( paren(X), SP, NewSP, SymTbl) :- | R=code_exp(X, SP, NewSP, SymTbl).

R=code_exp( mul(A,B), SP, NewSP, SymTbl)  :- R=code_binop('MUL', A, B, SP, NewSP, SymTbl).
R=code_exp( plus(A,B), SP, NewSP, SymTbl) :- R=code_binop('ADD', A, B, SP, NewSP, SymTbl).
R=code_exp( eq(A,B), SP, NewSP, SymTbl)   :- R=code_binop('CMP', A, B, SP, NewSP, SymTbl).
R=code_exp( neq(A,B), SP, NewSP, SymTbl)   :- R=code_binop('CMP', A, B, SP, NewSP, SymTbl).
R=code_exp( lt(A,B), SP, NewSP, SymTbl)   :- R=code_binop('CMP', A, B, SP, NewSP, SymTbl).
R=code_exp( le(A,B), SP, NewSP, SymTbl)   :- R=code_binop('CMP', A, B, SP, NewSP, SymTbl).
R=code_exp( gt(A,B), SP, NewSP, SymTbl)   :- R=code_binop('CMP', A, B, SP, NewSP, SymTbl).
R=code_exp( ge(A,B), SP, NewSP, SymTbl)   :- R=code_binop('CMP', A, B, SP, NewSP, SymTbl).
// R=code_exp( and(A,B), SP, NewSP, SymTbl)   :- R=code_sentence(if(A, 
R=code_bool_exp(pos, eq(A,B), SP, NewSP, SymTbl)   :- R=t('BEQ', code_exp(eq(A,B), SP, NewSP, SymTbl)).
R=code_bool_exp(pos, neq(A,B), SP, NewSP, SymTbl)  :- R=t('BNE', code_exp(neq(A,B), SP, NewSP, SymTbl)).
R=code_bool_exp(pos, lt(A,B), SP, NewSP, SymTbl)   :- R=t('BLT', code_exp(lt(A,B), SP, NewSP, SymTbl)).
R=code_bool_exp(pos, gt(A,B), SP, NewSP, SymTbl)   :- R=t('BGT', code_exp(gt(A,B), SP, NewSP, SymTbl)).
R=code_bool_exp(pos, le(A,B), SP, NewSP, SymTbl)   :- R=t('BLE', code_exp(le(A,B), SP, NewSP, SymTbl)).
R=code_bool_exp(pos, ge(A,B), SP, NewSP, SymTbl)   :- R=t('BGE', code_exp(ge(A,B), SP, NewSP, SymTbl)).
// R=code_bool_exp(pos, and(A,B), SP, NewSP, SymTbl)   :- R=t('BR', code_exp(and(A,B), SP, NewSP, SymTbl)).

R=code_bool_exp(neg, eq(A,B), SP, NewSP, SymTbl)   :- R=t('BNE', code_exp(eq(A,B), SP, NewSP, SymTbl)).
R=code_bool_exp(neg, neq(A,B), SP, NewSP, SymTbl)  :- R=t('BEQ', code_exp(neq(A,B), SP, NewSP, SymTbl)).
R=code_bool_exp(neg, lt(A,B), SP, NewSP, SymTbl)   :- R=t('BGE', code_exp(lt(A,B), SP, NewSP, SymTbl)).
R=code_bool_exp(neg, gt(A,B), SP, NewSP, SymTbl)   :- R=t('BLE', code_exp(gt(A,B), SP, NewSP, SymTbl)).
R=code_bool_exp(neg, le(A,B), SP, NewSP, SymTbl)   :- R=t('BGT', code_exp(le(A,B), SP, NewSP, SymTbl)).
R=code_bool_exp(neg, ge(A,B), SP, NewSP, SymTbl)   :- R=t('BLT', code_exp(ge(A,B), SP, NewSP, SymTbl)).
// R=code_bool_exp(neg, and(A,B), SP, NewSP, SymTbl)   :- R=t('BGE', code_exp(ge(A,B), SP, NewSP, SymTbl)).

R=code_binop(Op, A, B, SP, NewSP, SymTbl) :-
  dup_ref(SymTbl, Syms0, Syms1),
  R0 = code_exp(A, SP, SP0, Syms0), 
  R1 = code_exp(B, SP0, SP1, Syms1), 
  dup(dec(SP1), SP1_1, SP1_2, SP1_3, SP1_4),
  R2 = [inst(Op, [SP1_1, SP1_2, SP1_3+1])],
  R = append(R0, R1, R2),
  NewSP = SP1_4.

call @@
R=code_sentence( call(Name, Params), SymTbl) :- unary(Name) |
  R = append(code_params(Name, 0, Params, SymTbl),
             [branch_to(Name)]).

parameters @@
R = code_params(Name, I, [], SymTbl) :- int(I), unary(Name) | del_ref(SymTbl), R=[].
R = code_params(Name, I, [H|T], SymTbl) :-  int(I), unary(Name) |
  dup_ref(SymTbl, Syms0, Syms1),
  R=append(code_param(H, proc_pass_type(Name, I), Syms0),
           code_params(Name, I+1, T, Syms1)).

R = code_param(Exp, PassType, SymTbl) :- ground(Exp) |
    R = code_param_sub(is_id(Exp), Exp, PassType, SymTbl).

R = code_param_sub(true, id(ID), PassType, SymTbl) :- unary(ID) |
  dup_ref(SymTbl, Syms0, Syms1),
    R=code_param_id(ID, sym(pass_type, Syms0, ID), PassType, Syms1).
R = code_param_sub(false, Exp, 'VALUE', SymTbl) :- |
    R0 = code_exp(Exp, -1, SP0, SymTbl),
    R=append(R0, [inst('PSH', [SP0, 'SP', 4])]).

R=code_param_id(ID, 'VAR', 'VAR', SymTbl) :-
    R = [inst('LDW', [0, 'FP', sym(offset, SymTbl, ID)]),
         inst('PSH', [0, 'SP', 4])].
R=code_param_id(ID, 'VAR', 'VALUE', SymTbl) :- |
    R = [inst('LDW', [0, 'FP', sym(offset, SymTbl, ID)]),
         inst('LDW', [1, 0, 0]),
         inst('PSH', [1, 'SP', 4])].
R=code_param_id(ID, 'VALUE', 'VAR', SymTbl) :-
    R = [inst('ADDI', [0, 'FP', sym(offset, SymTbl, ID)]),
         inst('PSH', [0, 'SP', 4])].
R=code_param_id(ID, 'VALUE', 'VALUE', SymTbl) :-
    R0 = code_exp(id(ID), -1, SP0, SymTbl),
    R=append(R0, [inst('PSH', [SP0, 'SP', 4])]).

assignment @@
R=code_sentence( assign(id(ID), Exp), SymTbl) :- unary(ID) |
  dup_ref(SymTbl, Syms0, Syms1, Syms2),
  R0 = code_exp( Exp, -1, SP0, Syms0),
  R = append(R0, code_assign(ID, sym(pass_type, Syms1, ID), SP0, Syms2)).

R=code_assign(ID, 'VALUE', SP, SymTbl) :- int(SP) |
    R = [inst('STW', [SP, 'FP', sym(offset, SymTbl, ID)])].

R=code_assign(ID, 'VAR', SP, SymTbl) :- int(SP) |
    R = [inst('LDW', [SP+1, 'FP', sym(offset, SymTbl, ID)]),
         inst('STW', [SP, SP+1, 0])].


R=code_sentence( if(Exp, Then), SymTbl) :-
  dup_ref(SymTbl, Syms0, Syms1),
  break2(code_bool_exp(neg, Exp, -1, del, Syms0), CondOp, ExpCode),
  JmpCode = code_cjump(CondOp, ThenSize+1), % ThenEpilogの分+1
  ThenSize = code_size(code_seq(Then, Syms1), ThenCode),
  R = appendl([ExpCode, JmpCode, ThenCode]).

R=code_sentence( if(Exp, Then, Else), SymTbl) :-
  dup_ref(SymTbl, Syms0, Syms1, Syms2),
  break2(code_bool_exp(neg, Exp, -1, del, Syms0), CondOp, ExpCode),
  JmpCode = code_cjump(CondOp, ThenSize+TEplSize+1), % ThenEpilogの分+1
  ThenSize = code_size(code_seq(Then, Syms1), ThenCode),
  TEplSize = code_size([inst('BR', [ElseSize+1])], ThenEpilog),
  ElseSize = code_size(code_seq(Else, Syms2), ElseCode),  
  R = appendl([ExpCode, JmpCode, ThenCode, ThenEpilog, ElseCode]).

R=code_cjump(Op, Offset) :-
  R=[inst(Op, [Offset])].

%% Special code for Predeclared procedures

R=code_sentence(load(X), SymTbl) :-
  R=[inst('LDW', [0, 'FP', sym(offset, SymTbl, X)])].

R=code_sentence(store(X, Reg), SymTbl) :-
  R=code_assign(X, 'VAR', Reg, SymTbl).

R=code_sentence(inst(Name, Args), SymTbl) :-
  del_ref(SymTbl),
  R=[inst(Name, Args)].

R=allign_vars(L, Offset, NewOffset) :- R=allign_vars_sub(L, Offset, NewOffset).
R=allign_vars_sub([], Offset, NewOffset) :- NewOffset = Offset, R=[].
R=allign_vars_sub([var(Name, PassType, $type) | Args], $offset, NewOffset) :- ground($type), ground($offset) |
  $type[Type0], $offset[Offset0],
  R=[var{name(Name), pass_type(PassType), type(Type0), offset(Offset0)} |
     allign_vars_sub(Args, $offset+type_size($type), NewOffset)].

R=prolog(Size) :- int(Size) |
  R=[inst('PSH', ['LNK', 'SP', 4]),
     inst('PSH', ['FP', 'SP', 4]),
     inst('MOV', ['FP', 0, 'SP']),
     inst('SUBI', ['SP', 'SP', Size])].

R=epilog(Size) :- int(Size) |
  R=[inst('MOV', ['SP', 0, 'FP']),
     inst('POP', ['FP', 'SP', 4]),
     inst('POP', ['LNK', 'SP', Size]),
     inst('RET', ['LNK'])].

put_syms(SymTbl, Syms) :-
  fold({i(Sym,Tbl), {dup_ref(Tbl, Tbl0, O), syms_put(Tbl0, Sym)}, o(O)}, SymTbl, Syms, del_ref).

proc @@
R=code_proc_sub( proc(Name, Args, Vars, Body)) :- ground(Args), unary(Name) |
  %% TODO: マジックナンバーの意味を復習する
  dup_ref(syms_new, SymTbl0, SymTbl1),

  dup(ArgsOffset, ArgsOffset0, ArgsOffset1),
  put_syms(SymTbl0, append(allign_vars(reverse(Args), 8, ArgsOffset),
                           allign_vars(Vars, ArgsOffset0, VarsOffset))),
  ArgsSize = (ArgsOffset1 - 8),
  VarsSize = VarsOffset,

  PrologCode = prolog(VarsSize),
  BodyCode = code_seq(Body, SymTbl1),
  EpilogCode = epilog(ArgsSize+4),
  R=append(PrologCode, BodyCode, EpilogCode).
  
R=code_proc(proc(Name, Args, Vars, Body)) :- ground(Name), ground(Args) |
  put_pdecl(Name, Args),
  R = proc(Name, code_proc_sub(proc(Name, Args, Vars, Body))).

R=code_procs([]) :- R=[].
R=code_procs([H|T]) :- R=[code_proc(H) | code_procs(T)].

R=proc_code(pdecl(Name, Args, Code, Len)) :-
    ground(Name), ground(Args), ground(Len) |
  R = Code.

R=code_seq( seq([]), SymTbl) :- | del_ref(SymTbl), R=[].
R=code_seq( seq([H|T]), SymTbl) :- |
  dup_ref(SymTbl, Syms0, Syms1),
  R=append(code_sentence(H, Syms0), code_seq(seq(T), Syms1)).

R = code_module( module(Name, Procs, Body) ) :- |
  place_procs([code_proc(proc('$MAIN', [], [], Body)),
               code_proc(proc('Write', [var(x, 'VALUE', 'INTEGER')], [],
                              seq([load(x), inst('WRD', [0,0,0])]))),
               code_proc(proc('WriteHex', [var(x, 'VALUE', 'INTEGER')], [],
                              seq([load(x), inst('WRH', [0,0,0])]))),
               code_proc(proc('WriteLn', [], [],
                              seq([inst('WRL', [0,0,0])]))),
               code_proc(proc('Read', [var(x, 'VAR', 'INTEGER')], [],
                              seq([inst('RD', [0, 0, 0]),
                                   store(x, 0)])))
               | code_procs(Procs)],
              Code),
  R = module(Name, Code, get_paddr_tbl).

place_procs(L, Insts) :- place_procs_sub(L, 0, Insts).
place_procs_sub([], Pos, Insts) :- int(Pos) | Insts=[].
place_procs_sub([proc(Name, ProcInsts) | T], InitPos, Insts) :- 
    ground(Name), ground(InitPos) |
  break2(fold({i(X,I), {break2(I,Pos,L),
                        dup(Pos,Pos0,Pos1),
                        O=t(Pos0+4,L0), L=[set_addr(X, Pos1)|L0].},
               o(O)},
              t(InitPos,FoldedCode),
              ProcInsts),
         AfterPos, []),
  set_paddr(Name, InitPos),
  place_procs_sub(T, AfterPos, RestInsts),
  Insts = append(FoldedCode, RestInsts).

R=set_addr(inst(Name, Args), Pos) :- int(Pos) | R=inst(Name, Args).
R=set_addr(branch_to(ProcName), Pos) :- int(Pos) |
  R=inst('BSR', [(proc_pos(ProcName) - Pos)/4]).
// R=set_addr(branch_eq(To), Pos) :- int(Pos) |
//   R='BEQ'(0, 0, To).
}.

%% Syntax Module
{
module(syntax).

break_module(module(Name, Code, Syms), Name0, Code0, Syms0) :- 
  Name=Name0, Code=Code0, Syms=Syms0.

R=is_id($exp) :- ground($exp) |
    R=is_id_sub({exp($exp). result(false).
                 exp(id(ID)), result(false) :- unary(ID) | result(true).
    }).

R=is_id_sub({result(Result). $p[], @p}/) :- unary(Result) |
    R=Result.
}.

%% Code Generator Module
{
module(generator).

generator.use :-
  syntax.use,
  paddr.use.

R=generate_code(SyntaxTree)  :- 
  break_module(trans_module(SyntaxTree), del, Code, del),
  R=put_main_call(Code).

R=trans_module($module)  :- ground($module) |
  R=trans_module_sub({module_gen.use. module_gen.init. 
                      Result=code_module($module)},
                     Result).

R=trans_module_sub(L, Result), {+L, $module[Result], @p}/ :-
  $module[R].

MainCode=put_main_call(Code) :-
  
  MainCode=[inst('BSR', [proc_pos('$MAIN')+2]), inst('HAL',[]) | Code]. % 追加分のコードサイズを加算する
}.

{
module(predeclared_proc).

}.

{
module(linker).



}.

%%% Main Code

compiler{
generator.use.

//----------------------------------------------------------------------
//R=del_inst(inst(N, [X])) :- int(N) | R=X. 

// T = assign( id(u), plus( mul( id(x), number(12) ), mul(id(z), id(w)) ) ).
// result( code_sentence(T, []) ).

// T = module('TEST_MODULE',
//            [proc('P',
//                 [var(x, 'VALUE', 'INTEGER'), var(y, 'VAR', 'INTEGER')],
//                 [],
//                 seq([
//                      assign(id(x), id(y)),
//                      assign(id(y), id(x)),
//                      call('P', [id(x), id(y)]),
//                      call('P', [id(y), id(x)])
//                  ]))],
//             seq([call('P', [])])).

// code = module('TEST_MODULE',
//            [proc('P',
//                 [var(x, 'VALUE', 'INTEGER'), var(y, 'VAR', 'INTEGER')],
//                 [],
//                 seq([
//                      assign(id(y), plus(id(x), int(1)))
//                  ])),
//                  proc('Q',
//                 [],
//                 [var(x, 'VALUE', 'INTEGER')],
//                  seq([
//                       call('P', [int(0), id(x)]),
//                  ]))],
//             seq([call('Q', [])])).

%% Read Write Example
% code = module('TEST_MODULE',
%            [proc('Q',
%                 [],
%                 [var(x, 'VALUE', 'INTEGER'),var(y, 'VALUE', 'INTEGER')],
%                  seq([ call('Read', [id(x)]), call('Write', [id(x)]), call('WriteLn', []),
% %                       if(lt(id(x),int(5)), seq([call('WriteLn', [])]), seq([call('Write', [int(2)])]))
%                        if(lt(id(x),int(10)), seq([call('Write', [int(0)])]), seq([call('Write',[int(1)])])),
%                        if(lt(int(20),id(x)), seq([call('Write', [int(0)])]), seq([call('Write',[int(1)])]))
%                  ]))],
%             seq([call('Q', [])])).

code(T) :- result=generate_code(T).

/*

proc f(max, i){
  if(max > i){
   write(0);
   f(max, i+1);
  }
}

proc m(){
  x = read();
  if(x!=0){
   y = read();
   g(y, 0);
   m();
  }
}

*/

code = module('TEST_MODULE',[
           proc('f',
                [var(max,'VALUE','INTEGER'),var(i,'VALUE','INTEGER')],
                [],
                 seq([if(gt(id(max),id(i)),
			    seq([call('Write', [int(0)]),
				 call('f', [id(max),plus(id(i),int(1))])]))])),
	   proc('m',
		[],
		[var(x,'VALUE','INTEGER')],
		seq([call('WriteHex', [int(62)]),
		     call('Read', [id(x)]),
		     if(neq(id(x),int(0)),
			seq([call('f', [id(x),int(0)]),
			     call('WriteLn', []),
			     call('m', [])]))]))],
         seq([call('m', [])])).
}.
