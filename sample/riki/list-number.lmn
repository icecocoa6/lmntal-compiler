/* ======================================================== */
/*      リスト整数 (n/2, []/1 による整数表現)      */
/* 組み込み整数を用いないグラフ書き換えによる非負数4則演算 */
/* trueを1 ( n([]) ), falseを0 ( [] )とした論理演算 */
/* ======================================================== */

/* ------------------------------------ */
/* 似た表現はどこにでもあるが一番近いinteraction netsの例に触れている(addのみ) */
/* Interaction Nets  diploma  Simon Gay */
/* http://www.dcs.gla.ac.uk/~simon/publications/diploma.pdf */
/* */
/* と思ったらもっと身近でLMNtal wikiのKUDOさんのページにmulまで書いてあった */
/* ------------------------------------ */

/* ==================================== */
/* 基本ルール */
/* ==================================== */

% リスト整数の削除
del(n(X)) :- del(X).
del([]) :- .

% リスト整数の端を取得 第1引数にリスト整数の頭を渡すと 第2引数がその頭、第3引数が末尾になる
tail(n(X),XH,XT) :- tail(X,XM,XT), n(XM,XH).
tail([],XH,XT) :- XH=XT.

% リスト整数のコピー
cp(X,del,Z2) :- Z2=X.
cp(X,Z1,del) :- Z1=X.
cp(n(X),Z1,Z2) :- cp(X,Z1T,Z2T), Z1=n(Z1T), Z2=n(Z2T).
cp([],Z1,Z2) :- Z1=[], Z2=[].


/* ==================================== */
/* 4則演算ルール */
/* ==================================== */

add(n(X),Y,Z) :- add(X,Y,ZT), Z=n(ZT).
add(X,n(Y),Z) :- add(X,Y,ZT), Z=n(ZT).
add([],Y,Z) :- Z=Y.
add(X,[],Z) :- Z=X.

sub(n(X),n(Y),Z) :- sub(X,Y,Z).
sub(X,[],Z) :- Z=X.

mul(X,n(Y),Z) :- cp(X,X1,X2), add(X1,mul(X2,Y),Z).
mul(X,[],Z) :- del(X), Z=[].

% div(X,0,Z) -> stop
div(X,n(Y),Z) :- div(X,n(YH),I,YT,Z), tail(Y,YH,i(YT,I)).
div(n(X),n(YH),I,YT,Z) :- div(X,YH,I,YM,Z), n(YM,YT).
div(X,i(YH,I),I,YT,Z) :- div(X,YH,I,YM,ZM), i(YM,I,YT), n(ZM,Z).
div([],n(YH),I,YT,Z), i(IH,I,IT) :- IH=IT, Z=[], YT=[], del(YH).

mod(X,n(Y),Z) :- mod(X,n(YH),I,YT,Z), tail(Y,YH,i(YT,I)).
mod(n(X),n(YH),I,YT,Z) :- mod(X,YH,I,YM,Z), n(YM,YT).
mod(X,i(YH,I),I,YT,Z) :- mod(X,YH,I,YM,Z), i(YM,I,YT).
mod([],n(YH),I,YT,Z), i(IH,I,IT) :- Z=IH, YT=[], IT=[], del(YH).

/*
%div naive
div(X,n(Y),Z) :- cp(n(Y),Y1,Y2), div_sub(X,Y1,Y2,Z).
div_sub(n(X),n(Y1),Y2,Z) :- div_sub(X,Y1,Y2,Z).
div_sub([],Y1,Y2,Z) :- del(Y1), del(Y2), Z=[].
div_sub(n(X),[],Y2,Z) :- div(n(X),Y2,ZT), Z=n(ZT).
% mod naive
mod(X,Y,Z) :- div(X1,Y1,A), mul(A,Y2,B), sub(X2,B,Z), cp(X,X1,X2), cp(Y,Y1,Y2).
*/

/* ==================================== */
/* 論理演算ルール */
/* ==================================== */

not(n([]),Y) :- Y=[].
not([],Y) :- Y=n([]).

or(n([]),Y,Z) :- Z=n([]), del(Y).
or(X,n([]),Z) :- Z=t, del(X).
or([],[],Z) :- Z=f.

and([],Y,Z) :- Z=[], del(Y).
and(X,[],Z) :- Z=[], del(X).
and(n([]),n([]),Z) :- Z=n([]).


/* ==================================== */
/* 条件演算ルール */
/* ==================================== */

eq(n(X),n(Y),Z) :- eq(X,Y,Z).
eq(n(X),[],Z) :- Z=[], del(X).
eq([],n(Y),Z) :- Z=[], del(Y).
eq([],[],Z) :- Z=n([]).

gt(n(X),n(Y),Z) :- gt(X,Y,Z).
gt(n(X),[],Z) :- Z=n([]), del(X).
gt([],Y,Z) :- Z=[], del(Y).

ge(n(X),n(Y),Z) :- ge(X,Y,Z).
ge(n(X),[],Z) :- Z=n([]), del(X).
ge([],[],Z) :- Z=n([]).
ge([],n(Y),Z) :- Z=[], del(Y).


/* ==================================== */
/* ライブラリ */
/* ==================================== */

% 組み込み整数からリスト整数への変換
R=gen(N) :- N=:=0 | R=[].
R=gen(N) :- N=\=0,M=N-1 | R=n(gen(M)).

% リスト整数から組み込み整数への変換
R=ret(X) :- R=ret(0,X).
R=ret(N,n(X)) :- M=N+1 | R=ret(M,X).
R=ret(N,[]) :- R=N.

% 組み込み整数M以上N未満のリスト整数を昇順で生成しリストに
R=gen_list(M,N) :- M=\=N,S=M+1 | R=[gen(M)|gen_list(S,N)].
R=gen_list(M,N) :- M>=N | R=[].

% リスト整数のリストを組み込み整数のリストに
R=ret_list([]) :- R=[].
R=ret_list([H|T]) :- R=[ret(H)|ret_list(T)].

% 最大公約数
R=gcd(X,Y) :- gcd_if_0(mod(X,Y1),Y2,R), cp(Y,Y1,Y2).
gcd_if_0(n(M),Y,R) :- R=gcd(Y,n(M)).
gcd_if_0([],  Y,R) :- R=Y.

% 最小公倍数
R=lcm(X,Y) :- R=div(mul(X1,Y1),gcd(X2,Y2)), cp(X,X1,X2), cp(Y,Y1,Y2).

% 素因数分解 (naive 素数以外でも割る)
R=primefactor(X) :- R=primefactor(n(n([])),X).
R=primefactor(N,n([])) :- R=[], del(N).
R=primefactor(N,n(n(X))) :- primefactor_if_0(mod(n(n(X1)),N1),N2,n(n(X2)),R), cp(X,X1,X2), cp(N,N1,N2).
primefactor_if_0([],N,X,R) :- R=[N1|primefactor(N2,div(X,N3))], cp(N,N1,NM), cp(NM,N2,N3).
primefactor_if_0(n(M),N,X,R) :- R=primefactor(n(N),X), del(M).              % ここで割る数を+1で決めているのが原因

% エラトステネスの篩
R=eratosthenes(X) :- R=sieve_tail(gen_list(2,ret(X))).
R=sieve_tail([]) :- R=[].
R=sieve_tail([H|T]) :- R=[H1|sieve_tail(sieve(H2,T))], cp(H,H1,H2).         % こいつらが同じなので2つあるのが不満
R=sieve_tail(prime(N,X)) :- R=[N1|sieve_tail(sieve(N2,X))], cp(N,N1,N2).    % (一番最初の2の篩を作るため)
R=sieve(N,[]) :- R=[], del(N).
R=sieve(N,prime(M,X)) :- R=prime(M,sieve(N,X)).
R=sieve(N,[H|T]) :- sieve_if_0(mod(H1,N1),N2,H2,T,R), cp(H,H1,H2), cp(N,N1,N2).
sieve_if_0(n(M),N,H,T,R) :- sieve_if_1(gt(mul(N1,N2),H1),N3,H2,T,R), del(M), cp(N,N1,NM), cp(NM,N2,N3), cp(H,H1,H2).
sieve_if_0([]  ,N,H,T,R) :- R=sieve(N,T), del(H).
sieve_if_1(n([]),N,H,T,R) :- R=prime(H,sieve(N,T)).
sieve_if_1([]   ,N,H,T,R) :- R=[H|sieve(N,T)].

% max
R=max(n(X),n(Y)) :- R=n(max(X,Y)).
R=max([],n(Y)) :- R=Y.
R=max(n(X),[]) :- R=X.

% min
R=min(n(X),n(Y)) :- R=n(min(X,Y)).
R=min([],n(Y)) :- R=[], del(Y).
R=min(n(X),[]) :- R=[], del(X).


/* ==================================== */
/* ユーザプログラム */
/* ==================================== */

/*
r = max(gen(5),gen(8)).
*/

r = ret_list(eratosthenes(gen(100))).

/*
r = primefactor(gen(120)).
*/
/*
s = ret(gcd(gen(24),gen(20))).
t = ret(gcd(gen(12),gen(9))).
r = ret(gcd(gen(27),gen(36))).
*/
/*
% if (X+Y > Z) X*Y*Z else X+Y+Z
if_0_0(X,Y,Z,R) :- if_0_1(gt(add(X1,Y1),Z1),X2,Y2,Z2,R), cp(X,X1,X2), cp(Y,Y1,Y2), cp(Z,Z1,Z2).
if_0_1(n([]),X,Y,Z,R) :- R=mul(mul(X,Y),Z).
if_0_1([],   X,Y,Z,R) :- R=add(add(X,Y),Z).
r = if_0_0(gen(3), gen(2), gen(4)).
*/
/*
A = gen(2).
B = gen(1).
C = gen(3).
D = gen(1).
cp(A, A1, A2).
cp(B, B1, B2).
S = add(A1,B1).
T = sub(C,D).
U = mul(S,T).
V = div(U,A2).
r = mul(V,B2).
*/

/* a(X) :- X>10 | b(X). */
/* a(X) :- cp(X,X1,X2), a_guard('>'(X1,10),X2). */
/* a_guard(true,X) :- b(X). */
/* a_guard(false,X) :- ???? ここで何食わぬ顔でa(X)に戻ると無限ループ */

/* ガードを使う場合に比べて実用上の表現力が落ちるのは何が原因？ */
/*  -> 1.ガードによって本質的でない表現力を得ている。言語の問題。 */
/*  -> 2.上の????に"チェック済み"フラグがたたないのが悪い。実装の問題。 */
