# cps変換
# R = cps(E, C)
# E:変換したい式, C:式の継続, R:変換後のCPS

# 元の式表現
# if   = [if, 式, T式, E式]
# fix  = [fix, [[関数名1, 引数リスト, 式], [関数名2, , ], ], 式]
# 演算 = [演算子, 式, 式]
# 比較 = [演算子, 式, 式]
# call = [app, 関数名, 引数1, 引数2, ...]

# cps表現
# fix  = [fix, [[関数名1, 引数リスト, 式], ...], 継続]
# app  = [app, 関数名, 引数リスト]
# 演算 = [演算子, 引数リスト, 結果格納先, 継続]
# 分岐 = [演算子, 引数リスト, [], [継続,継続]]

# 名前のスコープに関する解決(closure変換)を一切していないので
# 自分で管理する必要がある
# できればunaryを拾って自動で管理させたい
#   膜にスコープに関する情報を入れるとbindが難しくなりそうな…
#   スコープとつながるのは変換前変数膜
# スコープからは unary=>膜 の形で引ければよい
# 最初のCSP変換の時点ではスコープを気にせずに変換してしまえばいいのか？
# letは自分の値を入れる変数を指定する
# 変換元式の親子関係からletの範囲にあわせてスコープを管理
# 元々はalistをコピーして渡すことでスコープの範囲を管理していた

# 局所名を生成できるようにするには変数名を膜とすべき
# 局所名は直接に膜を使い, 名前=>実体 で辞書は引かない
# scope(親,{参照},[entry(x,X),entry(y,Y),...])
# エントリーを見つけるためには, scope(親,{参照,+X},find(p,[...],X)) みたいにして
# 末尾まで行ったら
# R=find(p,[],X), scope(親,{+X,$p},E), scope(先祖,{+親,$q},E) :-
#     R=[], scope(親,,), scope(先祖,{+X,$q},find(p,E,X)).
# でどんどん遡っていく ルートまで行ったらnotfound
# スコープに変数名を追加するには単にlistのappend

# 変数名はある膜へのリンク
# {+X1,+X2,+X3}, lambda(X1, (...X2...X3...)) で X1の値が決まると
# {+X1,+X2,+X3}, R=bind(lambda(X1, (...X2...X3...)), V), {+V,...$v...} となる
# この時X1の指している先の膜の中にある参照を全部Vの先の膜に移し変えればよい
# {+X2,+X3,...$v...}, R=(...X2...X3...) となる
R=bind(lambda(X, L), V), {+X,$x}, {+V,$v} :- R=L, {$x,$v}.

# 変数,定数
#   変数や定数ならそれ以降の処理で値を使う部分を埋めてやるだけでよい
R=cps(V, C), {+V,$v} :- R=bind(C,V), {+V,$v}.

# if文
#   まず条件を計算し,その結果を(というか結果の所在を)本体に渡す
#   本体では合流のための関数jを定義し,条件の結果で分岐する
#   分岐先は各々変換し,最後に合流の関数jを分岐の結果を渡して呼ぶ
#   jは渡された値をif文全体の継続に渡す
R=cps([if, Cond, True, Else], C) :-
  R=cps(Cond, lambda(X1, [fixs, [[J1, [V1], bind(C,V2)]], [neq, [X2, false], [], [T, E]]])),
  T=cps(True, lambda(Y1, [app, J2, [Y2]])),
  E=cps(Else, lambda(Z1, [app, J3, [Z2]])),
  {+X1,+X2}, {+V1,+V2}, {+J1,+J2,+J3}, {+Y1,+Y2}, {+Z1,+Z2}.

# fix関数定義
#   実際の関数定義をcps_fbindで変換し,その継続に本文を変換して渡す
#   cps_fbindは関数名はそのまま,[k|P]は関数呼び出しの継続を受け取る引数を増やし,
#   本体の変換後に呼び出しの継続kに関数の結果を渡してreturnする
R=cps([fix, B, E], C) :- R=[fix, cps_fbind(B), cps(E, C)].
R=cps_fbind([]) :- R=[].
R=cps_fbind([[F, P ,E]|T]) :-
  R=[[F, [K1 | P], cps(E, lambda(X1, [app, K2, [X2]]))]|cps_fbind(T)],
  {+K1,+K2}, {+X1,+X2}.

# primitive演算
#   XとYを変換し,一時変数p,qに入れ,計算結果を一時変数rに入れる
#   後は継続にこの式の結果がrに入っていると教える
R=cps(['+', X, Y, Z |L], C) :- R=cps(['+', ['+', X, Y], Z |L], C).
R=cps(['*', X, Y, Z |L], C) :- R=cps(['*', ['*', X, Y], Z |L], C).
R=cps(['+', X, Y], C) :- R=cps_primitive('+', X, Y, C).
R=cps(['*', X, Y], C) :- R=cps_primitive('*', X, Y, C).
R=cps_primitive(F, X, Y, C) :-
  R=cps(X, lambda(P1, cps(Y, lambda(Q1, [F, [P2, Q2], R1, bind(C,R2)])))),
  {+P1,+P2}, {+Q1,+Q2}, {+R1,+R2}.

# primitive比較
#   if文とほぼ同じだが,式自体の値としていきなりtrue/falseを継続に渡す
R=cps([eq, X, Y], C) :-
  R=cps(X, lambda(P1, cps(Y, lambda(Q1, E)))),
  E=[fix, [[J1, [X1], bind(C,X2)]], [eq, [P2, Q2], [], [[app, J2, [true]], [app, J3, [false]]]]],
  {+P1,+P2}, {+Q1,+Q2}, {+J1,+J2,+J3}, {+X1,+X2}.

# 関数呼び出し
#   引数Aはcps_listで変換, vsは引数いっぱい, fをcps変換した結果(の格納場所)がxに入り,それをappで呼び出す
#   継続のkは関数の戻り値を呼び出し全体の継続に渡している
R=cps([app, F | A], C) :-
  R=cps_args(A, M, cps(F, lambda(X1, [fixs, [[K1, [R1], bind(C,R2)]], [app, X2, [K2|M]]]))),
  {+X1,+X2}, {+K1,+K2}, {+R1,+R2}.
R=cps_args([], A, C) :- R=C, A=[].
R=cps_args([H|T], A, C) :- R=cps(H, lambda(X1, cps_args(T, M, C))), A=[X2|M], {+X1,+X2}.

# samples

# r = cps([app, {f}, ['+',X1,{y}],X2,{z}], done), {+X1,+X2,x}.

# r = cps([fix, [[{f}, [X1], [app, {g}, ['+', X2, _1]]]], []], done), {+X1,+X2,x}, {+_1,1}.

# r = cps([fix, [[{f}, [A1,X1,B1,Y1], ['+', ['*', A2, X2], ['*', B2, Y2]]]], []], done),
# {+A1,+A2}, {+X1,+X2}, {+B1,+B2}, {+Y1,+Y2}.

# r = cps([fix, [[{pitfall}, [A1,B1,C1,D1,E1,F1,G1,H1], ['+', [if, A2, B2, C2], D2, E2, F2, G2, H2]]], []], done),
# {a,+A1,+A2}, {b,+B1,+B2}, {c,+C1,+C2}, {d,+D1,+D2}, {e,+E1,+E2}, {f,+F1,+F2}, {g,+G1,+G2}, {h,+H1,+H2}.

r = cps([fix, [[{f}, [X1], ['+', [app, {g}, X2], [app, {h}, X3]]]], []], done), {x,+X1,+X2,+X3}.
