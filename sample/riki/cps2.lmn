% cps変換
% http://www.is.s.u-tokyo.ac.jp/vu/jugyo/processor/process/soft/compilerresume/ を参照

% R = cps(E, C)
% E:変換したい式, C:式の継続, R:変換後のCPS

% 変換前
%  (fix ((f (a b) expr) (g (a b) expr) ...) expr)

% 変換後
%  primitive_cmp: [primitive_cmp, op, [args...], [trueexpr, falseexpr]]
%  primitive_op : [primitive_op, op, [args...], result, next]
%  fix          : [fix, [[funcname, [args...], expr], ...], next]
%  fixs         : [fixs, [[funcname, [args...], expr], ...], next] //一度しか呼ばれない関数を作る
%  app          : [app, func, [args...]]
%  apps         : [apps, func, [args...]] //一度しか呼ばれない関数を呼ぶ


%-------------
% ここからメインのCPS変換
%

% 変数のcps変換
%   変数ならそれ以降の処理でその値を使う部分を埋めてやるだけでよい
%   Cは空欄を待ち受けるlambda式になっているはず
R=cps_switched(var, {$v}, C) :- R=bind(C, {$v}).

% 定数のcps変換
%   定数でも変数の場合と同様にその値で空欄を埋めてやる
R=cps_switched(int, $int, C) :- int($int) | R=bind(C, $int).

% if文のcps変換
%   まず条件を計算し,その結果を入れた場所(というか結果の所在を)本体に渡す
%   本体では合流のための関数jを定義し,条件の結果で分岐する
%   分岐先は各々変換し,最後に合流の関数jを分岐の結果を渡して呼ぶ
%   jは渡された値をif文全体の継続に渡す
R=cps_switched(if, [if, Cond, True, Else], C) :-
  R=cps(Cond, lambda(X1, [fixs, [[J1, [V1], bind(C, V2)]], [primitive_cmp, '=', [X2, true], [T, E]]])),
  T=cps(True, lambda(Y1, [apps, J2, [Y2]])),
  E=cps(Else, lambda(Z1, [apps, J3, [Z2]])),
  {+X1,+X2}, {+V1,+V2}, {+J1,+J2,+J3}, {+Y1,+Y2}, {+Z1,+Z2}.

% fix関数定義のcps変換
%   実際の関数定義をcps_fbindで変換し,その継続に本文を変換して渡す
%   cps_fbindは関数名はそのまま,[k|P]は関数呼び出しの継続を受け取る引数を増やし,
%   本体の変換後に呼び出しの継続kに関数の結果を渡してreturnする
R=cps_switched(fix, [fix, B, E], C) :- R=[fix, cps_fbind(B), cps(E, C)].
R=cps_fbind([]) :- R=[].
R=cps_fbind([[F, P ,E]|T]) :-
  R=[[F, [K1 | P], cps(E, lambda(X1, [app, K2, [X2]]))]|cps_fbind(T)],
  {+K1,+K2}, {+X1,+X2}.

% primitive演算
%   XとYを変換し,一時変数p,qに入れ,計算結果を一時変数rに入れる
%   後は継続にこの式の結果がrに入っていると教える
R=cps_switched(primitive_op, [$op, X, Y, Z |L], C) :- unary($op) | R=cps_switched(primitive_op, [$op, [$op, X, Y], Z |L], C).
R=cps_switched(primitive_op, [Op, X, Y], C)
  :- R=cps(X, lambda(P1, cps(Y, lambda(Q1, [primitive_op, Op, [P2, Q2], R1, bind(C,R2)])))),
     {+P1,+P2}, {+Q1,+Q2}, {+R1,+R2}.

% primitive比較
%   if文とほぼ同じだが,式自体の値としていきなりtrue/falseを継続に渡す TODO:実行系に==と!=両方用意させるのは変？
R=cps_switched(primitive_cmp, [$op, X, Y], C) :- unary($op)
  | R=cps(X, lambda(P1, cps(Y, lambda(Q1, E)))),
    E=[fixs, [[J1, [X1], bind(C,X2)]], [primitive_cmp, $op, [P2, Q2], [[apps, J2, [true]], [apps, J3, [false]]]]],
    {+P1,+P2}, {+Q1,+Q2}, {+J1,+J2,+J3}, {+X1,+X2}.

% 関数呼び出し
%   引数はcps_argsで変換, 関数部分をcps変換した結果(の格納場所)をappで呼び出す 戻る場合kを呼び出す
%   継続のkは関数の戻り値を呼び出し全体の継続に渡している
R=cps_switched(apply, [Func | Args], Cont) :-
  R=cps_args(Args, A, cps(Func, lambda(F1, [fixs, [[K1, [R1], bind(Cont,R2)]], [app, F2, [K2|A]]]))),
  {+F1,+F2}, {+K1,+K2}, {+R1,+R2}.
R=cps_args([], ArgRes, Cont) :- R=Cont, ArgRes=[].
R=cps_args([H|T], ArgRes, Cont) :- R=cps(H, lambda(X1, cps_args(T, ArgPipe, Cont))), ArgRes=[X2|ArgPipe], {+X1,+X2}.

% begin文
%   begin文は複数の式を実行する構文だが, 実際は任意の引数をとって,単に最後の引数を返す関数と同じ
%   でも実装上は重そうなので間に値を捨てる式を挟んだ式にする
R=cps_switched(begin,[begin|L],C) :- R=cps_multiexpr(L,C).
R=cps_multiexpr([H],C) :- R=cps(H,C).
R=cps_multiexpr([H1,H2|T],C) :- R=cps(H1,lambda_drop(cps_multiexpr([H2|T],C))).

%------------------
% ここからlambda式への引数適応
%

% 一時変数として空欄になっている部分の埋め込み
%  何らかの変数名を埋め込む場合,膜のマージになる
R=bind(lambda({$hole}, Lambda), {$value}) :- R=Lambda, {$hole,$value}.
%  即値を埋め込む場合,空欄に即値をコピーする
R=bind(lambda({$hole}, Lambda), $int) :- int($int) | R=Lambda, copy_each($int,{$hole}).
% 値を捨てる場合
R=bind(lambda_drop(Lambda), {$value}) :- R=Lambda, {$value}.

% {+X,+Y,+Z,...} のような自由リンクそれぞれに対して整数アトムをつなぐ
copy_each($int,{+X,$p}) :- int($int) | copy_each($int,{$p}), X=$int.
copy_each($int,{$p[]}) :- int($int) | .

%------------------
% ここからeta reduction (未完成)
%

% 1. [fixs, [... [F, [A1], [apps, G, [A2]]] ...], C] の形を見つける
% 2. Cの中のF呼び出しをGに全部置き換える
%    Fは一意な名前をつけたものなので定義が隠される心配はない
%    リダクションした結果が再び冗長である可能性があるため,内側の関数のリダクションを先に終わらせておく必要がある
% いきなり1の構造に飛びつけないためマッチする場合/しない場合を書く必要がある
% マッチしない場合を書くのは非常に面倒くさい

% fixsなら引数内のチェックをする
R=eta_reduction([fixs,F,C]) :- R=[fixs,F1,eta_reduction_fixs(F,eta_reduction(C),F1)].
% 以下はチェック不要
R=eta_reduction([fix,F,C]) :- R=[fix,F,eta_reduction(C)].
R=eta_reduction([premitive_cmp,O,A,V,[T,F]]) :- R=[premitive_cmp,O,A,V,[eta_reduction(T),eta_reduction(F)]].
R=eta_reduction([premitive_op,O,A,V,C]) :- R=[premitive_op,O,A,V,eta_reduction(C)].
R=eta_reduction([app,F,A]) :- R=[app,F,A].
R=eta_reduction([apps,F,A]) :- R=[apps,F,A].

% 各関数定義が1reductionの対象になるか
R=eta_reduction_fixs([],C,FOut) :- R=C, FOut=[].
R=eta_reduction_fixs([[F,[A],E]|T],C,FOut)
  :- FOut=connecter(FChecking,FPipe), R=eta_reduction_fixs(T,eta_reduction_check(or(is(app,E,E1),is(apps,E1,E2)),[F,[A],E2],C,FChecking),FPipe).
R=eta_reduction_fixs([[F,[A,B|Rest],E]|T],C,FOut) :- FOut=[[F,[A,B|Rest],E]|FPipe], R=eta_reduction_fixs(T,C,FPipe).

% 1引数の関数定義の中身がappsかどうか
R=eta_reduction_check(true,F,C,FOut) :- R=eta_reduction_fixsapp(F,C,FOut).
R=eta_reduction_check(false,F,C,FOut) :- R=C, FOut=+F. //FOutで待っているのはconnecterなので注意

% appsの引数を確認 -> マッチできればreduction開始 関数定義は消す 
R=eta_reduction_fixsapps([{$f},[A],[apps,{$g},[B]]],C,FOut), {+A,+B,$p} :- R=eta_do_reduction({$f},{$g},C), {$p}, FOut='+'.
R=eta_reduction_fixsapps([F,[{$a}],[apps,G,[{$b}]]],C,FOut) :- R=C, FOut=+[F,[{$a}],[apps,G,[{$b}]]].
R=eta_reduction_fixsapps([F,[A],[apps,G,[B1,B2|Rest]]],C,FOut) :- R=C, FOut=+[F,[A],[apps,G,[B1,B2|Rest]]].

% 間接的な関数呼び出しを直接的に変更する
% R=eta_do_reduction({$f},{$g})
% R=eta_do_reduction([fixs,F,C]) :- R=[fixs,F1,eta_reduction_fixs(F,eta_reduction(C),F1)].
% R=eta_do_reduction([fix,F,C]) :- R=[fix,F,eta_reduction(C)].
% R=eta_do_reduction([premitive_cmp,O,A,V,[T,F]]) :- R=[premitive_cmp,O,A,V,[eta_reduction(T),eta_reduction(F)]].
% R=eta_do_reduction([premitive_op,O,A,V,C]) :- R=[premitive_op,O,A,V,eta_reduction(C)].
% R=eta_do_reduction([app,F,A]) :- R=[app,F,A].
% R=eta_do_reduction([apps,F,A]) :- R=[apps,F,A].

% connecter +_1が帰ってきたら消す +_2が帰ってきたらconsに
R=connecter('+',T) :- R=T.
R=connecter(+H,T) :- R=[H|T].

%------------------
% ここからシンボルの拾い上げ
%

% [{id(x)},{id(y)},{id(z)},...] で管理される(unary->膜)のマップに必要なら追加して,膜へのリンクを返す
Ref=get_ref([],$p,IDOut)              :- unary($p) | IDOut=[{id($p),+Ref,+Tag}], Tag=$p.
Ref=get_ref([{id($p),$q}|T],$r,IDOut) :- $p=$r     | IDOut=[{id($p),$q,+Ref}|T].
Ref=get_ref([{id($p),$q}|T],$r,IDOut) :- $p\=$r    | IDOut=[{id($p),$q     }|IDPipe], Ref=get_ref(T,$r,IDPipe).

% ツリー内で使っているidを探してきて,膜へのリンクで管理
pickup_unary(Mem,MemOut,[],ProgOut) :- Mem=MemOut, ProgOut=[].
pickup_unary(Mem,MemOut,+$p,ProgOut) :- unary($p) | ProgOut=get_ref(Mem,$p,MemOut).
pickup_unary(Mem,MemOut,$p,ProgOut) :- unary($p) | ProgOut=$p, MemOut=Mem.
pickup_unary(Mem,MemOut,[H|T],ProgOut)
  :- ProgOut=[pickup_unary(Mem,MemPipe,H)|pickup_unary(MemPipe,MemOut,T)].

%---------------------
% ここからcps変換のモード選択
%

% cps変換の分岐
R=cps(ProgIn, Cont) :- R=cps_switched(Mode, select_mode(ProgIn,Mode), Cont).
select_mode(ProgIn,Mode,ProgOut), select_mode_table(T) :- select_mode(ProgIn,T,select_mode_table,Mode,ProgOut).
% 最初の命令の先頭のunaryによって処理が振り分けられるもの
%  unaryがテーブルの要素とマッチしたら対応するモードを使う
select_mode([$prog_op|T],[unary_entry($table_op,$table_mode)|V],TableOut,Mode,ProgOut)
  :- $prog_op=$table_op, unary($table_mode)
  | Mode=$table_mode, ProgOut=[$prog_op|T], TableOut=[unary_entry($table_op,$table_mode)|V].
%  unaryがマッチしなかったら次
select_mode([$prog_op|T],[unary_entry($table_op,$table_mode)|V],TableOut,Mode,ProgOut)
  :- $prog_op\=$table_op, unary($table_mode)
  | select_mode([$prog_op|T],V,TablePipe,Mode,ProgOut), TableOut=[unary_entry($table_op,$table_mode)|TablePipe].
%  unary以外なら...って書きたいが書けないのですべての場合を列挙
%   consアトムの場合 関数呼び出しによって求まる関数の呼び出し
select_mode([[X|Y]|T],TableIn,TableOut,Mode,ProgOut) :- TableOut=TableIn, ProgOut=[[X|Y]|T], Mode=apply.
%   膜の場合 ユーザ定義シンボルを関数とする関数呼び出し
select_mode([{$p}|T],TableIn,TableOut,Mode,ProgOut) :- TableOut=TableIn, ProgOut=[{$p}|T], Mode=apply.
%  何ともマッチしなかったらエラー 停止
% いきなり名前に当たったら変数
select_mode({$p},TableIn,TableOut,Mode,ProgOut) :- TableOut=TableIn, ProgOut={$p}, Mode=var.
% いきなり整数に当たったら変数
select_mode($int,TableIn,TableOut,Mode,ProgOut) :- int($int) | TableOut=TableIn, ProgOut=$int, Mode=int.
% いきなり[]に当たるはずはない

select_mode_table([unary_entry(if,if),
                  unary_entry(fix,fix),
                  unary_entry(begin,begin),
                  %unary_entry(define,define),
		  unary_entry('+',primitive_op),
		  unary_entry('*',primitive_op),
		  unary_entry('-',primitive_op),
		  unary_entry('/',primitive_op),
		  unary_entry('>',primitive_cmp),
		  unary_entry('<',primitive_cmp),
		  unary_entry('>=',primitive_cmp),
		  unary_entry('<=',primitive_cmp),
		  unary_entry('=',primitive_cmp),
		  unary_entry('!=',primitive_cmp)]).

%--------------------
% ここから複数の式とdefineへの対応
%

% TODO:defineは関数以外の場合もあるはず
% (define x 3) は (lambda(x)続き)(3) に等しい

% 非defineブロックは1つのbegin文に等しい
R=cps_normal_block(L,C) :- R=cps([begin|L],C).

% defineブロックを1つのfix文にする
R=cps_define_block(L,C) :- R=[fix, cps_fbind(defines_to_fbind(L)), C].
R=defines_to_fbind([[define,[F|A],E]|U]) :- R=[[F,A,E]|defines_to_fbind(U)].
R=defines_to_fbind([]) :- R=[].

% defineブロックか非defineブロックかの分岐
R=cps_blocks([block(true,L)|T],C)  :- R=cps_define_block(L,cps_blocks(T,C)).
R=cps_blocks([block(false,L)|T],C) :- R=cps_normal_block(L,cps_blocks(T,C)).
R=cps_blocks([],C) :- R=C.

% R=is($p,ProgIn,ProgOut) ProgInが$p命令の文であるかどうかを判定
% $pで始まっていたらtrueを返し, それ以外ならfalseを返す 止まる場合もありそうだが気にしない
R=is($p,[$q|T],ProgOut) :- $p=$q  | R=true, ProgOut=[$q|T].
R=is($p,[$q|T],ProgOut) :- $p\=$q | R=false, ProgOut=[$q|T].
R=is($p,[{$q}|T],ProgOut) :- unary($p) | R=false, ProgOut=[{$q}|T].
R=is($p,[[H|T]|U],ProgOut) :- unary($p) | R=false, ProgOut=[[H|T]|U].

% or 途中で放り出すわけにもいかないので失敗待ち
R=or(false,X) :- R=X.
R=or(X,false) :- R=X.

% defineブロックと非defineブロックに分ける block(true,[...])ならdefine, block(false,[...])なら非define
R=split_define([H|T]) :- R=splitting_define(is(define,H,H1),[H1|Tail],Tail,T).
R=splitting_define(Mode,BlockH,BlockT,[H|T]) :- R=splitting_define(Mode,is(define,H,H1),BlockH,BlockT,[H1|T]).
R=splitting_define(Mode,BlockH,BlockT,[])    :- R=[block(Mode,BlockH)], BlockT=[].
R=splitting_define($mode,$check,BlockH,BlockT,[H|T]) :- $mode=$check  | BlockT=[H|BlockT1], R=splitting_define($mode,BlockH,BlockT1,T).
R=splitting_define($mode,$check,BlockH,BlockT,[H|T]) :- $mode\=$check | BlockT=[], R=[block($mode,BlockH)|splitting_define($check,[H|Tail],Tail,T)].

% 大元の呼び出し TODO:ここの右端はシステムに値を返す継続になるはず
% R=cps(ProgIn) :- pickup_unary([],ids,ProgIn,ProgOut), R=eta_reduction(cps_blocks(split_define(ProgOut), lambda_drop([stop]))).
R=cps(ProgIn) :- pickup_unary([],ids,ProgIn,ProgOut), R=cps_blocks(split_define(ProgOut), lambda_drop([stop])).


%---------------------------
% ユーザプログラム
%

result = cps(X).

% [[+f, ['+',+x,+y],+x,+z]] = X.
% [[fix, [[+f, [+x], [+g, ['+', +x, 1]]]], [+f, 3]]] = X.
% [[fix, [[+f, [+a,+x,+b,+y], ['+', ['*', +a, +x], ['*', +b, +y]]]], [+f,1,2,3,4]]] = X.
% [[fix, [[+pitfall, [+a,+b,+c,+d,+e,+f,+g,+h], ['+', [if, +a, +b, +c], +d, +e, +f, +g, +h]]], [+pitfall, 1,2,3,4,5,6,7,8]]] = X.
% [[fix, [[+f, [+x], ['+', [+g, +x], [+h, +x]]]], [+f,3]]] = X.

% [[define, [+f, +x],
%    ['+', +x, 1]],
%  [define, [+g, +x],
%    ['*', +x, +x]]]   = X.

[[define, [+fact, +n, +p],
   [if, ['=', +n, 0],
        +p,
        [+fact, ['-', +n, 1], ['*', +p, +n]]]]] = X.
