/*
NAME
	ferryman
	
AUTHOR
	Kohei HIROTO

HISTORY
	2006/07/13
*/

/*
問題のルール
川岸にferryman, wolf, goat, cabbageがいる。
ferrymanが操れるボートを使って全てを向こう岸に渡したい。
ボートはferrymanと最大一つのものを運ぶことができる。
ferrymanがいないところは、wolfがgoatを食べてしまう。
ferrymanがいないところは、goatがcabbageを食べてしまう。
*/

/*
考え方
０．初期状態
１．ハッシュコードを計算する
２．終了判定
３．食べられてしまうか、同一状態を過去に通過したか、もう打つ手がないかの判定をして、合致するならアトムｘを追加
４．ｘがあるならバックトラック
５．新たな状態の生成→１に戻る
*/

/*
状態数は2^4=16 4はferryman, wolf, goat, cabbageの種類の数から
状態を示すハッシュコードを
1 * bit(ferryman) + 2 * bit(wolf) + 4 * bit(goat) + 8 * bit(cabbage) とする。
これで各状態に対応する固有の０から１５の整数値が決まる。bit(x)はxがaにあるとき０、bにあるとき1
ハッシュコードを比較することで各状態の同一性の判定ができる。
ちなみに初期状態が０、終了状態が１５である。
*/

/*
mnumは次に運ぶべきものをあらわす。
0:wolf
1:goat
2:cabbage
3:nothing
4:もうその状態からどうやっても手詰まりになることを示す
*/

/* アトムxは、バックトラックが必要であることを示す。 */

{	
	{
		cd = 0. // 探索の現在の深さ
		// 初期状態
		{
			depth = 0. // 探索の深さ
			mnum = 0. // 次に何を運ぶか
			a = { f, w, c, g }. // 川のこちら側 f: ferryman, w: wolf, g: goat, c: cabbage
			b = { }. // 川のあちら側
			h = { 0 }. // ハッシュコードの計算に使う。0は未計算を示す。計算が終わると消える。
			state = -1. // この状態固有のハッシュコード
			
			// 終了条件。終了する場合mnumを消して一段階進めるルールが適用できないようにする。
			isFinished@@
			b = { f, w, g, c }, mnum = N :- int(N) | end, b = { f, w, g, c }.
			
			// 食べられてしまう条件。合致するときはバックトラックが必要。
			a = { w, g, $p[] } :- \+($p = (f, $pp)) | x.
			a = { g, c, $p[] } :- \+($p = (f, $pp)) | x.
			b = { w, g, $p[] } :- \+($p = (f, $pp)) | x.
			b = { g, c, $p[] } :- \+($p = (f, $pp)) | x.
			
			/* ハッシュコードの計算 */
			// はじめにbの中身をhの中にコピーする
			startCalhash@@
			state = N, h = { 0 }, b = { $b[] } 
				:- int(N) | state = 0, h = { $b[] }, b = { $b[] }.
			state = N, h = { f, $c } 
				:- int(N) | state = N + 1, h = { $c }.
			state = N, h = { w, $c } 
				:- int(N) | state = N + 2, h = { $c }.
			state = N, h = { g, $c } 
				:- int(N) | state = N + 4, h = { $c }.
			state = N, h = { c, $c } 
				:- int(N) | state = N + 8, h = { $c }.
			// 計算が終わったら膜を消す
			deleteClahashMemb@@
			h = { } :- .
		}.
		
		// 今までに同じ状態を通過してこなかったか調べる。合致するときはバックトラックが必要。
		heckEqualState@@
		cd = L, { depth = M, state = N, $p, @p }/, { state = P, $q, @q }/
			:- L = M, N = P | cd = L, { depth = M, $p, @p, x }, { state = P, $q, @q }.
			
		// もうこの状態から打つ手がないかの判定。合致するときはバックトラックが必要。
		cd = L, { depth = M, mnum = N, $p, @p }/
			:- L = M, N >= 4 | cd = L, { depth = M, $p, @p, x }.
		
		// 膜内にxがあったらバックトラックをする
		backTrack@@
		cd = L, { depth = M, x, $p[], @p }
			:- L = M, | cd = L - 1.
	}.
	
	/* 状態を一段階進める */
	// aにfがいて、運ぶもの＝wのとき
	{cd = L, { depth = M, mnum = N, a = {f, w, $a[]}, b = { $b[] }, $p[], @p }, $t, @t}/  
		:- L = M, N = 0 
		| {cd = L + 1, { depth = M, mnum = N + 1, a = {f, w, $a[]}, b = { $b[] }, $p[], @p }, 
			{ depth = M + 1, mnum = 0, h = { 0 }, a = { $a[] }, b = {f, w, $b[] }, $p[], @p }, $t, @t}.
	// aにfがいて、運ぶもの＝wのとき。しかし実際にはaにwがないとき。
	// b内にwがあるという条件は、a内にwがないということと同じである。
	{cd = L, { depth = M, mnum = N, a = {f, $a[]}, b = { w, $b[] }, $p[], @p }, $t, @t}/ 
		:- L = M, N = 0 
		| {cd = L, { depth = M, mnum = N + 1, a = {f, $a[]}, b = { w, $b[] }, $p[], @p }, $t, @t}.
	
	// aにfがいて、運ぶもの＝gのとき
	{cd = L, { depth = M, mnum = N, a = {f, g, $a[]}, b = { $b[] }, $p[], @p }, $t, @t}/ 
		:- L = M, N = 1 
		| {cd = L + 1, { depth = M, mnum = N + 1, a = {f, g, $a[]}, b = { $b[] }, $p[],@p }, 
			{ depth = M + 1, mnum = 0, h = { 0 }, a = { $a[] }, b = {f, g, $b[] }, $p[], @p }, $t, @t}.
	// aにfがいて、運ぶもの＝gのとき。しかし実際にはaにgがないとき。
	{cd = L, { depth = M, mnum = N, a = {f, $a[]}, b = { g, $b[] }, $p[], @p }, $t, @t}/ 
		:- L = M, N = 1 
		| {cd = L, { depth = M, mnum = N + 1, a = {f, $a[]}, b = { g, $b[] }, $p[], @p }, $t, @t}.
	
	// aにfがいて、運ぶもの＝cのとき
	{ cd = L, { depth = M, mnum = N, a = {f, c, $a[]}, b = { $b[] }, $p[], @p }, $t, @t}/ 
		:- L = M, N = 2 
		| {cd = L + 1, { depth = M, mnum = N + 1, a = {f, c, $a[]}, b = { $b[] }, $p[], @p }, 
			{ depth = M + 1, mnum = 0, h = { 0 }, a = { $a[] }, b = { f, c, $b[] }, $p[], @p }, $t, @t}.
	// aにfがいて、運ぶもの＝cのとき。しかし実際にはaにcがないとき。
	{cd = L, { depth = M, mnum = N, a = {$a[]}, b = { c, $b[] }, $p[], @p }, $t, @t}/ 
		:- L = M, N = 2 
		| {cd = L, { depth = M, mnum = N + 1, a = {$a[]}, b = { c, $b[] }, $p[], @p }, $t, @t}.
	
	// aにfがいて、運ぶもの＝nothingのとき
	{cd = L, { depth = M, mnum = N, a = {f, $a[]}, b = { $b[] }, $p[], @p }, $t, @t}/ 
		:- L = M, N = 3 
		| {cd = L + 1, { depth = M, mnum = N + 1, a = {f, $a[]}, b = { $b[] }, $p[], @p }, 
			{ depth = M + 1, mnum = 0, h = { 0 }, a = { $a[] }, b = {f,  $b[] }, $p[], @p }, $t, @t}.
	
	// bにfがいて、運ぶもの＝wのとき
	{ cd = L, { depth = M, mnum = N, a = { $a[] }, b = { f, w, $b[] }, $p[], @p }, $t, @t}/ 
		:- L = M, N = 0 
		| {cd = L + 1, { depth = M, mnum = N + 1, a = { $a[] }, b = { f, w, $b[] }, $p[], @p }, 
			{ depth = M + 1, mnum = 0, h = { 0 }, a = { f, w, $a[] }, b = { $b[] }, $p[], @p }, $t, @t}.
	// bにfがいて、運ぶもの＝wのとき。しかし実際にはbにwがないとき。
	// a内にwがあるという条件は、b内にwがないということと同じである。
	{cd = L, { depth = M, mnum = N, a = {w, $a[]}, b = { f, $b[] }, $p[], @p }, $t, @t}/ 
		:- L = M, N = 0 
		| {cd = L, { depth = M, mnum = N + 1, a = {w, $a[]}, b = { f, $b[] }, $p[], @p }, $t, @t}.
	
	// bにfがいて、運ぶもの＝gのとき
	{cd = L, { depth = M, mnum = N, a = { $a[] }, b = { f, g, $b[] }, $p[], @p }, $t, @t}/ 
		:- L = M, N = 1 
		| {cd = L + 1, { depth = M, mnum = N + 1, a = { $a[] }, b = { f, g, $b[] }, $p[], @p }, 
			{ depth = M + 1, mnum = 0, h = { 0 }, a = { f, g, $a[] }, b = { $b[] }, $p[], @p }, $t, @t}.
	// bにfがいて、運ぶもの＝gのとき。しかし実際にはbにgがないとき。
	// a内にgがあるという条件は、b内にgがないということと同じである。
	{cd = L, { depth = M, mnum = N, a = {g, $a[]}, b = { f, $b[] }, $p[], @p }, $t, @t}/ 
		:- L = M, N = 1 
		| {cd = L, { depth = M, mnum = N + 1, a = {g, $a[]}, b = { f, $b[] }, $p[], @p }, $t, @t}.
	
	// bにfがいて、運ぶもの＝cのとき
	{cd = L, { depth = M, mnum = N, a = { $a[] }, b = { f, c, $b[] }, $p[], @p }, $t, @t}/ 
		:- L = M, N = 2 
		| {cd = L + 1, { depth = M, mnum = N + 1, a = { $a[] }, b = { f, c, $b[] }, $p[], @p }, 
			{ depth = M + 1, mnum = 0, h = { 0 }, a = { f, c, $a[] }, b = { $b[] }, $p[], @p }, $t, @t}.
	// bにfがいて、運ぶもの＝cのとき。しかし実際にはbにcがないとき。
	// a内にcがあるという条件は、b内にwがないということと同じである。
	{cd = L, { depth = M, mnum = N, a = {c, $a[]}, b = { f, $b[] }, $p[], @p }, $t, @t}/ 
		:- L = M, N = 2 
		| {cd = L, { depth = M, mnum = N + 1, a = {c, $a[]}, b = { f, $b[] }, $p[], @p }, $t, @t}.
	
	// bにfがいて、運ぶもの＝nothingのとき
	{cd = L, { depth = M, mnum = N, a = { $a[] }, b = { f, $b[] }, $p[], @p }, $t, @t}/ 
		:- L = M, N = 3 
		| {cd = L + 1, { depth = M, mnum = N + 1, a = { $a[] }, b = { f, $b[] }, $p[], @p }, 
			{ depth = M + 1, mnum = 0, h = { 0 }, a = { f, $a[] }, b = { $b[] }, $p[], @p }, $t, @t}.
}.

// 計算結果をきれいな形にする
{ { cd = N, { end, $p, @p }, $q, @q }, $t[], @t } 
	:- int(N) | ans = [N], anss = [N], { $p }, { $q }.
{ { mnum = N, $p, @p }, $q, @q }
	 :- int(N) | { $p }, { $q }.
ans = [N|L1], anss = [M|L2], { depth = D, state = S, $p, @p } 
	:- N > 0, N = M, N = D, int(S) | ans = [N - 1, { $p } | L1], anss = [M - 1, S | L2].
ans = [N|L1], anss = [M|L2], { depth = D, state = S, $p, @p } 
	:- N = 0, N = M, N = D, int(S) | ans = [{ $p } | L1], anss = [S | L2].
{} :- .

/*
このプログラムによって得られる解
depth: a | b
として
0: f w g c | 
1:     w c | f g
2:   f w c | g
3:       c | f w g
4:   f g c | w
5:       g | f w c
6:       g | w c
7:         | f g w c
*/