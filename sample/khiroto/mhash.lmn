% 膜のハッシュコードを計算する
%
% AUTHOR: Kohei HIROTO
% 
% 06/11/01

{
module(mhash).

[:/*inline_define*/	
	class MembraneHashCodeCalculator {
		static int calculate(Membrane m) {
			//System.out.println(m);
			final long MAX_VALUE = Integer.MAX_VALUE;
			long h = 3412;        // 3412は適当な初期値
			//long g = 3412;
			long f = 3412;
			
			// 子膜以外のアトムを処理する
			for (Iterator i = m.atomIterator(); i.hasNext(); ) {
				Atom a = (Atom) i.next();
				String name = a.getName();
				if (name.equals("+") || name.equals("$in") || name.equals("$out")) {
					continue;
				}
				long t = a.getFunctor().hashCode();
				//System.out.println(a +":"+ t);
				
				// このアトムのリンクを処理する
				int arity = a.getFunctor().getArity();
				for (int k = 0; k < arity; k++) {
					t *= 31;
					Link link = a.getArg(k);
					if (link.getAtom().getName().equals("$out")) { // リンク先が子膜の場合
						//System.out.println("process komaku");
						t += calculate(link.getAtom().nthAtom(0).getMem());
					} else { // リンク先が子膜ではなくアトムの場合
						int pos = link.getPos();
						//System.out.println(pos);
						// 接続先の引数番号をハッシュに関与させる
						t += (link.getAtom().getFunctor().hashCode() * (pos + 1));
					}
				}
				h += t;
				h %= MAX_VALUE;
				//g ^= t;
				f *= t;
				f %= MAX_VALUE;
			}
			
			// 子膜を処理する
			for (Iterator i = m.memIterator(); i.hasNext(); ) {
				Membrane me = (Membrane) i.next();
				long t = calculate(me);
				//System.out.println("komaku " + me +":"+ t);
				h += t;
				h %= MAX_VALUE;
				//g ^= t;
				f *= t;
				f %= MAX_VALUE;
			}
			return (int) ((f /*+ g*/ + h) % MAX_VALUE);
		}
	}
:].

H = mhash.hashCode(Memb) :- H = 
[:/*inline*/
	Atom a = me.nthAtom(0).nthAtom(0); // アトム$in
	Membrane m = (Membrane) (a.getMem());
	int hashCode = MembraneHashCodeCalculator.calculate(m);
	
	Atom result = mem.newAtom(new IntegerFunctor(hashCode));
	mem.relinkAtomArgs(result, 0, me, 1);
	a.nthAtom(1).remove();
	me.remove();
:](Memb).
}.

/*
// 膜によるグループ分けの例
hc0 = mhash.hashCode(Memb0).
hc1 = mhash.hashCode(Memb1).
hc2 = mhash.hashCode(Memb2).
hc3 = mhash.hashCode(Memb3).
hc4 = mhash.hashCode(Memb4).
hc5 = mhash.hashCode(Memb5).
hc6 = mhash.hashCode(Memb6).
hc7 = mhash.hashCode(Memb7).
hc8 = mhash.hashCode(Memb8).
hc9 = mhash.hashCode(Memb9).
hc10 = mhash.hashCode(Memb10).
hc11 = mhash.hashCode(Memb11).
hc12 = mhash.hashCode(Memb12).
hc13 = mhash.hashCode(Memb13).

Memb0 = { aaa. bbb. ccc. }.
Memb1 = {{aaa. bbb. ccc}. {}.}.
Memb2 = {{}. {ccc. aaa. bbb}.}.   // アトムの順番が変ったとき
Memb3 = {{aaa. bbb. ccc}. }.      // {}の有無
Memb4 = {{aaa. bbb.}. {ccc.}.}.
Memb5 = {{ccc.}. {aaa. bbb.}.}.
Memb6 = {{aaa. ccc.}. {bbb.}.}.
Memb7 = {{bbb. ccc.}. {aaa.}.}.
Memb8 = {{aaa.}. {bbb.}. {ccc.}.}.
Memb9 = { aaa. }.
Memb10 = {{aaa.}.}.
Memb11 = {{{aaa.}.}.}.
Memb12 = {a = {w, c}. b = {g}}.
Memb13 = {a = {w, g}. b = {c}}.
*/


// 「２つ一組が２つ」と「４つで環状」
hc1 = mhash.hashCode(Memb1).
hc2 = mhash.hashCode(Memb2).
Memb1 = { a(X, Y). a(X, Y). a(S, T). a(S, T). }.
Memb2 = { a(X, Y). a(X, T). a(S, Y). a(S, T). }.

/*
// シス･トランス異性体
hc1 = mhash.hashCode(Memb1).
hc2 = mhash.hashCode(Memb2).
Memb1 = { a(X, Y, L). a(X, T). a(S, Y). a(S, T, M). a(L). a(M). }.
Memb2 = { a(X, Y, L). a(X, T). a(S, Y, M). a(S, T). a(L). a(M). }.
*/

/*
//ferrymanの例題で使った状態を表す膜
hc1 = mhash.hashCode(Memb1).
hc2 = mhash.hashCode(Memb2).
Memb1 = {a = {f, c, g}. b = {}.}.
Memb2 = {a = {c, g}. b = {f}.}.
*/