% 膜のハッシュコードを計算するモジュール
%
% AUTHOR: Kohei HIROTO
% 
% 07/01/16

{
module(mhash).

mhash.use :- .

[:/*inline_define*/	
	import java.util.*;
	import util.*;
	
	class MembraneHashCodeCalculator {
		/* 膜のハッシュコードを返す */
		static int calculate(Membrane m) {
			return calculate(m, new HashMap<Membrane, Integer>());
		}
		
		/*
		 * 膜のハッシュコードを返す
		 * @param m ハッシュコード算出対象の膜
		 * @param m2hc mの子膜からハッシュコードへのマップ。子膜のハッシュコード算出を繰り返さないために使う。
		 */
		private static int calculate(Membrane m, Map<Membrane, Integer> m2hc) {
			//System.out.println("membrane:" + m);
			final long MAX_VALUE = Integer.MAX_VALUE;
			/*
			 * add: m内の分子のハッシュコードが加算されていく変数
			 * mult: m内の分子のハッシュコードが乗算されていく変数
			 */
			long add = 3412;        // 3412は適当な初期値
			long mult = 3412;
			
			/* 一時変数 */
			Atom a = null;
			Membrane mm = null;
			QueuedEntity q = null;
			
			/*
			 * contents:この膜内のアトムと子膜全体の集合
			 * toCalculate:現在計算中の分子内の未処理アトムまたは子膜の集合
			 * calculated:現在計算中の分子内の処理済アトムまたは子膜の集合
			 */
			Set<QueuedEntity> contents = new HashSet<QueuedEntity>(), 
								toCalculate = new HashSet<QueuedEntity>(), 
								calculated = new HashSet<QueuedEntity>();
			
			for (Iterator i = m.atomIterator(); i.hasNext(); ) {
				a = (Atom) i.next();
				if (a.getFunctor().isOutsideProxy() || a.getFunctor().isInsideProxy()) {
					continue;
				}
				contents.add(a);
			}
			
			for (Iterator i = m.memIterator(); i.hasNext(); ) {
				mm = (Membrane) i.next();
				contents.add(mm);
				m2hc.put(mm, calculate(mm, m2hc));
			}
			
			while (!contents.isEmpty()) {
				//System.out.println("uncalculated:" + contents);
				q = contents.iterator().next();
				contents.remove(q);
				
				/*
				 * mol: この分子のハッシュコードを保持する
				 * mol_add: 基本計算単位のハッシュコードが加算されていく変数
				 * mol_mult: 基本計算単位のハッシュコードが乗算されていく変数
				 * temp: 基本計算単位のハッシュコードを保持する
				 */
				 
				long mol = -1, mol_add = 0, mol_mult = 41, temp = 0;
				
				toCalculate.clear();
				calculated.clear();
				toCalculate.add(q);
					
				// 分子のハッシュコードの計算
				while (!toCalculate.isEmpty()) {
					q = toCalculate.iterator().next();
					calculated.add(q);
					toCalculate.remove(q);
					
					if (q instanceof Atom) {
						a = (Atom) q;
						temp = a.getFunctor().hashCode();
									
						// このアトムのリンクを処理する
						int arity = a.getFunctor().getArity();
						for (int k = 0; k < arity; k++) {
							temp *= 31;
							Link link = a.getArg(k);
							if (link.getAtom().getFunctor().isInsideProxy()) {
								Atom inside = link.getAtom();
								int pos = link.getPos() + 1;
								temp += (inside.getFunctor().hashCode() * pos);	
							} else if (link.getAtom().getFunctor().isOutsideProxy()) { // リンク先が子膜の場合
								/*
								 * リンク先アトムに至るまで貫いた子膜のハッシュコードと
								 * 最終的なリンク先アトムのハッシュコードと
								 * そのアトムの引数番号の組を
								 * このアトムから子膜へのリンクを表現する項とする。
								 */
								int t = 0;
								mm = link.getAtom().nthAtom(0).getMem();
								if (!calculated.contains(mm)) {
									toCalculate.add(mm);
								}
								while (link.getAtom().getFunctor().isOutsideProxy()) {
									link = link.getAtom().nthAtom(0).getArg(1);
									mm = link.getAtom().getMem();
									t += m2hc.get(mm);
									t *= 13;
								}
								
								t *= link.getAtom().getFunctor().hashCode();
								t *= link.getPos() + 1;
								temp += t;
							} else { // リンク先がプロキシ以外のアトムの場合
								Atom linked = link.getAtom();
								if (!calculated.contains(linked)) {
									toCalculate.add(linked);
								}
								int pos = link.getPos() + 1;
								// 接続先の引数番号をハッシュコードに関与させる
								temp += (linked.getFunctor().hashCode() * pos);
							}
						}
					} else {
						Membrane mt = (Membrane) q;
						final int thisMembsHC = m2hc.get(mt);
						temp = thisMembsHC;
						
						// この膜から膜の外部へのリンクを処理する
						Link link = null;
						for (Iterator i = mt.atomIteratorOfFunctor(Functor.INSIDE_PROXY); i.hasNext(); ) {
							Atom inside = (Atom) i.next();
							// この膜外部の（プロキシでない）リンク先アトムまでトレース
							int s = 0;
							link = inside.nthAtom(0).getArg(1);
							
							if (link.getAtom().getFunctor().isOutsideProxy()) { // この膜のリンク先が膜のとき
								mm = link.getAtom().nthAtom(0).getMem();
								if (!calculated.contains(mm)) {
									toCalculate.add(mm);
								}
							} else { // この膜のリンク先がアトムの場合
								a = link.getAtom();
								if (!calculated.contains(a)) {
									toCalculate.add(a);
								}
							}
								
							while (link.getAtom().getFunctor().isOutsideProxy()) {
								link = link.getAtom().nthAtom(0).getArg(1);
								s += m2hc.get(link.getAtom().getMem());
								s *= 13;
							}
							s += link.getAtom().getFunctor().hashCode();
							s *= link.getPos() + 1;
								
							// この膜内部の（プロキシでない）リンク元アトムまでトレース
							int t = 0;
							link = inside.getArg(1);
							while (link.getAtom().getFunctor().isOutsideProxy()) {
								link = link.getAtom().nthAtom(0).getArg(1);
								t += m2hc.get(link.getAtom().getMem());
								t *= 13;
							}
							t *= link.getAtom().getFunctor().hashCode();
							t *= link.getPos() + 1;
							temp += thisMembsHC^t * s;
						}
					}
					
					mol_add += temp;
					mol_add %= MAX_VALUE;
					mol_mult *= temp;
					mol_mult %= MAX_VALUE;
				}
				mol = mol_add^mol_mult;
				//System.out.println("molecule: " + calculated + " = " + mol);
				/* ハッシュコードを算出した分子を計算対象から取り除く */
				contents.removeAll(calculated);
				
				add += mol;
				add %= MAX_VALUE;
				mult *= mol;
				mult %= MAX_VALUE;
			}
			
			//System.out.println("membrane:" + m + " = " + (mult^add) + " (mult=" + mult + ", add=" + add + ")");
			return (int) (mult^add);
		}
	}
:].

H = mhash.hashCode(Memb, MR) :- H = 
[:/*inline*/
	Atom a = me.nthAtom(0).nthAtom(0);
	Membrane m = (Membrane) (a.getMem());
	int hashCode = MembraneHashCodeCalculator.calculate(m);
	
	Atom result = mem.newAtom(new IntegerFunctor(hashCode));
	
	mem.relinkAtomArgs(result, 0, me, 2);
	mem.unifyAtomArgs(me, 0, me, 1);
	me.remove();
:](Memb, MR).
}.