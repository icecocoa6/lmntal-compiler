% 膜同士の同型性判定モジュール
%
% AUTHOR: Kohei HIROTO
% 
% 06/12/19

{
module(meq).

[:/*inline_define*/	
	import java.util.*;
	import util.*;
	
	class MembraneEqualityJudge {
		/* mの直下のアトムの集合を返す */
		private static Set<Atom> getAtomSet(Membrane m) {
			Set<Atom> atoms = new HashSet<Atom> (m.getAtomCount());
			for (Iterator i = m.atomIterator(); i.hasNext(); ) {
				atoms.add((Atom) i.next());
			}
			return atoms;
		}
		
		/* mの直下の子膜の集合を返す */
		private static Set<Membrane> getMemSet(Membrane m) {
			Set<Membrane> mems = new HashSet<Membrane> (m.getMemCount());
			for (Iterator i = m.memIterator(); i.hasNext(); ) {
				mems.add((Membrane) i.next());
			}
			return mems;
		}
		
		/* m1とm2が同型ならば真同型でなければ偽を返す */
		static boolean judge(Membrane m1, Membrane m2) {
			return judge(m1, getAtomSet(m1), getMemSet(m1), m2, getAtomSet(m2), getMemSet(m2), 
							0, new HashSet<Atom>(), new HashSet<Membrane>(), new HashSet<Atom>(), new HashSet<Membrane>());
		}
		
		/* 
		 * m1とm2が同型ならば真同型でなければ偽を返す 
		 * @param uncheckedAtoms1 m1直下のアトムのうちm2との同型性が未チェックのものの集合
		 * @param uncheckedMems1 m1直下の子膜のうちm2との同型性が未チェックのものの集合
		 * @param depth m1およびm2が同型性を判定したい膜の何階層下の子膜であるかを示すゼロ以上の整数値。
		 * 				m1およびm2が同型性を判定したい膜そのものであるとき0
		 * @param checkedAtoms1 同型性判定が終了したアトムの集合。m1直下にないアトムも含み得る。
		 * 				このメソッドが真を返すとき少なくともuncheckedAtoms1に含まれていたアトムは追加される。
		 * 				偽を返すときは呼び出し時の状態から変化しない。
		 * @param checkedMems1 同型性判定が終了した膜の集合。m1直下にない膜も含み得る。
		 * 				このメソッドが真を返すとき少なくともuncheckedMems1に含まれていた子膜は追加される。
		 * 				偽を返すときは呼び出し時の状態から変化しない。
		 */
		private static boolean judge(Membrane m1, Set<Atom> uncheckedAtoms1, Set<Membrane> uncheckedMems1, 
										Membrane m2, Set<Atom> uncheckedAtoms2, Set<Membrane> uncheckedMems2, 
										int depth, Set<Atom> checkedAtoms1, Set<Membrane> checkedMems1, Set<Atom> checkedAtoms2, Set<Membrane> checkedMems2) {
			/*System.out.println("judge:\nm1=" + m1 + "\n\tuncheckedAtoms1=" + uncheckedAtoms1 + "\n\tuncheckedMems1=" + uncheckedMems1 
								+ "\nm2=" + m2 + "\n\tuncheckedAtoms2=" + uncheckedAtoms2 + "\n\tuncheckedMems2=" + uncheckedMems2
								+ "\ncheckedAtoms1=" + checkedAtoms1 + "\ncheckedMems1=" + checkedMems1 
								+ "\ncheckedAtoms2=" + checkedAtoms2 + "\ncheckedMems2=" + checkedMems2);*/
			
			// 直下のアトム数と子膜数を調べる
			if (m1.getAtomCount() != m2.getAtomCount()
				|| m1.getMemCount() != m2.getMemCount()) {
				return false;
			}
			
			/*
			 * tca1: このメソッドが真を返すときcheckedAtoms1に追加されるアトムの集合
			 * tcm1: このメソッドが真を返すときcheckedMems1に追加される膜の集合
			 */
			Set<Atom> tca1 = new HashSet<Atom>(checkedAtoms1), tca2 = new HashSet<Atom>(checkedAtoms2);
			Set<Membrane> tcm1 = new HashSet<Membrane>(checkedMems1), tcm2 = new HashSet<Membrane>(checkedMems2);
			
			/*
			 * traceメソッドの呼び出しに必要となる変数群
			 */
			Set<Atom> atomsInMol1 = new HashSet<Atom>(), atomsInMol2 = new HashSet<Atom>();
			List<Membrane> mLog1 = new ArrayList<Membrane>(), mLog2 = new ArrayList<Membrane>();
			List<Integer> mdLog = new ArrayList<Integer>();
			
			// m1とm2直下のアトムをそれぞれ起点とする分子を調べる
			while (!uncheckedAtoms1.isEmpty()) {
				Atom a1 = uncheckedAtoms1.iterator().next();
				/* matched: m1直下のアトムa1を起点とする分子とマッチする分子がm2内で最終的に見つかったかどうかを示すフラグ */
				boolean matched = false;
				Set<Atom> ca1 = null, ca2 = null;
				Set<Membrane> cm1 = null, cm2 = null;
				for (Iterator i = uncheckedAtoms2.iterator(); i.hasNext() && !matched; ) {
					Atom a2 = (Atom) i.next();
					atomsInMol1.clear();
					atomsInMol2.clear();
					mLog1.clear();
					mLog2.clear();
					mdLog.clear();
					
					trace: {
						if (traceLinks(a1, a2, depth, atomsInMol1, atomsInMol2, mLog1, mLog2, mdLog)) {
							// traceLinksで通過してきた膜をその順番どおり検査する
							// 膜が全てマッチすれば、a1とa2をそれぞれ起点とする分子全体がマッチしたことになる
							ca1 = new HashSet<Atom>(tca1);
							ca2 = new HashSet<Atom>(tca2);
							ca1.addAll(atomsInMol1);
							ca2.addAll(atomsInMol2);
							cm1 = new HashSet<Membrane>(tcm1);
							cm2 = new HashSet<Membrane>(tcm2);
							for (int k = 0; k < mLog1.size(); k++) {
								Membrane mm1 = mLog1.get(k), mm2 = mLog2.get(k);
								int d = mdLog.get(k);
								Set<Atom> ua1 = getAtomSet(mm1), ua2 = getAtomSet(mm2); 
								ua1.removeAll(ca1);
								ua2.removeAll(ca2);
								Set<Membrane> um1 = getMemSet(mm1), um2 = getMemSet(mm2);
								um1.removeAll(cm1);
								um2.removeAll(cm2);
								if (!judge(mm1, ua1, um1, mm2, ua2, um2, d, ca1, cm1, ca2, cm2)) {
									// 膜がひとつでもマッチしなかったら、このa2を起点とする分子はa1を起点とする分子にマッチしなかったということになる
									break trace;
								}
							}
							// traceLinksで通過してきた膜が全てマッチしたときここに到達する
							matched = true;
						}
					}
				}
					
				if (matched) {
					// a1とa2をそれぞれ起点とする分子同士のマッチングに成功したときここに到達する
					tca1.addAll(ca1);
					tcm1.addAll(cm1);
					tca2.addAll(ca2);
					tcm2.addAll(cm2);
					uncheckedAtoms1.removeAll(tca1);
					uncheckedMems1.removeAll(tcm1);
					uncheckedAtoms2.removeAll(tca2);
					uncheckedMems2.removeAll(tcm2);
				} else {
					return false;
				}
			}
			
			// m1とm2直下のアトムをそれぞれ起点とする分子のマッチングが全て成功したときここに到達する
			// m1とm2直下の子膜をそれぞれ起点とする分子を調べる
			while (!uncheckedMems1.isEmpty()) {
				Membrane mm1 = uncheckedMems1.iterator().next();
				Membrane mm2 = null;
				/* matched: m1直下の子膜mm1を起点とする分子とマッチする分子がm2内で最終的に見つかったかどうかを示すフラグ */
				boolean matched = false;
				Set<Atom> ca1 = null, ca2 = null, ua1 = null, ua2 = null;
				Set<Membrane> cm1 = null, cm2 = null, um1 = null, um2 = null;
				for (Iterator i = uncheckedMems2.iterator(); i.hasNext() && !matched; ) {
					mm2 = (Membrane) i.next();
					ua1 = getAtomSet(mm1);
					ua1.removeAll(tca1);
					ua2 = getAtomSet(mm2);
					ua2.removeAll(tca2);
					um1 = getMemSet(mm1);
					um1.removeAll(tcm1);
					um2 = getMemSet(mm2);
					um2.removeAll(tcm2);
					
					ca1 = new HashSet<Atom>(tca1);
					ca2 = new HashSet<Atom>(tca2);
					cm1 = new HashSet<Membrane>(tcm1);
					cm2 = new HashSet<Membrane>(tcm2);
					
					mLog1.clear();
					mLog2.clear();
					mdLog.clear();
					
					if (judge(mm1, ua1, um1, mm2, ua2, um2, depth + 1, ca1, cm1, ca2, cm2)) {
						matched = true;
					}
				}
					
				if (matched) {
					// mm1とmm2をそれぞれ起点とする分子同士のマッチングに成功したときここに到達する
					tca1.addAll(ca1);
					tcm1.addAll(cm1);
					tcm1.add(mm1);
					tca2.addAll(ca2);
					tcm2.addAll(cm2);
					tcm2.add(mm2);
					uncheckedAtoms1.removeAll(tca1);
					uncheckedMems1.removeAll(tcm1);
					uncheckedAtoms2.removeAll(tca2);
					uncheckedMems2.removeAll(tcm2);
				} else {
					return false;
				}
			}
			
			// m1とm2が同型と判定されたときここに到達する
			checkedAtoms1.addAll(tca1);
			checkedMems1.addAll(tcm1);
			checkedAtoms2.addAll(tca2);
			checkedMems2.addAll(tcm2);
			return true;
		}
		
		/*
		 * a1とa2をそれぞれ起点とする分子を比較する。このメソッドはメソッドjudgeから呼び出される。
		 */
		private static boolean traceLinks(Atom a1, Atom a2, int depth, 
											Set<Atom> atomsInMol1, Set<Atom> atomsInMol2, 
											List<Membrane> mLog1, List<Membrane> mLog2, List<Integer> mdLog) {
			//System.out.println("a1=" + a1 + ", a2=" + a2);
			return traceLinks(a1, -1, a2, -1, depth, atomsInMol1, atomsInMol2, new ArrayList<Atom>(), new ArrayList<Atom>(), mLog1, mLog2, mdLog);
		}
		
		/*
		 * a1とa2をそれぞれ起点とする分子を比較する
		 * @param a1 起点となるアトム
		 * @param argNum1 あるアトムからa1へのリンクを辿ってきたときの、a1側の引数番号。
		 * @param atomInMol1 メソッド実行後に分子１に含まれるアトムが追加されている
		 * @param depth メソッドjudgeの引数depthが受け渡される
		 * @param mLog1 トレースで通過してきた膜が通過順に格納される
		 * @param mdLog トレースで通過してきた膜の通過順に、その膜に対応するdepthが格納される。depthの意味はメソッドjudgeの引数depthと同様である。
		 */
		private static boolean traceLinks(Atom a1, int argNum1, Atom a2, int argNum2, int depth, 
											Set<Atom> atomsInMol1, Set<Atom> atomsInMol2, 
											List<Atom> aLog1, List<Atom> aLog2, List<Membrane> mLog1, List<Membrane> mLog2, List<Integer> mdLog) {
			aLog1.add(a1);
			aLog2.add(a2);
			
			// a1とa2が等しくなかったら偽を返す
			if (!a1.getName().equals(a2.getName())
						|| a1.getFunctor().getArity() != a2.getFunctor().getArity()
						|| argNum1 != argNum2) {
				return false;
			}
			
			if (depth > 0 && a1.getFunctor().isInsideProxy()) {
				Membrane m = a1.getMem();
				if (!mLog1.contains(m)) {
					mLog1.add(m);
					mLog2.add(a2.getMem());
					mdLog.add(depth);
				}
			}
			
			int arity = a1.getFunctor().getArity();
			// for文内のiの初期化で、比較したい膜の外側にまでトレースが進まないようにしている
			for (int i = (a1.getFunctor().isInsideProxy() && depth == 0) ? 1 : 0; i < arity; i++) {
				Link link1 = a1.getArg(i);
				Link link2 = a2.getArg(i);
				Atom aa1 = link1.getAtom();
				Atom aa2 = link2.getAtom();
				int an1 = link1.getPos();
				int an2 = link2.getPos();
				
				int index1 = aLog1.indexOf(aa1);
				if (index1 >= 0) { // これまでのトレースで通過してきたアトムに帰ってきたとき。（分子が環状であるとき起こる)
					if (index1 != aLog2.indexOf(aa2) || an1 != an2) {
						return false;
					} else {
						continue;
					}
				} else if (atomsInMol1.contains(aa1)) {
					continue;
				}
				
				int nextDepth = depth;
				if (a1.getFunctor().isOutsideProxy() && i == 0) {
					nextDepth++;
				} else if (a1.getFunctor().isInsideProxy() && i == 0) {
					nextDepth--;
				}
				boolean flag = traceLinks(aa1, an1, aa2, an2, nextDepth, atomsInMol1, atomsInMol2, aLog1, aLog2, mLog1, mLog2, mdLog);
				aLog1.remove(aLog1.size() - 1);
				aLog2.remove(aLog2.size() - 1);
				if (!flag) {
					return false;
				}
			}
			
			atomsInMol1.add(a1);
			atomsInMol2.add(a2);
			return true;
		}
	}
:].

H = meq.judgeEquality(Memb1, Memb2, MR1, MR2) :- H = 
[:/*inline*/
	Atom a1 = me.nthAtom(0).nthAtom(0);
	Atom a2 = me.nthAtom(1).nthAtom(0);
	Membrane m1 = (Membrane) (a1.getMem());
	Membrane m2 = (Membrane) (a2.getMem());
	boolean equality = MembraneEqualityJudge.judge(m1, m2);
	
	Atom result = mem.newAtom(new SymbolFunctor((equality) ? "true" : "false", 1));
	
	mem.relinkAtomArgs(result, 0, me, 4);
	mem.unifyAtomArgs(me, 2, me, 0);
	mem.unifyAtomArgs(me, 3, me, 1);
	//mem.relinkAtomArgs(result, 0, me, 2);
	//mem.relinkAtomArgs(hand1, 0, me, 0);
	me.remove();
:](Memb1, Memb2, MR1, MR2).
}.