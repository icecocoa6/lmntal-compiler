% 膜のハッシュコードを計算する
%
% AUTHOR: Kohei HIROTO
% 
% 06/12/13

{
module(mhash).

// 分子毎の計算を実装した版
[:/*inline_define*/	
	import java.util.*;
	import util.*;
	
	class MembraneHashCodeCalculator {
		static int calculate(Membrane m) {
			return calculate(m, new HashMap<Membrane, Integer>());
		}
		
		private static int calculate(Membrane m, Map<Membrane, Integer> m2hc) {
			System.out.println("membrane:" + m);
			final long MAX_VALUE = Integer.MAX_VALUE;
			long add = 3412;        // 3412は適当な初期値
			//long xor = 3412;
			long mult = 3412;
			
			Atom a = null;
			Membrane mm = null;
			QueuedEntity q = null;
			
			//Map<Membrane, Integer> m2hc = new HashMap<Membrane, Integer>();
			
			// atoms:この膜内のアトム全体の集合, toCalculate:現在計算中の分子内の未処理アトムの集合, calculated:現在形山中の分子内の処理済アトムの集合
			Set<QueuedEntity> contents = new HashSet<QueuedEntity>(), toCalculate = new HashSet<QueuedEntity>(), calculated = new HashSet<QueuedEntity>();
			
			for (Iterator i = m.atomIterator(); i.hasNext(); ) {
				a = (Atom) i.next();
				if (a.getFunctor().isOutsideProxy() || a.getFunctor().isInsideProxy()) {
					continue;
				}
				contents.add(a);
			}
			
			// 子膜を処理する
			for (Iterator i = m.memIterator(); i.hasNext(); ) {
				mm = (Membrane) i.next();
				contents.add(mm);
				m2hc.put(mm, calculate(mm, m2hc));
			}
			
			// 子膜以外のアトムを処理する
			while (!contents.isEmpty()) {
				System.out.println("uncalculated:" + contents);
				q = contents.iterator().next();
				contents.remove(q);
				
				// 分子ごとのハッシュコード
				long mol = -1, mol_add = 0, mol_xor = 0, mol_mult = 1, temp = 0;
				
				toCalculate.clear();
				calculated.clear();
				toCalculate.add(q);
					
				// 「２つ一組が２つ」と「４つで環状」を区別するために
				// 分子毎にグループ化して計算する
				while (!toCalculate.isEmpty()) {
					q = toCalculate.iterator().next();
					calculated.add(q);
					toCalculate.remove(q);
					
					if (q instanceof Atom) {
						a = (Atom) q;
						temp = a.getFunctor().hashCode();
						//System.out.println(a +":"+ mol_hc);
									
						// このアトムのリンクを処理する
						int arity = a.getFunctor().getArity();
						for (int k = 0; k < arity; k++) {
							temp *= 31;
							Link link = a.getArg(k);
							if (link.getAtom().getFunctor().isInsideProxy()) {
								Atom inside = link.getAtom();
								int pos = link.getPos() + 1;
								temp += (inside.getFunctor().hashCode() * pos);	
							} else if (link.getAtom().getFunctor().isOutsideProxy()) { // リンク先が子膜の場合
								/*リンク先アトムに至るまで貫いた子膜のハッシュコードと
									最終的なリンク先アトムのハッシュコードと
									そのアトムの引数番号の組を
									このアトムから子膜へのリンクを表現する項とする。*/
								int t = 0;
								mm = link.getAtom().nthAtom(0).getMem();
							if (!calculated.contains(mm)) {
									toCalculate.add(mm);
								}
								while (link.getAtom().getFunctor().isOutsideProxy()) {
									link = link.getAtom().nthAtom(0).getArg(1);
									mm = link.getAtom().getMem();
									t += m2hc.get(mm);
									t *= 13;
								}
								
								t += link.getAtom().getFunctor().hashCode();
								t *= link.getPos() + 1;
								temp += t;
							} else {
								Atom linked = link.getAtom();
								if (!calculated.contains(linked)) {
									toCalculate.add(linked);
								}
								int pos = link.getPos() + 1;
								//System.out.println(pos);
								// 接続先の引数番号をハッシュに関与させる
								temp += (linked.getFunctor().hashCode() * pos);
							}
						}
					} else {
						Membrane mt = (Membrane) q;
						
						final int thisMembsHC = m2hc.get(mt);
						temp = thisMembsHC;
						
						// この膜から膜の外部へのリンクを処理する
						Link link = null;
						for (Iterator i = mt.atomIteratorOfFunctor(Functor.INSIDE_PROXY); i.hasNext(); ) {
							Atom inside = (Atom) i.next();
							// この膜外部の（プロキシでない）リンク先アトムまでトレース
							int s = 0;
							link = inside.nthAtom(0).getArg(1);
							
							if (link.getAtom().getFunctor().isOutsideProxy()) { // この膜のリンク先が膜のとき
								mm = link.getAtom().nthAtom(0).getMem();
								if (!calculated.contains(mm)) {
									toCalculate.add(mm);
								}
							} else { // この膜のリンク先がアトムの場合
								a = link.getAtom();
								if (!calculated.contains(a)) {
									toCalculate.add(a);
								}
							}
								
							while (link.getAtom().getFunctor().isOutsideProxy()) {
								link = link.getAtom().nthAtom(0).getArg(1);
								s += m2hc.get(link.getAtom().getMem());
								s *= 13;
							}
							s += link.getAtom().getFunctor().hashCode();
							s *= link.getPos() + 1;
								
							// この膜内部の（プロキシでない）リンク元アトムまでトレース
							int t = 0;
							link = inside.getArg(1);
							while (link.getAtom().getFunctor().isOutsideProxy()) {
								link = link.getAtom().nthAtom(0).getArg(1);
								t += m2hc.get(link.getAtom().getMem());
								t *= 13;
							}
							t += link.getAtom().getFunctor().hashCode();
							t *= link.getPos() + 1;
							temp += thisMembsHC^t * s;
						}
					}
					System.out.println(q + " and its links = " + temp);
					
					mol_add += temp;
					mol_add %= MAX_VALUE;
					//mol_xor ^= temp;
					mol_mult *= temp;
					mol_mult %= MAX_VALUE;
						
				}
				mol = mol_add /*+ mol_xor */ + mol_mult;
				System.out.println("molecule: " + calculated + " = " + mol);
				contents.removeAll(calculated);
				
				add += mol;
				add %= MAX_VALUE;
				//xor ^= mol;
				mult *= mol;
				mult %= MAX_VALUE;
			}
			
			return (int) ((mult /*+ xor*/ + add) % MAX_VALUE);
		}
	}
:].

H = mhash.hashCode(Memb) :- H = 
[:/*inline*/
	Atom a = me.nthAtom(0).nthAtom(0); // アトム$in
	Membrane m = (Membrane) (a.getMem());
	int hashCode = MembraneHashCodeCalculator.calculate(m);
	
	Atom result = mem.newAtom(new IntegerFunctor(hashCode));
	mem.relinkAtomArgs(result, 0, me, 1);
	a.nthAtom(1).remove();
	me.remove();
:](Memb).
}.
/*
hc1 = mhash.hashCode(Memb1).
Memb1 = { a(X). a(X) }.
*/

/*
// 膜によるグループ分けの例
hc0 = mhash.hashCode(Memb0).
hc1 = mhash.hashCode(Memb1).
hc2 = mhash.hashCode(Memb2).
hc3 = mhash.hashCode(Memb3).
hc4 = mhash.hashCode(Memb4).
hc5 = mhash.hashCode(Memb5).
hc6 = mhash.hashCode(Memb6).
hc7 = mhash.hashCode(Memb7).
hc8 = mhash.hashCode(Memb8).
hc9 = mhash.hashCode(Memb9).
hc10 = mhash.hashCode(Memb10).
hc11 = mhash.hashCode(Memb11).
hc12 = mhash.hashCode(Memb12).
hc13 = mhash.hashCode(Memb13).
Memb0 = {aaa. bbb. ccc.}.
Memb1 = {{aaa. bbb. ccc}. {}.}.
Memb2 = {{}. {ccc. aaa. bbb}.}.   // アトムの順番が変ったとき
Memb3 = {{aaa. bbb. ccc}. }.      // {}の有無
Memb4 = {{aaa. bbb.}. {ccc.}.}.
Memb5 = {{ccc.}. {aaa. bbb.}.}.
Memb6 = {{aaa. ccc.}. {bbb.}.}.
Memb7 = {{bbb. ccc.}. {aaa.}.}.
Memb8 = {{aaa.}. {bbb.}. {ccc.}.}.
Memb9 = {aaa.}.
Memb10 = {{aaa.}.}.
Memb11 = {{{aaa.}.}.}.
Memb12 = {a = {w, c}. b = {g}}.
Memb13 = {a = {w, g}. b = {c}}.
*/
/*
// 「２つ一組が２つ」と「４つで環状」
hc1 = mhash.hashCode(Memb1).
hc2 = mhash.hashCode(Memb2).
hc3 = mhash.hashCode(Memb3).
hc4 = mhash.hashCode(Memb4).
Memb1 = { a(X, Y). a(X, Y). a(S, T). a(S, T). }.
Memb2 = { a(X, Y). a(X, T). a(S, Y). a(S, T). }.
Memb3 = { a(X, Y). a(Y, Z). a(Z, X). a(S, T). a(T, S). }.
Memb4 = { a(X, Y). a(Y, Z). a(Z, S). a(S, T). a(T, X). }.
*/

/*
// 膜内のリンク先アトムひとつのみを考える場合には区別できない例
hc1 = mhash.hashCode(Memb1).
hc2 = mhash.hashCode(Memb2).
Memb1 = { x(X). y(Y). { a(X, L1). a(Y, L2). b(L3, L1). c(L2, L3). } }.
Memb2 = { x(X). y(Y). { a(X, L1). a(Y, L2). c(L1, L3). b(L3, L2). } }.
*/

/*
// 膜内のリンク先アトムひとつのみを考える場合には区別できない例
hc1 = mhash.hashCode(Memb1).
hc2 = mhash.hashCode(Memb2).
Memb1 = { x(X). y(Y). a(X, L0). a(L0, L1). a(Y, L500). a(L500, L2). b(L3, L1). c(L2, L3). }.
Memb2 = { x(X). y(Y). a(X, L0). a(L0, L1). a(Y, L500). a(L500, L2). c(L1, L3). b(L3, L2). }.
*/

/*
// シス･トランス異性体
hc1 = mhash.hashCode(Memb1).
hc2 = mhash.hashCode(Memb2).
Memb1 = { a(X, Y, L). a(X, T). a(S, Y). a(S, T, M). a(L). a(M). }.
Memb2 = { a(X, Y, L). a(X, T). a(S, Y, M). a(S, T). a(L). a(M). }.
*/

/*
//ferrymanの例題で使った状態を表す膜
hc1 = mhash.hashCode(Memb1).
hc2 = mhash.hashCode(Memb2).
Memb1 = {a = {f, c, g}. b = {}.}.
Memb2 = {a = {c, g}. b = {f}.}.
*/