///////////////////////////////////////////////////////////////////////////
○ unify 関数実装メモ

次のような実行結果の関数
 % Prologでいう yes, F=naoyuki.
 unify(リスト1, リスト2) -(成功時)-> 束縛変数リスト
 % Prologでいう no.
 unify(リスト1, リスト2) -(失敗時)-> fail
 
前提
(i) unifyの引数に使用するリストは入れ子構造ではない
  ==> 入れ子の場合 X = [Y, a] などの束縛を管理するため、
      構造が複雑になる？

(ii) シンボル：小文字　変数：大文字

実装手順
1. リストの要素がシンボルのみ（マッチング）
    bindingの成否のみ判定するルールの作成
    
    unify([], []) -> []
    unify([a], []) -> fail
    unify([a, b], [a, b]) -> []

2. 1 + リストの要素に変数が含まれる
   変数にシンボルを束縛させる
   ただし変数に変数は束縛されない
 
    unify([X], [a]) -> [[X, a]]
    unify([X, b], [a, Y]) -> [[X, a], [Y, b]]

3. 2 + 変数同士の束縛
    unify([X, Y], [Y, a]) -> [[X, Y], [Y, a]] ( -?-> [[X, a], [Y, a]] )
    unify([X, Y], [X, Y]) -> [[X, X], {Y, Y]] ( -?-> [] )
    unify([X, Y], [Y, X]) -> [[X, Y], [Y, X]] ( -?-> [[X, Y]])
    unify([X, Y, X], [a, b, Y]) -?-> [[X, a], [Y, b], ?[X, Y]] -> fail
    
    束縛変数管理テーブルのようなものが必要？
    変数同士の整合性確認
    
※リストの要素にリストの入れ子を考慮
1. シンボルのみ
   それほど拡張点はない
    unify([a, [b, X]], [a, [b, c]]) -> [X, c]
   
2. 変数にシンボル(リスト)を束縛
   束縛できるものをリストとする
    unify([a, X], [a, [b, c]]) -> [[X, [b,c]]]

3. 変数同士の束縛
    unify([X, Y], [[X, a], b]) -?-> [[X, [X, a]], [Y, b]] -> fail
    
    整合性を確認する？

///////////////////////////////////////////////////////////////////////////
○ その他のメモ
シンボルのマッチングにunaryを使うと簡潔に書ける？
