//  rules of bisimulation04
//  module使用、system_ruleset未使用
/*
input{
  stateSet([1,2,3,4,5,6,7,8,9,10,11,12]).
  compare(1,7).
  transition(1,1,2).
  transition(1,1,3).
  transition(2,2,4).
  transition(2,2,5).
  transition(3,2,6).
  transition(4,3,4).
  transition(5,3,5).
  transition(6,4,6).
  transition(7,1,8).
  transition(7,1,9).
  transition(8,2,10).
  transition(9,2,11).
  transition(9,2,12).
  transition(10,3,10).
  transition(11,4,11).
  transition(12,4,12).
}.
*/

/*
input{
  stateSet([1,2,3,4,5,6,7,8,9,10,11,12]).
  compare(1,7).
  transition(1,1,2).
  transition(1,1,3).
  transition(2,2,4).
  transition(2,2,5).
  transition(3,2,6).
  transition(4,3,4).
  transition(5,4,5).
  transition(6,4,6).
  transition(7,1,8).
  transition(7,1,9).
  transition(8,2,10).
  transition(9,2,11).
  transition(9,2,12).
  transition(10,3,10).
  transition(11,3,11).
  transition(12,4,12).
}.
*/

/*
input{
  stateSet([1,2,3,4,5,6]).
  compare(1,4).
  transition(1,1,2).
  transition(1,1,3).
  transition(2,2,2).
  transition(3,3,3).
  transition(4,1,5).
  transition(4,1,6).
  transition(5,3,5).
  transition(6,2,6).
}.
*/


input{
  stateSet([1,2,3,4,5,6]).
  compare(1,4).
  transition(1,1,6).
  transition(1,1,3).
  transition(2,2,2).
  transition(3,3,3).
  transition(4,1,5).
  transition(4,1,2).
  transition(5,3,5).
  transition(6,2,6).
}.


input{$i} :- 
  preprocess{
    $i.
    
    L = [X1, X2|T] :- X1 > X2 | L = [X2, X1|T].
    compare(X, Y) :- X > Y | compare(Y, X).
    transition(From1, Label1, To1), transition(From2, Label2, To2) :- 
      From1 = From2, Label1 = Label2, To1 = To2 | 
      transition(From1, Label1, To1).
  }.

preprocess{stateSet(List), $p, @p}/ :- 
  ground(List) | 
  mk_arc{
    mk_arc(List), $p.
    
    mk_arc([]) :- .
    mk_arc([H|T]) :- arc(H, []), mk_arc(T).
    
    transition(From1, Label, To), arc(From2, List) :- 
      int(Label), int(To), From1 = From2 | 
      arc(From2, [label(Label, [To])|List]).
    L = [label(Label1, List1), label(Label2, List2) | T] :- 
      Label1 > Label2 | 
      L = [label(Label2, List2), label(Label1, List1) | T].
    L = [label(Label1, List1), label(Label2, List2) | T] :- 
      Label1 = Label2 | 
      L = [label(Label1, list.append(List1, List2)) | T].
  }, 
  product{
    product1(List).
    
    product1([]) :- .
    product1([H|T]) :- int(H) | product1([p1(H) | T]), pair(H, H).
    R = [p1(X) | []] :- int(X) | R = [].
    R = [p1(X), H|T] :- int(X), int(H) | R = [H, p1(X) | T], pair(X, H).
  }.

mk_arc{$m, @m}/, product{$p[], @p}/ :- 
  bisimulation{
    bisimulation(no).
    factory{
      $m.
      work{$p[]. pair(L, R) :- L = R | .}.
      prev{$p[]}.
      next{$p[]. flag(0)}.
      
      work{pair(I, J), $w, @w}, arc(I0, List0), arc(J1, List1) :- 
        ground(List0), ground(List1), I = I0, J = J1 | 
        work{checking, $w, @w}, arc(I0, List0), arc(J1, List1), 
        check1(I, J, List0, List1).
      check1(I, J, [], []), work{checking, $w, @w} :- 
        int(I), int(J) | 
        work{$w, @w}.
      check1(I, J, [label(X0, X0List) | List0], []), work{checking, $w, @w}, 
      next{flag(F), pair(NI, NJ), $n} :- 
        ground(X0List), ground(List0), int(X0), int(F), I = NI, J = NJ | 
        work{$w, @w}, next{flag(1), $n}.
      check1(I, J, [], [label(X1, X1List) | List1]), work{checking, $w, @w}, 
      next{flag(F), pair(NI, NJ), $n} :- 
        ground(X1List), ground(List1), int(X1), int(F), I = NI, J = NJ | 
        work{$w, @w}, next{flag(1), $n}.
      check1(I, J, [label(X0, X0List) | List0], [label(X1, X1List) | List1]), 
      work{checking, $w, @w}, next{flag(F), pair(NI, NJ), $n} :- 
        ground(X0List), ground(List0), ground(X1List), ground(List1), int(F), 
        X0 \= X1, I = NI, J = NJ | 
        work{$w, @w}, next{flag(1), $n}.
      check1(I, J, [label(X0, X0List) | List0], [label(X1, X1List) | List1]) :- 
        ground(X0List), ground(X1List), X0 = X1 | 
        check2(
          I, J, List0, List1, 
          { product2(X0List, X1List).
            mk_node(X0List).
            mk_node(X1List).
            mk_node([]) :- .
            mk_node([H|T]) :- node(H, 1), mk_node(T).
            product2([], List) :- ground(List) | .
            product2([H|T], List) :- 
              ground(List) | 
              p2(H, List), product2(T, List).
            p2(X, []) :- int(X) | .
            p2(X, [H|T]) :- X =< H | pair(X, H), p2(X, T).
            p2(X, [H|T]) :- X > H | pair(H, X), p2(X, T).
          }
        ).
      check2(
        I, J, List0, List1, 
        {pair(CL, CR), node(NL, LF), node(NR, RF), $c, @c}/
      ),
      prev{pair(PL, PR), $p} :- 
        ground(List0), ground(List1), int(LF), int(RF), int(I), int(J), 
        CL = PL, CR = PR, CL = NL, CR = NR | 
	      check2(I, J, List0, List1, {node(NL, 0), node(NR, 0), $c, @c}), 
	      prev{pair(PL, PR), $p}.
      check2(I, J, List0, List1, {@c}) :- check1(I, J, List0, List1).
    }.
    factory{check2(I, J, List0, List1, {pair(L, R), $c, @c}), $f, @f}/ :- 
      ground(List0), ground(List1), int(I), int(J), int(L), int(R) | 
      factory{check2(I, J, List0, List1, {$c, @c}), $f, @f}.
    factory{check2(I, J, List0, List1, {node(N, 0), $c, @c}), $f, @f}/ :- 
      ground(List0), ground(List1), int(I), int(J), int(N) | 
      factory{check2(I, J, List0, List1, {$c, @c}), $f, @f}.
    factory{
      check2(I, J, List0, List1, {node(N, 1), $c[], @c}), 
      work{checking, $w, @w}, next{pair(IN, JN), flag(F), $n}, $f, @f
    }/ :- 
      ground(List0), ground(List1), int(N), int(F), I = IN, J = JN | 
      factory{work{$w, @w}, next{flag(1), $n}, $f, @f}.
    factory{prev{$p[]}, work{@w}, next{flag(1), $n[]}, $f, @f}/ :- 
      factory{prev{$n[]}, work{$n[], @w}, next{flag(0), $n[]}, $f, @f}.
    factory{
      prev{$p[]}, work{@w}, next{flag(0), pair(L, R), $n[]}, 
      compare(CL, CR), $f, @f
    }/, 
    bisimulation(no) :- 
      L = CL, R = CR | 
      factory{
        prev{$n[]}, work{$n[], @w}, next{flag(0), pair(L, R), $n[]}, 
        compare(CL, CR), $f, @f
      }, 
      bisimulation(yes).
  }.

bisimulation{
  factory{next{flag(F), $n, @n}, $f[], @f}, 
  bisimulation(B), $r[], @r
}/ :- 
  unary(B), int(F) | 
  bisim_result{bisimulation(B), bisimilar{$n}}.
