//  rules of ccs01-obseq00
//  module使用、system_ruleset未使用

input{
/*
ccs{
  //  proc P = '1.0.nil + 2.nil
  {
    { send(C11, 
      {
        { internal({{ nil }}) }
      }), 
      receive(C21, {{ nil }})
    }
  }, 
  {name(1), +C11}, {name(2), +C21}.
}.



ccs{
  //  proc P = 0.('1.nil + 2.0.nil)
  {
    { internal(
      {
        { send(C11, {{ nil }}), 
          receive(C21, 
          {
            { internal({{ nil }}) }
          })
        }
      })
    }
  }, 
  {name(1), +C11}, {name(2), +C21}.
}.
*/


ccs{
  //  proc P = 1.nil + 0.nil
  {
    { receive(C11, {{ nil }}), 
      internal({{ nil }})
    }
  }, 
  {name(1), +C11}.
}.



ccs{
  //  proc P = 1.nil
  {
    { receive(C11, {{ nil }}) }
  }, 
  {name(1), +C11}.
}.

}.

//  rules of ccs01-nd04
//  module未使用、system_ruleset未使用

input{$i, @i}, ccs_nd_rules{@c} :- 
  factory{
    //  状態のコピー
    generator{ccs_nd{copyFlag(0, 0), $r[], @r}, $g, @g}/ :- 
      generator{
        ccs_nd{copyFlag(0, 1), $r[], @r}, 
        ccs_nd{copyFlag(1, 1), $r[], @r}, $g, @g
      }.
      
    generator{
      transitions{stateSet([])}, nextActionID(0), nextStateID(0), $i, @i, @c
    }
  }.

factory{generator{transitions{$t[]}, $g[], @g}, $f[], @f}/ :- 
  ccs_nd_result{$t[]}, 
  obseq_input{
    $t[].
    
    transition(From1, Label1, To1), transition(From2, 0, To2) :- 
      Label1 \= 0, To1 = From2, uniq(From1, From2, Label1, To1, To2) | 
      transition(From1, Label1, To1), transition(From2, 0, To2), 
      transition(From1, Label1, To2).
    transition(From1, 0, To1), transition(From2, Label2, To2) :- 
      Label2 \= 0, To1 = From2, uniq(From1, From2, Label2, To1, To2) | 
      transition(From1, 0, To1), transition(From2, Label2, To2), 
      transition(From1, Label2, To2).
    transition(From1, 0, To1), transition(From2, 0, To2) :- 
      To1 = From2, uniq(From1, From2, To1, To2) | 
      transition(From1, 0, To1), transition(From2, 0, To2), 
      transition(From1, 0, To2).
  }.

ccs_nd_rules{
  //  actionIDを付与
  //  安定版
  ccs_nd{
    {{send(C1, {$q1}), $p1}, $q2}, {name(CN), +C1, $c}, $r1, @r1
  }/, 
  nextActionID(N1) :- 
    int(CN), N2 = N1 + 1 | 
    ccs_nd{
      {{send(N1, C2, {$q1}), $p1}, $q2}, 
      {name(CN), +C2, $c}, $r1, @r1
    }, 
    nextActionID(N2).
  ccs_nd{
    {{send(C1, {$q1}), $p1}, {name(CN), +C1, $c}, $q2}, $r1, @r1
  }/, 
  nextActionID(N1) :- 
    int(CN), N2 = N1 + 1 | 
    ccs_nd{
      {{send(N1, C2, {$q1}), $p1}, {name(CN), +C2, $c}, $q2}, 
      $r1, @r1
    }, 
    nextActionID(N2).
  ccs_nd{
    {{receive(C1, {$q1}), $p1}, $q2}, {name(CN), +C1, $c}, $r1, @r1
  }/, 
  nextActionID(N1) :- 
    int(CN), N2 = N1 + 1 | 
    ccs_nd{
      {{receive(N1, C2, {$q1}), $p1}, $q2}, 
      {name(CN), +C2, $c}, $r1, @r1
    }, 
    nextActionID(N2).
  ccs_nd{
    {{receive(C1, {$q1}), $p1}, {name(CN), +C1, $c}, $q2}, $r1, @r1
  }/, 
  nextActionID(N1) :- 
    int(CN), N2 = N1 + 1 | 
    ccs_nd{
      {{receive(N1, C2, {$q1}), $p1}, {name(CN), +C2, $c}, $q2}, 
      $r1, @r1
    }, 
    nextActionID(N2).
  ccs_nd{{{internal({$q1}), $p1}, $q2}, $r1, @r1}/, 
  nextActionID(N1) :- 
    N2 = N1 + 1 | 
    ccs_nd{{{internal(N1, {$q1}), $p1}, $q2}, $r1, @r1}, 
    nextActionID(N2).
    
  //  外部に送信
  ccs_nd{
    {{send(A_ID1, C1, {$q1}), $p1}, $q2}, 
    {name(CN), +C1, $c}, stateID(S_ID1), copyFlag(1, 1), $r1, @r1
  }/, 
  ccs_nd{stateID(S_ID2), copyFlag(0, 1), $r2, @r2}, 
  transitions{stateSet(S), $t}, nextStateID(N1) :- 
    ground(S), int(A_ID1), int(CN), T = CN, S_ID1 = S_ID2, N2 = N1 + 1, 
    uniq(A_ID1, S_ID1) | 
    ccs_nd{
      memkill({$p1}, killed), {name(CN), $c}, {$q1, $q2}, 
      stateID(N1), copyFlag(0, 0), $r1, @r1
    }, 
    ccs_nd{stateID(S_ID2), copyFlag(0, 0), $r2, @r2}, 
    transitions{stateSet([N1|S]), transition(S_ID1, T, N1), $t}, 
    nextStateID(N2).
    
  //  外部から受信
  ccs_nd{
    {{receive(A_ID1, C1, {$q1}), $p1}, $q2}, 
    {name(CN), +C1, $c}, stateID(S_ID1), copyFlag(1, 1), $r1, @r1
  }/, 
  ccs_nd{stateID(S_ID2), copyFlag(0, 1), $r2, @r2}, 
  transitions{stateSet(S), $t}, nextStateID(N1) :- 
    ground(S), int(A_ID1), int(CN), T = -CN, S_ID1 = S_ID2, N2 = N1 + 1, 
    uniq(A_ID1, S_ID1) | 
    ccs_nd{
      memkill({$p1}, killed), {name(CN), $c}, {$q1, $q2}, 
      stateID(N1), copyFlag(0, 0), $r1, @r1
    }, 
    ccs_nd{stateID(S_ID2), copyFlag(0, 0), $r2, @r2}, 
    transitions{stateSet([N1|S]), transition(S_ID1, T, N1), $t}, 
    nextStateID(N2).
    
  //  明示的な内部動作
  ccs_nd{
    {{internal(A_ID1, {$q1}), $p1}, $q2}, 
    stateID(S_ID1), copyFlag(1, 1), $r1, @r1
  }/, 
  ccs_nd{stateID(S_ID2), copyFlag(0, 1), $r2, @r2}, 
  transitions{stateSet(S), $t}, nextStateID(N1) :- 
    ground(S), int(A_ID1), S_ID1 = S_ID2, N2 = N1 + 1, uniq(A_ID1, S_ID1) | 
    ccs_nd{
      memkill({$p1}, killed), {$q1, $q2}, 
      stateID(N1), copyFlag(0, 0), $r1, @r1
    }, 
    ccs_nd{stateID(S_ID2), copyFlag(0, 0), $r2, @r2}, 
    transitions{stateSet([N1|S]), transition(S_ID1, 0, N1), $t}, 
    nextStateID(N2).
    
  //  異なるRestriction膜内で大域チャネルによる送受信
  ccs_nd{
    {{send(A_ID1, C1, {$q1}), $p1}, $q2}, 
    {{receive(A_ID2, C2, {$q3}), $p2}, $q4}, 
    {name(CN), +C1, +C2, $c}, 
    stateID(S_ID1), copyFlag(1, 1), $r1, @r1
  }/, 
  ccs_nd{stateID(S_ID2), copyFlag(0, 1), $r2, @r2}, 
  transitions{stateSet(S), $t}, nextStateID(N1) :- 
    ground(S), int(A_ID1), int(A_ID2), int(CN), S_ID1 = S_ID2, N2 = N1 + 1, 
    uniq(A_ID1, A_ID2, S_ID1) | 
    ccs_nd{
      memkill({$p1, $p2}, killed), {name(CN), $c}, 
      {$q1, $q2}, {$q3, $q4}, stateID(N1), copyFlag(0, 0), $r1, @r1
    }, 
    ccs_nd{stateID(S_ID2), copyFlag(0, 0), $r2, @r2}, 
    transitions{stateSet([N1|S]), transition(S_ID1, 0, N1), $t}, 
    nextStateID(N2).
    
  //  同一Restriction膜内で大域チャネルによる送受信
  ccs_nd{
    {
      {send(A_ID1, C1, {$q1}), $p1}, 
      {receive(A_ID2, C2, {$q2}), $p2}, $q3
    }, 
    {name(CN), +C1, +C2, $c}, 
    stateID(S_ID1), copyFlag(1, 1), $r1, @r1
  }/, 
  ccs_nd{stateID(S_ID2), copyFlag(0, 1), $r2, @r2}, 
  transitions{stateSet(S), $t}, nextStateID(N1) :- 
    ground(S), int(A_ID1), int(A_ID2), int(CN), S_ID1 = S_ID2, N2 = N1 + 1, 
    uniq(A_ID1, A_ID2, S_ID1) | 
    ccs_nd{
      memkill({$p1, $p2}, killed), {name(CN), $c}, 
      {$q1, $q2, $q3}, stateID(N1), copyFlag(0, 0), $r1, @r1
    }, 
    ccs_nd{stateID(S_ID2), copyFlag(0, 0), $r2, @r2}, 
    transitions{stateSet([N1|S]), transition(S_ID1, 0, N1), $t}, 
    nextStateID(N2).
    
  //  同一Restriction膜内で局所チャネルによる送受信
  ccs_nd{
    {
      {send(A_ID1, C1, {$q1}), $p1}, 
      {receive(A_ID2, C2, {$q2}), $p2}, 
      {name(CN), +C1, +C2, $c}, $q3
    }, 
    stateID(S_ID1), copyFlag(1, 1), $r1, @r1
  }/, 
  ccs_nd{stateID(S_ID2), copyFlag(0, 1), $r2, @r2}, 
  transitions{stateSet(S), $t}, nextStateID(N1) :- 
    ground(S), int(A_ID1), int(A_ID2), int(CN), S_ID1 = S_ID2, N2 = N1 + 1, 
    uniq(A_ID1, A_ID2, S_ID1) | 
    ccs_nd{
      memkill({$p1, $p2}, killed), 
      {{name(CN), $c}, $q1, $q2, $q3}, 
      stateID(N1), copyFlag(0, 0), $r1, @r1
    }, 
    ccs_nd{stateID(S_ID2), copyFlag(0, 0), $r2, @r2}, 
    transitions{stateSet([N1|S]), transition(S_ID1, 0, N1), $t}, 
    nextStateID(N2).
    
  ccs_nd{@r}, action(A) :- ground(A) | action(end).
  
  ccs{$c, @c}, transitions{stateSet(S), $t}, nextStateID(N1) :- 
    ground(S), N2 = N1 + 1 | 
    ccs_nd{
      //  選択されなかった動作の削除
      memkill({$p, @p}) :- memkill({$p, @p}, killed).
      memkill({$p[], @p}, KillTag) :- 
        unary(KillTag) | .
      memkill({$p[X|*Z], @p}, KillTag) :- 
        unary(KillTag) | 
        memkill({$p[Y|*Z], killing(Y), @p}, KillTag), X = KillTag.
        
      //  同一チャネル膜の併合
      {name(CN1), $c1}, {name(CN2), $c2} :- 
        CN1 = CN2 | {name(CN1), $c1, $c2}.
      {{name(CN1), $c1}, {name(CN2), $c2}, $q} :- 
        CN1 = CN2 | {{name(CN1), $c1, $c2}, $q}.
        
      //  使用済みチャネル膜の削除
      {name(CN)} :- unary(CN) | .
      {{name(CN)}, $q} :- unary(CN) | {$q}.
      
      //  killedアトムと接続子の削除
      killed({$c}) :- {$c}.
      killed(C), {{+C, $c}, $q} :- {{$c}, $q}.
      
      //  動作終了
      {} :- .
      {{}, $q} :- {$q}.
      {{nil, $p}, $q} :- {{$p}, $q}.
      stateID(N1), copyFlag(0, 0), $c, @c
    }, 
    transitions{stateSet([N1|S]), initState(N1), $t}, nextStateID(N2).
}.



//  rules of bisimulation03
//  module使用、system_ruleset未使用
obseq_input{$i, @i}/ :- 
  preprocess{
    $i.
    
    L = [X1, X2|T] :- X1 > X2 | L = [X2, X1|T].
    initState(X), initState(Y) :- X =< Y | compare(X, Y).
    transition(From1, Label1, To1), transition(From2, Label2, To2) :- 
      From1 = From2, Label1 = Label2, To1 = To2 | 
      transition(From1, Label1, To1).
  }.

preprocess{stateSet(List), $p, @p}/ :- 
  ground(List) | 
  mk_arc{
    mk_arc(List), $p.
    
    mk_arc([]) :- .
    mk_arc([H|T]) :- arc(H, []), mk_arc(T).
    
    transition(From1, Label, To), arc(From2, List) :- 
      int(To), Label \= 0, From1 = From2 | 
      arc(From2, [label(Label, [To])|List]).
    L = [label(Label1, List1), label(Label2, List2) | T] :- 
      Label1 > Label2 | 
      L = [label(Label2, List2), label(Label1, List1) | T].
    L = [label(Label1, List1), label(Label2, List2) | T] :- 
      Label1 = Label2 | 
      L = [label(Label1, list.append(List1, List2)) | T].
  }, 
  product{
    product1(List).
    
    product1([]) :- .
    product1([H|T]) :- int(H) | product1([p1(H) | T]), pair(H, H).
    R = [p1(X) | []] :- int(X) | R = [].
    R = [p1(X), H|T] :- int(X), int(H) | R = [H, p1(X) | T], pair(X, H).
  }.

mk_arc{$m, @m}/, product{$p[], @p}/ :- 
  w_bisimulation{
    w_bisimulation(no).
    factory{
      $m.
      work{$p[]. pair(L, R) :- L = R | .}.
      prev{$p[]}.
      next{$p[]. flag(0)}.
      
      work{pair(I, J), $w, @w}, arc(I0, List0), arc(J1, List1) :- 
        ground(List0), ground(List1), I = I0, J = J1 | 
        work{checking, $w, @w}, arc(I0, List0), arc(J1, List1), 
        check1(I, J, List0, List1).
      check1(I, J, [], []), work{checking, $w, @w} :- 
        int(I), int(J) | 
        work{$w, @w}.
      check1(I, J, List0, []), work{checking, $w, @w}, 
      next{flag(F), pair(NI, NJ), $n} :- 
        ground(List0), int(F), I = NI, J = NJ | 
        work{$w, @w}, next{flag(1), $n}.
      check1(I, J, [], List1), work{checking, $w, @w}, 
      next{flag(F), pair(NI, NJ), $n} :- 
        ground(List1), int(F), I = NI, J = NJ | 
        work{$w, @w}, next{flag(1), $n}.
      check1(I, J, [label(X0, X0List) | List0], [label(X1, X1List) | List1]), 
      work{checking, $w, @w}, next{flag(F), pair(NI, NJ), $n} :- 
        ground(X0List), ground(List0), ground(X1List), ground(List1), int(F), 
        X0 \= X1, I = NI, J = NJ | 
        work{$w, @w}, next{flag(1), $n}.
      check1(I, J, [label(X0, X0List) | List0], [label(X1, X1List) | List1]) :- 
        ground(X0List), ground(X1List), X0 = X1 | 
        check2(
          I, J, List0, List1, 
          { product2(X0List, X1List).
            mk_node(X0List).
            mk_node(X1List).
            mk_node([]) :- .
            mk_node([H|T]) :- node(H, 1), mk_node(T).
            product2([], List) :- ground(List) | .
            product2([H|T], List) :- product2(T, [p2(H) | List]).
            R = [p2(X) | []] :- int(X) | R = [].
            R = [p2(X) | [H|T]] :- 
              X =< H | 
              pair(X, H), R = [H, p2(X) | T].
            R = [p2(X) | [H|T]] :- 
              X > H | 
              pair(H, X), R = [H, p2(X) | T].
          }
        ).
      check2(
        I, J, List0, List1, 
        {pair(CL, CR), node(NL, LF), node(NR, RF), $c, @c}/
      ),
      prev{pair(PL, PR), $p} :- 
        ground(List0), ground(List1), int(LF), int(RF), int(I), int(J), 
        CL = PL, CR = PR, CL = NL, CR = NR | 
	      check2(I, J, List0, List1, {node(NL, 0), node(NR, 0), $c, @c}), 
	      prev{pair(PL, PR), $p}.
      check2(I, J, List0, List1, {@c}) :- check1(I, J, List0, List1).
    }.
    factory{check2(I, J, List0, List1, {pair(L, R), $c, @c}), $f, @f}/ :- 
      ground(List0), ground(List1), int(I), int(J), int(L), int(R) | 
      factory{check2(I, J, List0, List1, {$c, @c}), $f, @f}.
    factory{check2(I, J, List0, List1, {node(N, 0), $c, @c}), $f, @f}/ :- 
      ground(List0), ground(List1), int(I), int(J), int(N) | 
      factory{check2(I, J, List0, List1, {$c, @c}), $f, @f}.
    factory{
      check2(I, J, List0, List1, {node(N, 1), $c[], @c}), 
      work{checking, $w, @w}, next{pair(IN, JN), flag(F), $n}, $f, @f
    }/ :- 
      ground(List0), ground(List1), int(N), int(F), I = IN, J = JN | 
      factory{work{$w, @w}, next{flag(1), $n}, $f, @f}.
    factory{prev{$p[]}, work{@w}, next{flag(1), $n[]}, $f, @f}/ :- 
      factory{prev{$n[]}, work{$n[], @w}, next{flag(0), $n[]}, $f, @f}.
    factory{
      prev{$p[]}, work{@w}, next{flag(0), pair(L, R), $n[]}, 
      compare(CL, CR), $f, @f
    }/, 
    w_bisimulation(no) :- 
      L = CL, R = CR | 
      factory{
        prev{$n[]}, work{$n[], @w}, next{flag(0), pair(L, R), $n[]}, 
        compare(CL, CR), $f, @f
      }, 
      w_bisimulation(yes).
  }.

w_bisimulation{
  factory{next{flag(F), $n, @n}, $f[], @f}, 
  w_bisimulation(W), $w[], @w
}/ :- 
  unary(W), int(F) | 
  obseq_result{w_bisimulation(W), w_bisimilar{$n}}.
