//  rules of bisimulation01
//  module使用、system_ruleset未使用
/*
input{
  state_set([1,2,3,4,5,6,7,8,9,10,11,12]).
  compare(1,7).
  transition(1,1,2).
  transition(1,1,3).
  transition(2,2,4).
  transition(2,2,5).
  transition(3,2,6).
  transition(4,3,4).
  transition(5,3,5).
  transition(6,4,6).
  transition(7,1,8).
  transition(7,1,9).
  transition(8,2,10).
  transition(9,2,11).
  transition(9,2,12).
  transition(10,3,10).
  transition(11,4,11).
  transition(12,4,12).
}.
*/

/*
input{
  state_set([1,2,3,4,5,6,7,8,9,10,11,12]).
  compare(1,7).
  transition(1,1,2).
  transition(1,1,3).
  transition(2,2,4).
  transition(2,2,5).
  transition(3,2,6).
  transition(4,3,4).
  transition(5,4,5).
  transition(6,4,6).
  transition(7,1,8).
  transition(7,1,9).
  transition(8,2,10).
  transition(9,2,11).
  transition(9,2,12).
  transition(10,3,10).
  transition(11,3,11).
  transition(12,4,12).
}.
*/

/*
input{
  state_set([1,2,3,4,5,6]).
  compare(1,4).
  transition(1,1,2).
  transition(1,1,3).
  transition(2,2,2).
  transition(3,3,3).
  transition(4,1,5).
  transition(4,1,6).
  transition(5,3,5).
  transition(6,2,6).
}.
*/


input{
  state_set([1,2,3,4,5,6]).
  compare(1,4).
  transition(1,1,6).
  transition(1,1,3).
  transition(2,2,2).
  transition(3,3,3).
  transition(4,1,5).
  transition(4,1,2).
  transition(5,3,5).
  transition(6,2,6).
}.


input{$i} :- 
  preprocess{
    $i.
    
    L = [X1, X2|T] :- 
      X1 > X2 | 
      L = [X2, X1|T].
    compare(X, Y) :- 
      X > Y | 
      compare(Y, X).
  }.

preprocess{state_set(List), $p, @p}/ :- 
  ground(List) | 
  mk_arc{
    mk_arc(List), $p.
    
    mk_arc([]) :- .
    mk_arc([H|T]) :- arc(H, []), mk_arc(T).
    
    transition(From1, Label, To), arc(From2, List) :- 
      int(Label), int(To), From1 = From2 | 
      arc(From2, [label(Label, [To])|List]).
    L = [label(Label1, List1), label(Label2, List2) | T] :- 
      Label1 > Label2 | 
      L = [label(Label2, List2), label(Label1, List1) | T].
    L = [label(Label1, List1), label(Label2, List2) | T] :- 
      Label1 = Label2 | 
      L = [label(Label1, list.append(List1, List2)) | T].
  }, 
  nC2{
    nC2(List).
    
    nC2([]) :- .
    nC2([H|T]) :- nC2([nc(H) | T]).
    R = [nc(X) | []] :- int(X) | R = [].
    R = [nc(X), H|T] :- int(X), int(H) | R = [H, nc(X) | T], pair(X, H).
  }.

mk_arc{$m, @m}/, nC2{$n[], @n}/ :- 
  bisimulation{
    bisimulation(no).
    factory{
      $m.
      prev{$n[]}.
      copy{$n[]}.
      next{$n[], flag(0)}.
      
      copy{pair(I, J), $c}, arc(I0, List0), arc(J1, List1) :- 
        ground(List0), ground(List1), I = I0, J = J1 | 
        copy{f, $c}, arc(I0, List0), arc(J1, List1), 
        check1(I, J, List0, List1).
      check1(I, J, [], []), copy{f, $copy} :- 
        int(I), int(J) | 
        copy{$copy}.
      check1(I, J, List0, []), copy{f, $c}, 
      next{flag(F), pair(NI, NJ), $n} :- 
        ground(List0), int(F), I = NI, J = NJ | 
        copy{$c}, next{flag(1), $n}.
      check1(I, J, [], List1), copy{f, $c}, 
      next{flag(F), pair(NI, NJ), $n} :- 
        ground(List1), int(F), I = NI, J = NJ | 
        copy{$c}, next{flag(1), $n}.
      check1(I, J, [label(X0, X0List) | List0], [label(X1, X1List) | List1]), 
      copy{f, $c}, next{flag(F), pair(NI, NJ), $n} :- 
        ground(X0List), ground(List0), ground(X1List), ground(List1), int(F), 
        X0 \= X1, I = NI, J = NJ | 
        copy{$c}, next{flag(1), $n}.
      check1(I, J, [label(X0, X0List) | List0], [label(X1, X1List) | List1]) :- 
        ground(X0List), ground(X1List), X0 = X1 | 
        check2(
          I, J, List0, List1, 
          { t(X0List, X1List).
            mk_node(X0List).
            mk_node(X1List).
            mk_node([]) :- .
            mk_node([H|T]) :- node(H, 1), mk_node(T).
            t([], List) :- ground(List) | .
            t([H|T], List) :- t(T, [tt(H) | List]).
            R = [tt(X) | []] :- int(X) | R = [].
            R = [tt(X) | [H|T]] :- 
              int(X), int(H) | 
              pair(X, H), R = [H, tt(X) | T].
          }
        ).
      check2(
        I, J, List0, List1, 
        {pair(CL, CR), node(NL, LF), node(NR, RF), $c, @c}
      ),
      prev{pair(PL, PR), $p} :- 
        ground(List0), ground(List1), int(LF), int(RF), int(I), int(J), 
        CL = PL, CR = PR, CL = NL, CR = NR | 
	      check2(I, J, List0, List1, {node(NL, 0), node(NR, 0), $c, @c}), 
	      prev{pair(PL, PR), $p}.
      check2(I, J, List0, List1, {@c}) :- check1(I, J, List0, List1).
    }.
    factory{check2(I, J, List0, List1, {node(N, 0), $c, @c}), $f, @f}/ :- 
      ground(List0), ground(List1), int(I), int(J), int(N) | 
      factory{check2(I, J, List0, List1, {$c, @c}), $f, @f}.
    factory{
      check2(I, J, List0, List1, {node(N, 1), $check2[], @check2}), 
      copy{f, $copy}, next{pair(IN, JN), flag(F), $n}, $f, @f
    }/ :- 
      ground(List0), ground(List1), int(N), int(F), I = IN, J = JN | 
      factory{copy{$copy}, next{flag(1), $n}, $f, @f}.
    factory{check2(I, J, List0, List1, {pair(L, R), $c, @c}), $f, @f}/ :- 
      int(I), int(J), int(L), int(R), ground(List0), ground(List1) | 
      factory{check2(I, J, List0, List1, {$c, @c}), $f, @f}.
    factory{prev{$p[]}, copy{}, next{flag(1), $n[]}, $f, @f}/ :- 
      factory{prev{$n[]}, copy{$n[]}, next{flag(0), $n[]}, $f, @f}.
    factory{
      prev{$p[]}, copy{}, next{flag(0), pair(L, R), $n[]}, 
      compare(CL, CR), $f, @f
    }/, 
    bisimulation(no) :- 
      L = CL, R = CR | 
      factory{
        prev{$n[]}, copy{$n[]}, next{flag(0), pair(L, R), $n[]}, 
        compare(CL, CR), $f, @f
      }, 
      bisimulation(yes).
  }.

bisimulation{
  factory{next{flag(F), $n, @n}, $f[], @f}, 
  bisimulation(B), $r[], @r
}/ :- 
  unary(B), int(F) | 
  result{bisimulation(B), bisimilar{$n}}.
