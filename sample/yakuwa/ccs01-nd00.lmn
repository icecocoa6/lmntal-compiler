//  rules of ccs01-nd00
//  module未使用、system_ruleset未使用

input{$i, @i}, rules{$r, @r} :- 
  factory{ccs{$i, @i}, $r, @r}.

factory{transitions{$t}, $f[], @f}/ :- result{$t}.

rules{
  //  状態のコピー
  system{copy(0, 0), $r[], @r} :- 
    system{copy(0, 1), $r[], @r}, system{copy(1, 1), $r[], @r}.
    
  //  rules of ccs101-mc
  //  module未使用、system_ruleset未使用
  
  //  事前処理
  ccs{$r, @r} :- 
    //  外部に送信
    ( system{
        {{send(C1, {$q1}), $p1}, $q2}, 
        {name(CN), +C1, $c}, state(S1), copy(1, 1), $r1, @r1
      }/, 
      system{state(S2), copy(0, 1), $r2, @r2}, 
      transitions{$t}, next(N1) :- 
        int(CN), T = CN, S1 = S2, N2 = N1 + 1, uniq(S1, CN) | 
        system{
          memkill({$p1}, killed), {name(CN), $c}, {$q1, $q2}, 
          state(N1), copy(0, 0), $r1, @r1
        }, 
        system{state(S2), copy(0, 0), $r2, @r2}, 
        transitions{transition(S1, T, N1), $t}, next(N2)
    ), 
    
    //  外部から受信
    ( system{
        {{receive(C1, {$q1}), $p1}, $q2}, 
        {name(CN), +C1, $c}, state(S1), copy(1, 1), $r1, @r1
      }/, 
      system{state(S2), copy(0, 1), $r2, @r2}, 
      transitions{$t}, next(N1) :- 
        int(CN), T = -CN, S1 = S2, N2 = N1 + 1, uniq(S1, CN) | 
        system{
          memkill({$p1}, killed), {name(CN), $c}, {$q1, $q2}, 
          state(N1), copy(0, 0), $r1, @r1
        }, 
        system{state(S2), copy(0, 0), $r2, @r2}, 
        transitions{transition(S1, T, N1), $t}, next(N2)
    ), 
    
    //  明示的な内部動作
    ( system{
        {{internal({$q1}), $p1}, $q2}, state(S1), copy(1, 1), $r1, @r1
      }/, 
      system{state(S2), copy(0, 1), $r2, @r2}, 
      transitions{$t}, next(N1) :- 
        S1 = S2, N2 = N1 + 1, uniq(S1) | 
        system{
          memkill({$p1}, killed), {$q1, $q2}, 
          state(N1), copy(0, 0), $r1, @r1
        }, 
        system{state(S2), copy(0, 0), $r2, @r2}, 
        transitions{transition(S1, 0, N1), $t}, next(N2)
    ), 
    
    //  異なるRestriction膜内で大域チャネルによる送受信
    ( system{
        {{send(C1, {$q1}), $p1}, $q2}, 
        {{receive(C2, {$q3}), $p2}, $q4}, 
        {name(CN), +C1, +C2, $c}, state(S1), copy(1, 1), $r1, @r1
      }/, 
      system{state(S2), copy(0, 1), $r2, @r2}, 
      transitions{$t}, next(N1) :- 
        S1 = S2, N2 = N1 + 1, uniq(CN) | 
        system{
          memkill({$p1, $p2}, killed), {name(CN), $c}, 
          {$q1, $q2}, {$q3, $q4}, state(N1), copy(0, 0), $r1, @r1
        }, 
        system{state(S2), copy(0, 0), $r2, @r2}, 
        transitions{transition(S1, 0, N1), $t}, next(N2)
    ), 
    
    //  同一Restriction膜内で大域チャネルによる送受信
    ( system{
        {{send(C1, {$q1}), $p1}, {receive(C2, {$q2}), $p2}, $q3}, 
        {name(CN), +C1, +C2, $c}, state(S1), copy(1, 1), $r1, @r1
      }/, 
      system{state(S2), copy(0, 1), $r2, @r2}, 
      transitions{$t}, next(N1) :- 
        S1 = S2, N2 = N1 + 1, uniq(CN) | 
        system{
          memkill({$p1, $p2}, killed), {name(CN), $c}, 
          {$q1, $q2, $q3}, state(N1), copy(0, 0), $r1, @r1
        }, 
        system{state(S2), copy(0, 0), $r2, @r2}, 
        transitions{transition(S1, 0, N1), $t}, next(N2)
    ), 
    
    //  同一Restriction膜内で局所チャネルによる送受信
    ( system{
        {
          {send(C1, {$q1}), $p1}, {receive(C2, {$q2}), $p2}, 
          {name(CN), +C1, +C2, $c}, $q3
        }, 
        state(S1), copy(1, 1), $r1, @r1
      }/, 
      system{state(S2), copy(0, 1), $r2, @r2}, 
      transitions{$t}, next(N1) :- 
        S1 = S2, N2 = N1 + 1, uniq(CN) | 
        system{
          memkill({$p1, $p2}, killed), 
          {{name(CN), $c}, $q1, $q2, $q3}, 
          state(N1), copy(0, 0), $r1, @r1
        }, 
        system{state(S2), copy(0, 0), $r2, @r2}, 
        transitions{transition(S1, 0, N1), $t}, next(N2)
    ), 
    
    ( system{@r}, action(A) :- ground(A) | action(end) ), 
    
    system{
      //  選択されなかった動作の削除
      memkill({$p, @p}) :- memkill({$p, @p}, killed).
      memkill({$p[], @p}, KillTag) :- 
        unary(KillTag) | .
      memkill({$p[X|*Z], @p}, KillTag) :- 
        unary(KillTag) | 
        memkill({$p[Y|*Z], killing(Y), @p}, KillTag), X = KillTag.
        
      //  同一チャネル膜の併合
      {name(CN1), $c1}, {name(CN2), $c2} :- 
        CN1 = CN2 | {name(CN1), $c1, $c2}.
      {{name(CN1), $c1}, {name(CN2), $c2}, $q} :- 
        CN1 = CN2 | {{name(CN1), $c1, $c2}, $q}.
        
      //  使用済みチャネル膜の削除
      {name(CN)} :- unary(CN) | .
      {{name(CN)}, $q} :- unary(CN) | {$q}.
      
      //  killedアトムと接続子の削除
      killed({$c}) :- {$c}.
      killed(C), {{+C, $c}, $q} :- {{$c}, $q}.
      
      //  動作終了
      {} :- .
      {{}, $q} :- {$q}.
      {{nil, $p}, $q} :- {{$p}, $q}.
      state(0), copy(0, 0), $r, @r
    }.
    
  transitions{}, next(1).
}.

input{
/*
//  proc P = '1.('2.3.nil | (2.nil + t.nil))
{{p}}.
{{p, $p}, $q} :- 
  {
    { send(C11, 
      {
        { send(C21, 
          {
            { receive(C31, {{ nil }}) }
          })
        }, 
        { receive(C22, {{ nil }}), 
          internal({{ nil }})
        }
      }), 
      $p
    }, 
    $q
  }, 
  {name(1), +C11}, {name(2), +C21, +C22}, {name(3), +C31}.
*/


//  proc P = ('1.nil + 2.nil) | ('1.nil + 3.nil)
{q}.
{q, $q} :- 
  {
    { send(C11, {{ nil }}), 
      receive(C21, {{ nil }})
    }, 
    { send(C12, {{ nil }}), 
      receive(C31, {{ nil }})
    }, 
    $q
  }, 
  {name(1), +C11, +C12}, {name(2), +C21}, {name(3), +C31}.

}.
