% 神経衰弱．
% といっても，一度めくったカードを覚えないバージョン．
% 生成時の"indexing"は，カードの位置を決めていると思ってくれ．
% 一度めくったカードを覚えておくには，どうしたらいいだろう．
% マークと数字から位置への対応付けを記憶膜とかに放り込んでおく，とかだと
% 記憶をほじくり返すのが重い処理になってしまう．
% 参照を直接カードに突っ込まないと意味がない気がする．

% カードを生成する
field={
gen_all.
gen_all :- gen(13,spade),gen(13,club),gen(13,heart),gen(13,diamond).
gen(N,Mark) :- unary(Mark),N>0 | gen(N-1,Mark), card(N,Mark).
gen(N,Mark) :- unary(Mark),N=0 | ().
indexing(52).
indexing(N),card(CN,Mark) :- N>0|indexing(N-1),card(CN,Mark,N).
indexing(N)               :- N=0|().
}.

% プレイヤの循環リスト
L=[p|L].

% cは手持ち札で，神経衰弱では2枚が限度．なのでペアなら0に戻す．
% pcはペアの数．つまり取った札/2．
player_rule={
card(N1,Mark1,I1),card(N2,Mark2,I2),c(C),  pc(PC) :- N1=N2,int(C),int(I1),int(I2) |
pair(N1,Mark1,         Mark2),c(C-2),pc(PC+1).
}.

%プレイヤを追加する
add_players(2). 

add_players(P)  ,L=[p                |R],player_rule={@r} :- P>0 |
add_players(P-1),L=[p,{c(0),pc(0),@r}|R],player_rule={@r}.
add_players(P) :- P=0 | ().

% 一枚目をめくる．
field={card(N,M,I),$f,@f},L=[p,{            c(C),  $p,@p}|R] :-
int(C),C=0,int(N),unary(M),int(I)|
field={            $f,@f},L=[p,{card(N,M,I),c(C+1),$p,@p}|R].

% 二枚目をめくる．
field={card(N,M,I),$f,@f},L=[p,{            c(C),  $p,@p}|R] :-
int(C),C=1,int(N),unary(M),int(I)|
field={            $f,@f},L=[p,{card(N,M,I),c(C+1),$p,@p}|R].

% 二枚たまったら場に返して（ペアを作るルールは子膜で優先），次の人の番．
field={$f,@f},L=[p,{card(N1,M1,I1),card(N2,M2,I2),     c(C),  $p,@p}/  |R] :-
int(C),C=2,int(N1),unary(M1),int(I1),int(N2),unary(M2),int(I2)|
field={$f,@f,       card(N1,M1,I1),card(N2,M2,I2)},L=[{c(C-2),$p,@p},p|R].

% 場に札が無くなったら終了．
field={@f} :- endgame.

% 枚数の多い人順のリストを作る．

endgame,L=[p|R] :- players=R,L=[].

winners=[].

players=[{pc(PC),$p,@p}|REST],winners=PCS :- int(PC) | players=REST,winners=[pc(PC,M)|PCS],M={$p}.
players=[] :- sort.

% バブルソート
sort,L=[pc(PC1,M1),pc(PC2,M2)|REST] :- PC1<PC2 | 
sort,L=[pc(PC2,M2),pc(PC1,M1)|REST].
