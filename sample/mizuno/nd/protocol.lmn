//Needham-Schroderの公開鍵プロトコル

//nonce 生成
next_nonce(0).

//命令
conn_to(1,p1,p2).   // p1は、p2に接続するための状態1にいる
conn_from(1,p2,p1). // p2は、p1から接続をいけるための状態1にいる

conn_to(1,p1,p3).   // 攻撃者に対して接続してしまう
conn_to(1,p2,p3).
conn_from(1,p1,p3). // 攻撃者から接続を受け付ける
conn_from(1,p2,p3).

//鍵交換
//A -> B : {Na,A}B
k1@@next_nonce(N), conn_to(1,SID1,SID2) :- unary(SID1),unary(SID2),N2=N+1 | 
	next_nonce(N2),conn_to(2,SID1,SID2,N),packet(SID1,SID2,enc(SID2,[nonce(N),id(SID1)])).
//B -> A : {Na,Nb}A
k2@@next_nonce(N2),conn_from(1,SID2,SID1), packet(ID1,ID2,enc(EID2,[nonce(N),id(PID1)])) :- ID1=PID1,ID1=SID1,ID2=EID2,ID2=SID2,unary(N),N3=N2+1 | 
	next_nonce(N3),conn_from(2,SID2,SID1,N,N2), packet(ID1,ID2,enc(EID2,[nonce(N),id(PID1)])), packet(ID2,ID1,enc(ID1,[nonce(N),nonce(N2)])).
//A -> B : {Nb}B
k3@@conn_to(2,SID1,SID2,SN), packet(ID2,ID1,enc(EID1,[nonce(N1),nonce(N2)])) :- ID1=SID1,ID2=SID2,ID1=EID1,SN=N1,unary(N2) |
	conn_to(3,SID1,SID2,SN,N2), packet(ID2,ID1,enc(EID1,[nonce(N1),nonce(N2)])), packet(ID1,ID2,enc(ID2,[nonce(N2)])).
k4@@conn_from(2,SID2,SID1,SN1,SN2), packet(ID1,ID2,enc(EID2,[nonce(N)])) :- SID1=ID1,SID2=ID2,SN2=N,EID2=ID2 |
	conn_from(3,SID2,SID1,SN1,SN2), packet(ID1,ID2,enc(EID2,[nonce(N)])).

//攻撃者
conn_to(1,p3,p1).
conn_to(1,p3,p2).
conn_to(1,p3,p1,p2).  //p3が、p1のふりをしてp2に接続
conn_to(1,p3,p2,p1).

//A -> B : {Na,A}B
i11@@next_nonce(N), conn_to(1,SID3,SID1,SID2) :- unary(SID1),unary(SID2),unary(SID3),N2=N+1 | 
	 next_nonce(N2),conn_to(2,SID3,SID1,SID2,N),packet(SID1,SID2,enc(SID2,[nonce(N),id(SID1)])),know(SID3,N).						//自分で新規にノンスを生成して接続
i12@@packet(X,Y,enc(EID3,[nonce(N)|Z])), conn_to(1,SID3,SID1,SID2) :- unary(SID1),unary(SID2),SID3=EID3,unary(N) | 
	 packet(X,Y,enc(EID3,[nonce(N)|Z])), conn_to(2,SID3,SID1,SID2,N),packet(SID1,SID2,enc(SID2,[nonce(N),id(SID1)])),know(SID3,N).	//受け取ったノンスで接続1
i13@@packet(X,Y,enc(EID3,[Z,nonce(N)])), conn_to(1,SID3,SID1,SID2) :- unary(SID1),unary(SID2),SID3=EID3,unary(N) | 
	 packet(X,Y,enc(EID3,[Z,nonce(N)])), conn_to(2,SID3,SID1,SID2,N),packet(SID1,SID2,enc(SID2,[nonce(N),id(SID1)])),know(SID3,N).	//受け取ったノンスで接続2
i14@@packet(PID1,PID2,Data), conn_to(1,SID3,SID1,SID2) :- unary(SID1),PID1=SID1,PID2=SID2,ground(Data) | 
	 packet(PID1,PID2,Data), conn_to(2,SID3,SID1,SID2,unknown),packet(SID1,SID2,Data).												//暗号化されたパケットを再利用
//A -> B : {Nb}B
i31@@conn_to(2,SID3,SID1,SID2,SN),   next_nonce(N) :- unary(SID1),unary(SID2),unary(SID3),N2=N+1|
	 conn_to(3,SID3,SID1,SID2,SN,N), next_nonce(N2), packet(SID1,SID2,enc(SID2,[nonce(N)])), know(SID3,N).
i32@@conn_to(2,SID3,SID1,SID2,SN),   packet(X,Y,enc(EID3,[nonce(N)|Z])) :- SID3=EID3,unary(N),unary(SID1),unary(SID2),unary(SID3) |
	 conn_to(3,SID3,SID1,SID2,SN,N), packet(X,Y,enc(EID3,[nonce(N)|Z])), packet(SID1,SID2,enc(SID2,[nonce(N)])), know(SID3,N).
i33@@conn_to(2,SID3,SID1,SID2,SN),   packet(X,Y,enc(EID3,[Z,nonce(N)])) :- SID3=EID3,unary(N),unary(SID1),unary(SID2),unary(SID3) |
	 conn_to(3,SID3,SID1,SID2,SN,N), packet(X,Y,enc(EID3,[Z,nonce(N)])), packet(SID1,SID2,enc(SID2,[nonce(N)])), know(SID3,N).
i34@@conn_to(2,SID3,SID1,SID2,SN),   packet(PID1,PID2,Data) :- PID2=SID2,PID1=SID1,ground(Data),unary(SID1),unary(SID2),unary(SID3) |
	 conn_to(3,SID3,SID1,SID2,SN,unknown), packet(PID1,PID2,Data), packet(SID1,SID2,Data).

//攻撃成功
conn_to(  3,ID1,ID2,N11,N12),know(p3,N21),know(p3,N22) :- N11=N21,N12=N22,unary(ID1),unary(ID2) | fail.
conn_from(3,ID2,ID1,N11,N12),know(p3,N21),know(p3,N22) :- N11=N21,N12=N22,unary(ID1),unary(ID2) | fail.
