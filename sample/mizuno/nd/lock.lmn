M={
	nd.exec({{
		thread(n,1).
		thread(n,2).
	
		critical(0).
		thread(n,T1) :- thread(w,T1).
		thread(w,T1),critical(0) :- thread(c,T1),critical(1).
		%thread(c,T1),critical(1) :- thread(n,T1),critical(0).
		thread(c,T1),thread(w,T2) :- thread(n,T1),thread(c,T2).
		thread(c,T1),thread(n,T2),critical(1) :- thread(n,T1),thread(n,T2),critical(0).
	}*}).
}.

check({$p,@p}/,[{$q,@q}|L]) :- check({$p,@p,$q,@q},L).
check({$p,@p},[]) :- {$p,@p}.

check(M,[C1,C2,C3]).

C1={
	//uniq用のID生成
	nextid(0).
	nextid(N), {$p,@p} :- \+($p=(id(X),$pp)), N2=N+1 | nextid(N2), {id(N),$p,@p}.
	//遷移のリスト化
	{id(N),$p,@p} :- uniq(N) | {id(N),fl([]),$p,@p}.
	reduce(F,T,R),{id(N),from(F),fl(FL),$p[FL|*W],@p},{id(N2),to(T),$q,@q} :- uniq(N,N2) |
		reduce(F,T,R),{id(N),from(F),fl([N2|FL]),$p[FL|*W],@p},{id(N2),to(T),$q,@q}.
}.
C2={
	//safety
	{id(N), {thread(c,T1),thread(c,T2),$p,@p}*, $q,@q} :- uniq(N) | fail(safety, N), {id(N), {thread(c,T1),thread(c,T2),$p,@p}*, $q,@q}.
	//liveness
	{id(N),{thread(c,T1),$p,@p}*,$q,@q} :- uniq(N,T1) | {id(N),fc(T1,true),{thread(c,T1),$p,@p}*,$q,@q}.
	{id(N),fl(L),{thread(S,T1),$p[S|*X],@p}*,$q,@q} :- \+($p=(c(S),$pp)),uniq(N,T1),ground(L) |
		{id(N),fl(L),check_fc(L,T1),fc(T1,false),{thread(S,T1),$p[S|*X],@p}*,$q,@q}.
	{check_fc([N|Tail],T1),$q[Tail|*Y],@q}, {id(N2),fc(T2,true),$r,@r} :- T1=T2,N=N2 |
		{check_fc(Tail,T1),$q[Tail|*Y],@q}, {id(N2),fc(T2,true),$r,@r}.
	{check_fc([],T1),fc(T2,false),$q,@q} :- T1=T2 | {fc(T1,true),$q,@q}.
}.
C3={
	{id(N),fc(T1,false),{thread(w,T2),$p,@p}*,$q,@q} :- T1=T2,uniq(N,T1) | {id(N),fc(T1,false),{thread(w,T2),$p,@p}*,$q,@q}, fail(liveness, N,T1).
}.
