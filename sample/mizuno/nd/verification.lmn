{
model.
nd.exec({{
%mem(Stable,Locked,Parent,Children,Stack,Lock)
mem(false, false, nil, [L1,L2], M1, nil).
mem(false, false, L1 , [L3]   , M2, nil).
mem(false, false, L2 , []     , M3, nil).
mem(false, false, L3 , []     , M4, nil).

state(start).

stack([M4,M3,M2,M1]).
%実行膜スタックの先頭を取得
state(start), stack([M|T]), mem(S,false,P,Ch,M,nil) :-
  state(locking), stack([M|T]), lock(mem(S,false,P,Ch,M)).
%ロック取得
state(locking), lock(mem(S,false,P,Ch,M)) :- 
  state(locking), lock2([Ch],[Ch2],[]),
  lock_list([mem(S,true,P,Ch2,M)]).
%本膜ロック失敗 : ロックが解放されるまで本膜取得→失敗を繰り返す
state(locking), lock(mem(S,true,P,Ch,M))
 :- state(start), mem(S,true,P,Ch,M,nil).
%本膜のルール適用終了
state(start), stack([M|T]), mem(S,LF,P,Ch,M,nil)
 :- unary(S) | state(check_stable), stack(T), mem(S2,LF,P,Ch2,nil,nil), check(Ch,Ch2,S2).
state(check_stable), check([H|T],Ch,S2), mem(true,L,H,CC,M,nil)
 :- state(check_stable), check(T,Ch2,S2), Ch=[H|Ch2], mem(true,L,H,CC,M,nil).
state(check_stable), check([H|T],Ch,S2), mem(false,L,H,CC,M,nil)
 :- state(check_stable), Ch=[H|T],S2=false, mem(false,L,H,CC,M,nil).
state(check_stable), check([],Ch,S2)
 :- state(start), Ch=[], S2=true.

state(locking), lock2([[]|L1],[M|L2],T)
 :- state(locking), lock2(L1,L2,[]), M = T.
%ロック成功
state(locking), lock2([[M|LL1]|L1],[Mr|L2],T), mem(S,false,M,Ch,St,nil), lock_list(L)
  :- state(locking), lock2([LL1,Ch|L1],[Mr,Mr2|L2],[M|T]), lock_list([mem(S,true,M,Mr2,St)|L]).
%ロック失敗
state(locking), lock2([[M|LL1]|L1],[Mr|L2],T), mem(S,true,M,Ch,St,nil)
 :- state(lock_fail), lock2([[M|LL1]|L1],[Mr|L2],T), mem(S,true,M,Ch,St,nil).
%ロックしない
state(locking), lock2([[M|LL1]|L1],[Mr|L2],T), mem(S,LF,M,Ch,St,nil)
  :- unary(LF) | state(locking), lock2([LL1|L1],[Mr|L2],[M|T]), mem(S,false,M,Ch,St,nil).
state(locking), lock2([],[],[]) :- state(activate).
state(locking), lock2([],[],[]) :- state(not_matched).
%ロックした膜のロック解放・活性化
state(activate), lock_list([mem(S,true,P,Ch,nil),M2|L]), stack(St)
 :- state(activate), lock_list([M2|L]), mem(S,false,P,Ch,M,nil), stack([M|St]).
state(activate), lock_list([mem(S,true,P,Ch,M),M2|L]), X=[M|Y]
 :- state(activate), lock_list([M2|L]), mem(S,false,P,Ch,M,nil), X=[M|Y].
state(activate), lock_list([mem(S,true,P,Ch,M)])
 :- state(start), mem(S,false,P,Ch,M,nil).
state(not_matched), lock_list([mem(S,true,P,Ch,St),M2|L])
 :- state(not_matched), lock_list([M2|L]), mem(S,false,P,Ch,St,nil).
state(not_matched), lock_list([mem(S,true,P,Ch,M)])
 :- state(start), mem(S,false,P,Ch,M,nil).

%ロック失敗後の後始末
state(lock_fail), lock2([LL1|L1],[Mr|L2],[TH|TT])
 :- state(lock_fail), lock2([[TH|LL1]|L1],[Mr|L2],TT).
state(lock_fail), lock2([H1|T1],[H2|T2],[])
 :- state(lock_fail), H2=H1, lock2(T1,T2,[]).
state(lock_fail), lock2([],[],[]) :- state(lock_fail2).
state(lock_fail2), lock_list([mem(S,true,M,Ch,St)|L])
 :- state(lock_fail2), mem(S,false,M,Ch,St), lock_list(L).
state(lock_fail2), lock_list([]) :- state(start).
}*}).
}.

{model,$p,@p}/, {check,$q,@q} :- {$p,@p,$q,@q}.

{check.
//uniq用のID生成
nextid(0).
nextid(N), {$p,@p} :- \+($p=(id(X),$pp)), N2=N+1 | nextid(N2), {id(N),$p,@p}.

//終了状態検出
{id(I),$p,@p} :- \+($p=(from(T),$pp)),uniq(I) | {id(I),$p,@p}, end(I).

//終了状態で満たすべき性質の検証
end(E), {{mem(false,LF,P,C,S,L),$q[LF,P,C,S,L],@q}*,id(I),$p,@p} :- E=I,uniq(I) |
	{{mem(false,LF,P,C,S,L),$q[LF,P,C,S,L],@q}*, id(I),$p,@p}, fail(I).
end(E), {{mem(St,true,P,C,S,L),$q[St,P,C,S,L],@q}*,id(I),$p,@p}  :-E=I,uniq(I) |
	{{mem(St,true,P,C,S,L),$q[St,P,C,S,L],@q}*, id(I),$p,@p}, fail2(I)
}. 
