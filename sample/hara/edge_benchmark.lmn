// e(E0, E1), e(E1, E2), e(E2, E0) ==> loop(E0, E1, E2).
// e(0, 1), e(1, 2), e(2, 0), e(0, 3), e(3, 2).



workset={
	io.use.
	arg=sys.argv.
	arg=[] :- res=print("\n\n** Usage <this program> <NumVertices> <DataTpye : int or link> **\n\n").
	arg=[_SNumVertices, _SDataType] :- 
	vertices = string.int_of_str(_SNumVertices), dataType = _SDataType.
	
	vertices=_IV :- uniq | vertices=_IV, gen(integer.rndList(_IV, _IV*10)).
	vertices=_IV, dataType="link", linkRules={@r} :- uniq |
	vertices=_IV, dataType="link", genMem(_IV), @r.
	
	gen([]) :-.
	gen([A,B|T]) :- e(A, B), gen(T).
	e(A, B) :- A=B |.
	linkRules={
		genMem(0) :-.
		genMem(N) :- N>0, M=N-1 | genMem(M), {id(M)}.
		e(_I0, _I1), {id(N0),$p0}, {id(N1),$p1} :- N0=_I0, N1=_I1 |
		e(E0, E1), {+E0,id(N0),$p0}, {+E1,id(N1),$p1}.
	}.
	int_rule = {
		LoopInt@@
		e(E00, E10), e(E11, E20), e(E21, E01)
			:- E00=E01, E10=E11, E20=E21, uniq(E00, E10, E20) |
		e(E00, E10), e(E11, E20), e(E21, E01), loop(E00, E10, E20).
	}.
	link_rule = {
//		LoopLink@@
//		e(E00, E10), e(E11, E20), e(E21, E01),
//		{+E00,+E01,id(N0),$p0},{+E10,+E11,id(N1),$p1},{+E20,+E21,id(N2),$p2},
//			:- uniq(N0, N1, N2) |
//		e(E00, E10), e(E11, E20), e(E21, E01),
//		{+E00,+E01,id(N0),$p0},{+E10,+E11,id(N1),$p1},{+E20,+E21,id(N2),$p2},
//		loop(N0, N1, N2).
		LoopLink@@
		e(E00, E10), e(E11, E20), e(E21, E30), e(E31, E40), e(E41, E01),
		{+E00,+E01,id(N0),$p0},
		{+E10,+E11,id(N1),$p1},
		{+E20,+E21,id(N2),$p2},
		{+E30,+E31,id(N3),$p3},
		{+E40,+E41,id(N4),$p4},
			:- uniq(N0, N1, N2, N3, N4) |
		e(E00, E10), e(E11, E20), e(E21, E30), e(E31, E40), e(E41, E01),
		{+E00,+E01,id(N0),$p0},
		{+E10,+E11,id(N1),$p1},
		{+E20,+E21,id(N2),$p2},
		{+E30,+E31,id(N3),$p3},
		{+E40,+E41,id(N4),$p4},
		loop(N0, N1, N2, N3, N4).
	}.
	A@@go, dataType="int",  int_rule={@r}  :- dataType="int",  @r.
	B@@go, dataType="link", link_rule={@r} :- dataType="link", @r.
}.

io.use.
workset={$e, @e}/ :- time=timer.benchmark({$e, @e}).
time=_F :- res=print(string.join("", ["",string.str_of_float(_F),""])).

