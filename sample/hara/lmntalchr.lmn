/*
----------------------------------------------------------------------
CHR
                                              Koji Hara
                                              2005/10/18(火) 23:03:38
                                              2005/10/24(月) 14:26:43

操作的意味論をそのまま LMNtal で書いてみたもの

関連：
 http://www.ueda.info.waseda.ac.jp/localpage/siryou2005/embeddingCHRinLMNtal.ppt
 Operational Semantics and Confluence of Constraint Propagation Rules[Abd97]
----------------------------------------------------------------------




State : <Gs, Cu, cb, T, V>
	Gs : ゴールストア : Set of c=制約 | eq/2
	Cu : ユーザ定義制約ストア : Set of c=制約
	Cb : 組み込み制約ストア
	T  : トークン : Set of ルール名 | c=反応できるユーザ定義制約
	V  : Gs, Cu, Cb に出てくる変数 : 未使用
	
	実装:
		state : states(Gs, Cu, Cb, T, V).
		Gs={c=制約, eq(変数, 変数), ...}.
		Cu={c=制約, ...}.
		Cb={eq(変数, 変数), ...}.
		T ={ {rule=ルール名, c=制約, ...}, ... }.
		V ={}.
		token : 

Initial :
	<Gx, T, true, 0, V>

Final :
	<T, Cu, Cb, T, V> with false not \in Cb
	<Gs, Cu, false, T, V>


組み込み制約は、今のところ eq のみ

*/

/*

----------------------------------------------------------------------
HISTORY / 備忘録
----------------------------------------------------------------------

コマンドライン例
$ java -cp bin runtime/FrontEnd -x dump 1 --interpret --use-source-library sample/hara/chr.lmn -t | perl tohtml.pl .* +prop > result.html


★マークがついたルールは CHR プログラムに依存（要手動コンパイル）


◆等式伝播

Cb に eq(a, b) があって Cu に leq(a, b) などがある場合、a=b だから leq(a, a) などと伝播させなければならない。
意味論では正規化関数でやっている。nstate を追加。


◆トークンの計算方法

token/2 は ground と膜を受け取ってトークンを計算し、同レベルに展開する。

leq の例だと偶然うまくいっていたが、Token の計算が不完全だったので修正した。
T(C, Cu) は {C, Cu} の中から Propagation rule の左辺にマッチするものを全て出力する。
実装は {C, Cu} 内にルールを置いて、マッチしたものを別の膜に入れて出力としている。
これだと {C, Cu} 内で反応したものは消えてしまうので、本来計算されるべきものが計算されていない可能性がある。

例：
r3 @ leq(X, Y), leq(Y, Z) ==> leq(X, Z).
{C, Cu} = leq(a, b), leq(b, c), leq(c, d)

の時

T(C, Cu) = { r3@{X=a, Y=b, Z=c}, r3@{X=b, Y=c, Z=d} }

となるべきだが１個だけしか返されていなかった。

解決案
ある Propagation rule の左辺の要素数（アトムグループ数）が k 個の時、
Cu から選ばれるのは k-1 個。（C は新しく追加されたものなのでマッチするなら必ず含まれる）
count(Cu) 個から k-1 個を選ぶ全通りについて左辺とマッチするか調べればよい。


気づいたこと：

- LMNtal はルール間で引数を引きまわすため、複数ルールに対する引数仕様の変化に弱い。
-- 関数呼び出し（の気分）した際の引数は、とりあえず全部最初の引数につないだ膜とかに入れておくと後で使えるので新たに使う引数が出てきたときに複数ルールの書き直しが必要なくなる。。
- 対象データがリストになってないと嫌な部分と、膜内の多重集合になってた方がいい部分がある。簡単に変換できると便利。
--１個のデータを入れた膜をリストの要素にすればいい。list=[{a}, {b}].
---が、こういうリストは ground じゃないので扱いが悪い。こういうものにマッチする型付きプロセス文脈がほしい。

続き：
k-1 個の選び方リストまではうまくいっている。それぞれに対してどういう膜を生成するかから始めること。
2005/10/23(日) 02:17:55

うまくいった。edge の例題も書いてみること。
2005/10/24(月) 02:20:31

*/

{ module(lmntalchr).


Solve @@
state({eq(X, Y), $gs}, {$cu[], @cu}, {eq=[], $cb}, {$t, @t}, {$v})
:- unary(X), unary(Y) | 
nstate({$gs}, {$cu[], @cu}, {eq=[X,Y], eq(X, Y), $cb}, {$t, @t}, {$v}).


Introduce @@
state({c_=Con, $gs}, {$cu[], @cu}, {$cb}, {$t, @tr}, {$v})
:- ground(Con) | 
tstate({$gs}, {c_=Con, $cu[], @cu}, {$cb}, {$t, token({c_store. c_=Con}, {$cu[]}), @tr}, {$v}).





//----------------------------------------------------------------------
// Normalize - '=' の伝播
//----------------------------------------------------------------------

Eq @@
nstate({$gs}, {$cu[], @cu}, {eq=[], $cb}, {$t, @tr}, {$v})
:- 
state({$gs}, {$cu[], @cu}, {eq=[], $cb}, {$t, @tr}, {$v}).


Eq @@
nstate({$gs}, {$cu[], @cu}, {eq=[X], $cb}, {$t, @tr}, {$v})
:- unary(X) |
state({$gs}, {$cu[], @cu}, {eq=[], $cb}, {$t, @tr}, {$v}).


Eq @@
nstate({$gs}, {$cu[], @cu}, {eq=[A,B|R], $cb[R]}, {$t, @tr}, {$v})
:- unary(A), unary(B) | 
nstate1({$gs}, {replace(B, A), $cu[], @cu}, {eq=[A|R], $cb[R]}, {$t, @tr}, {$v}).


Eq @@
nstate1({$gs}, {replace(B, A), $cu[], @cu}/, {$cb}, {$t, @tr}, {$v})
:- unary(A), unary(B) | 
nstate({$gs}, {$cu[], @cu}, {$cb}, {$t, @tr}, {$v}).


Terminate @@
H={ state({}, {$cu[], @cu}, {eq=[], $cb}, {$t[], @tr}, {$v[]}), $etc[], @etc }/
:-
H={$cu[], $cb}.

Start @@
H=chr.run({$gs}, {@simplify}, {@replace}, {@find_token}, Prop_head_count) :- int(Prop_head_count) |
H={
	chr.use.
	solve.
	introduce.
	simplify.
	propagate.
	@simplify.
	state(Gs, Cu, Cb, T, V).
	Gs={$gs}.
	Cu={
		@replace.
	}.
	Cb={eq=[]}.
	T={
		found_token.
		prop_head_count=Prop_head_count.
		
		// token/2 - トークンを計算する
		token({c_store. $c[]}, {$cu[]}) :- token0({{c_store. $c[]}, {$cu[]}}, {list=[], $cu[]}).
		
		// リスト処理するためにリスト化
		token0(ARG, {list=L, c_=Con, $c[L]}) :- ground(Con) | 
		token0(ARG, {list=[Con|L], $c[L]}).
		
		token0(ARG, {list=L}), prop_head_count=N :- ground(L), int(N) | 
		token1(ARG, {list=list.choose_k(L, N-1)}, {}), prop_head_count=N.
		
		// 候補を作る
		token1({{c_store. c_=Con}, {$cu[]}}, {list=[Hd|Tl], $p[Tl], @r}, {$w}) :- ground(Hd), ground(Con) | 
		token1({{c_store. c_=Con}, {$cu[]}}, {list=Tl, $p[Tl], @r}, {$w, {l=Hd, l=Con}}).
		
		token1(ARG, {list=[], @r}, {$w}) :- |
		token2(ARG, {$w}).
		
		@find_token.
		
	}.
	V={}.
	// トークン計算が終わったら次
	TokenFinished @@
	tstate(Gs, Cu, Cb, {$p, token2({{$c[]}, {$cu[]}}, {$w[]}), @r}/, V) :- 
	nstate(Gs, Cu, Cb, {$p, @r}, V).
}.

}. // End of CHR module



