//  Coyright(C) 2006 Ueda Laboratory LMNtal Group, All rights reserved.
//  Author: mizuno

ret=sort(gen(100)).

R=sort([D|L]), heap({$p,@p}) :- int(D) | R=sort(L), heap({insert(D),$p,@p}).
R=sort([]   ), heap({$p,@p}) :- R=sort2, heap({$p,@p}).
R=sort2,       heap({$p,@p}) :- R=[remove({$p,@p})|sort2].
R=[remove({root=R,leaves([R|L],L),@p}/)|sort2] :- R=[].

/**
 * R=remove(Heap)
 * 先頭要素を除去する。
 * @param Heap ヒープ膜
 * @param R    除去した先頭要素の出力先
 */
R=remove({root=c(C1,C2,VT), leaves(F,L), L2=[R1,R2|L], c(R1,R2,VL,P), $p[C1,C2,F,L2,P|*X], @p}/)
	:- int(VT), int(VL) | R=VT, heap({root=c(C1,C2,VL), leaves([P|F],L2), $p[C1,C2,F,L2,P|*X], @p}).
R=remove({root=c(R1,R2,VT), leaves([R1,R2|L],L), @p}/)
	:- int(VT) | R=VT, heap({root=R, leaves([R|L],L), @p}).

// ヒープ膜。c(Child1, Child2, Value, Parent) によって木構造を作る。
heap({
root=R. leaves([R|L], L).

/**
 * ヒープ条件
 * ヒープ条件を満たさない要素があったら、修正する。
 */
c(C1,c(C2,C3,V2),V1,P) :- V2 < V1 | c(C1,c(C2,C3,V1),V2,P).
c(c(C2,C3,V2),C1,V1,P) :- V2 < V1 | c(c(C2,C3,V1),C1,V2,P).

/**
 * insert(V)
 * ヒープに要素を追加する。
 * @param V 追加する要素
 */
insert(V), root=R, leaves([R|L], L) :- root=c(R1,R2,V), leaves([R1,R2|L], L).
insert(V), leaves([R|T], L) :- R=c(R1,R2,V), leaves(T, L2), L=[R1,R2|L2].
}).

/**
 * R=gen(N)
 * 乱数リスト生成。integerモジュールを利用しています。
 * @param N 生成するリストの長さを表す整数アトム
 * @param R 生成したリストの出力先
 */
R=gen(N) :- N > 0 | R=[integer.rnd(100)|gen(N-1)].
R=gen(N) :- N = 0 | R=[].

