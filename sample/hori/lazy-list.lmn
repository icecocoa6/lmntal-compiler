// 要素はgroundでないとだめ。

// 遅延評価に膜を使っているのでとにかく遅い。Haskellの10000倍くらい遅い気がする。
// 膜を使っているので、リストのコピーや消去ができない。(すべてforce済みならその限りではない)

{
module(lazy_list).

//////////////////////////////////////////////////////////////////////
// 基本
//////////////////////////////////////////////////////////////////////

// この辺とかモジュールの外に公開したくない
force @@
H=lazy_list.force(lazy_list.forced(L)) :- H=L.
H=lazy_list.force(lazy_list.lazy_mem({@p, $p})) :-
    H=X, apply{@p. $p. call(X)}.

// 連結していないアトムも取り出される。
apply @@
apply{@r. $h[|*L]}/ :-  $h[|*L].
// 自由リンクがある場合これだと取り出せない。
// H=apply_mem{@r. result($r). }/ :- H=$r.

identity @@
lazy_list.identity :- {H=','(N) :- H=N}.

// 空のリスト
empty @@
H=lazy_list.empty :- H=lazy_list.forced(lazy_list.nil).

is_empty @@
H=lazy_list.is_empty(L, Org) :- H=lazy_list.is_empty_sub(lazy_list.force(L), Org).
H=lazy_list.is_empty_sub(lazy_list.nil, Org) :- H=true, Org=lazy_list.empty.
H=lazy_list.is_empty_sub(lazy_list.tuple(A,L), Org) :- H=false, Org=lazy_list.cons(A, L).

// head @@
// H=lazy_list.head(L) :- H=lazy_list.head_sub(lazy_list.force(L)).
// //H=lazy_list.head_sub(lazy_list.nil) :- H=lazy_list.error("empty list -- lazy_list").
// H=lazy_list.head_sub(lazy_list.tuple(A,L)) :- H=A, to_delete(L).

tail @@
H=lazy_list.tail(L) :- H=lazy_list.tail_sub(lazy_list.forace(L)).
// nilの場合の処理はどうする？
H=lazy_list.tail_sub(lazy_list.tuple(A,L)) :- ground(A) | H=L.

// いい名前は?
head_and_tail @@
lazy_list.head_and_tail(L,H,T) :- lazy_list.head_and_tail_sub(lazy_list.force(L), H, T).
lazy_list.head_and_tail_sub(lazy_list.tuple(A,L),H,T) :- H=A, T=L.

cons @@
H=lazy_list.cons(A, L) :-  H=lazy_list.forced(lazy_list.tuple(A, L)).

// 要素が一つだけのリスト
single @@
H=lazy_list.single(A) :- H=lazy_list.cons(A, lazy_list.empty).

length @@
H=lazy_list.length(L, M) :- H=lazy_list.length_sub(lazy_list.force(L), M).
H=lazy_list.length_sub(lazy_list.nil, M) :- H=0, M=lazy_list.empty.
H=lazy_list.length_sub(lazy_list.tuple($a,L),M) :- ground($a) |
    H=1+lazy_list.length_sub(lazy_list.force(L), N), M=lazy_list.cons($a, N).

append @@
H=lazy_list.append(L, R) :-
    H=lazy_list.lazy_mem({a(L, R).
                          a(L, R), call(H) :- 
                              H=lazy_list.append_sub(lazy_list.force(L), R).}).
H=lazy_list.append_sub(lazy_list.nil, R) :- H=lazy_list.force(R).
H=lazy_list.append_sub(lazy_list.tuple(A,L), R) :- H=lazy_list.tuple(A, (lazy_list.append(L, R))).

// take @@
// H=lazy_list.take(N, L) :- N =< 0 | H=lazy_list.empty, to_delete(L).
// H=lazy_list.take(N, L) :- N > 0 |
//     H=lazy_list.lazy_mem({a(L,N).
//                           a(L,N), call(H) :- 
//                                H=lazy_list.take_sub(N, lazy_list.force(L)).}).
// H=lazy_list.take_sub(N, lazy_list.nil) :- int(N) |  H=lazy_list.empty.
// H=lazy_list.take_sub(N, lazy_list.tuple(A,L)) :-
//     H=lazy_list.cons(A, lazy_list.take(N-1, L)).

split_at @@
lazy_list.split_at(N, L, Left, Right) :- N =< 0 | Left=lazy_list.empty, Right=L.
lazy_list.split_at(N, L, Left, Right) :- N > 0 |
   Left=lazy_list.lazy_mem({a(L,N,Right).
                             a(L,N,Right), call(H) :- 
                             lazy_list.split_at_sub(N, lazy_list.force(L), H, Right).}).
lazy_list.split_at_sub(N, lazy_list.nil, Left, Right) :- int(N) |
    Left=lazy_list.nil, Right=lazy_list.empty.
lazy_list.split_at_sub(N, lazy_list.tuple(A,L), Left, Right) :- 
    lazy_list.split_at(N-1, L, Left2, Right), Left=lazy_list.tuple(A, Left2).


//////////////////////////////////////////////////////////////////////
// 変換
//////////////////////////////////////////////////////////////////////


map @@
H=lazy_list.map({@p. $p}, L) :-
    H=lazy_list.lazy_mem({ a(L). {@p, $p}.
                           a(L), {@p, $p}, call(H) :-
                              H=lazy_list.map_sub({@p, $p}, lazy_list.force(L))}).
H=lazy_list.map_sub({@p, $p[]}, lazy_list.nil) :- H=lazy_list.nil.
H=lazy_list.map_sub({@p. $p[]}, lazy_list.tuple($a,L)) :- ground($a) |
    H=lazy_list.tuple(A, lazy_list.map({@p, $p[]}, L)),
      apply{@p. $p[], A=','($a)}.

// 長さが同じリストに対しては、定義はできている。
// しかし、独立して使うわけではなく、transposeのためのものなので、コメントアウト
// [ [a1, a2, ...], [b1, b2, ...], ...] => ([a1, b2, ...], [[a2, ...], [b2, ...] ...])
// skim @@
// lazy_list.skim(L, Heads, Tails) :- lazy_list.skim_sub(lazy_list.force(L), Heads, Tails).
// lazy_list.skim_sub(lazy_list.nil, Heads, Tails) :- Heads=lazy_list.empty, Tails=lazy_list.empty.
// lazy_list.skim_sub(lazy_list.tuple(A,L), Heads, Tails) :-
//     lazy_list.skim_sub2(lazy_list.force(A), L, Heads, Tails).
// lazy_list.skim_sub2(lazy_list.tuple(A,L), L2, Heads, Tails) :-
//     Heads=lazy_list.cons(A, Heads2),
//     Tails=lazy_list.cons(L, Tails2),
//     lazy_list.skim_sub(lazy_list.force(L2), Heads2, Tails2).



// きれいに定義できなそう
// transpose @@
// Hl=lazy_list.transpose(L) :-
//     A=lazy_list.all_i({ 
//     Hl=lazy_list.transpose_sub(lazy_list.force(L)).
// Hl=lazy_list.transpose_sub(lazy_list.nil) :- Hl=lazy_list.empty.
// Hl=lazy_list.transpose_sub(lazy_list.tuple(A,L)) :-
//     Hl=lazy_list.transpose_sub2(

    

//////////////////////////////////////////////////////////////////////
// 構築
//////////////////////////////////////////////////////////////////////

// [x, x, ... ]
repeat @@
H=lazy_list.repeat($a) :- ground($a) |
    H=lazy_list.lazy_mem({ a($a).
                         a($a), call(H) :- ground($a) |
                         H=lazy_list.tuple($a, lazy_list.repeat($a)).}).

// [x, f x, f (f x), ...]
iterate @@
H=lazy_list.iterate({@p. $p[]}, $x) :- ground($x) |
    H=lazy_list.forced(lazy_list.tuple($x, L)),
    L=lazy_list.lazy_mem({a({@p. $p[]}, $x).
                          a({@p. $p[]}, $x), call(H) :- ground($x) |
                              H=lazy_list.force(lazy_list.iterate({@p. $p[]}, A)),
                              apply{@p. $p[]. A=','($x)}.}).

// [start, start + step, start + step + step, ...]
// いい名前は?
int_sequence @@
H=lazy_list.int_sequence($start, $step) :- int($start), int($step) |
    H=lazy_list.lazy_mem({a($start, $step).
                          a($start, $step), call(H) :-  int($start), int($step) |
                             H=lazy_list.tuple($start, lazy_list.int_sequence($start+$step, $step)).}).


lazy_list.copy_ground($x, A, B)  :- ground($x) | $x[A], $x[B].

//  scanl f z [x1, x2, ...] == [z, f z x1, f (f z x1) x2, ...]
scanl @@
H=lazy_list.scanl({@p. $p[]}, $x, L) :- ground($x) |
    H= lazy_list.lazy_mem({a({@p. $p[]}, $x, L).
                            a({@p. $p[]}, $x, L), call(H) :-  ground($x) |
                                H=lazy_list.tuple($x, lazy_list.scanl_sub({@p. $p[]}, $x, Hd, Tl)),
                                lazy_list.head_and_tail(L, Hd, Tl).}).
// $h を膜の中に入れるためにルールを分離
H=lazy_list.scanl_sub({@p. $p[]}, $x, $h, Tl) :- ground($x), ground($h) |
    H=lazy_list.scanl({@p. $p[]}, A, Tl),
    apply{@p, $p[], A=','($x, $h)}.


//////////////////////////////////////////////////////////////////////
// Reducing
//////////////////////////////////////////////////////////////////////

foldl @@
H=lazy_list.foldl({@p, $p[]}, $a, L) :- ground($a) |
  H=lazy_list.foldl_sub({@p. $p[]}, $a, lazy_list.force(L)).
H=lazy_list.foldl_sub({@p, $p[]}, A, lazy_list.nil) :- H=A.
H=lazy_list.foldl_sub({@p, $p[]}, $a, lazy_list.tuple($b, L)) :- ground($a), ground($b) |
    H=lazy_list.foldl_sub({@p, $p[]}, A, lazy_list.force(L)),
    apply{@p, $p[], A=','($a, $b)}.

unfoldr @@
Hl=lazy_list.unfoldr({@p, $p[]}, $a) :- ground($a) |
  Hl=lazy_list.lazy_mem({a({@p, $p[]}, $a).
                         a({@p, $p[]}, $a), call(Hf) :- ground($a) |
                            Hf=lazy_list.unfoldr_sub({@p. $p[]}, A),
                            apply{@p. $p[]. A=','($a)}.}).
Hf=lazy_list.unfoldr_sub({@p, $p[]}, false) :- Hf=lazy_list.nil.
Hf=lazy_list.unfoldr_sub({@p, $p}, ','(A, B)) :-
    Hf=lazy_list.tuple(A, lazy_list.unfoldr({@p. $p}, B)).


// all_i(f, [x1, x2, ...], Org) == f x1 && f x2 && ...,   Org=[x1, x2, ...]
all_i @@
H=lazy_list.all_i({@p. $p}, L, Org) :-
    H=lazy_list.all_i_sub({@p. $p}, lazy_list.force(L), Org).
H=lazy_list.all_i_sub({@p. $p[]}, lazy_list.nil, Org) :- H=true, Org=list.empty.
H=lazy_list.all_i_sub({@p. $p[]}, lazy_list.tuple($a,L), Org) :- ground($a) |
    H=lazy_list.all_i_sub2({@p. $p[]}, A, L, Org2),
    apply{@p. $p[]. A=','($a)},
    Org=lazy_list.cons($a, Org2).
H=lazy_list.all_i_sub2({@p. $p[]}, true, L, Org) :-
    H=lazy_list.all_i_sub({@p. $p[]}, lazy_list.force(L), Org).
H=lazy_list.all_i_sub2({@p. $p[]}, false, L, Org) :- H=false, Org=L.

                                  
//////////////////////////////////////////////////////////////////////
//  探索
//////////////////////////////////////////////////////////////////////

filter @@
H=lazy_list.filter({@p. $p}, L) :-
    H=lazy_list.lazy_mem({a({@p. $p}, L).
                          a({@p. $p}, L), call(H) :-
                           H=lazy_list.filter_sub({@p, $p}, lazy_list.force(L)).}).
H=lazy_list.filter_sub({@p. $p[]}, lazy_list.nil) :- H=lazy_list.nil.
H=lazy_list.filter_sub({@p. $p[]}, lazy_list.tuple($a,L)) :- ground($a) |
    H=lazy_list.filter_sub2(A, {@p. $p[]}, $a, L),
    apply{@p. $p[]. A=','($a)}.
H=lazy_list.filter_sub2(true, {@p. $p}, A, L) :-
    H=lazy_list.tuple(A, lazy_list.filter({@p. $p}, L)).
H=lazy_list.filter_sub2(false, {@p. $p}, A, L) :- ground(A) |
    H=lazy_list.filter_sub({@p. $p}, lazy_list.force(L)).

// parition(f, L, X, Y) == X=filter(f, L), Y=filter(not f, L).
// Yの方（条件が偽）のほうはXがforceした位置までしかとりだせない。
partition @@
lazy_list.partition({@p. $p}, L, X, Y) :-
    X=lazy_list.lazy_mem({a({@p. $p}, L, Y).
                          a({@p. $p}, L, Y), call(H) :-
                           lazy_list.partition_sub({@p, $p}, lazy_list.force(L), H, Y).}).
lazy_list.partition_sub({@p. $p[]}, lazy_list.nil, X, Y) :- X=lazy_list.nil, Y=lazy_list.empty.
lazy_list.partition_sub({@p. $p[]}, lazy_list.tuple($a,L), X, Y) :- ground($a) |
    lazy_list.partition_sub2(A, {@p. $p[]}, $a, L, X, Y),
    apply{@p. $p[]. A=','($a)}.
lazy_list.partition_sub2(true, {@p. $p}, A, L, X, Y) :-
    X=lazy_list.tuple(A, X2),
    lazy_list.partition({@p. $p}, L, X2, Y).
lazy_list.partition_sub2(false, {@p. $p}, A, L, X, Y) :-
    Y=lazy_list.forced(lazy_list.tuple(A, Y2)),
    lazy_list.partition_sub({@p. $p}, lazy_list.force(L), X, Y2).

// クイックでないクイックソート
// あれ、さっきまで動いてたのに
// qsort @@
// H=lazy_list.qsort(L) :- H=lazy_list.qsort_sub(lazy_list.force(L)).
// H=lazy_list.qsort_sub(lazy_list.nil) :- H=lazy_list.empty.
// H=lazy_list.qsort_sub(lazy_list.tuple($a,L)) :- ground($a) |
//     lazy_list.partition({  a($a). a(n($a)), H=','($n) :- $n<$a | H=true.
//                                   a(n($a)), H=','($n) :- $a=<$n | H=false.
//                        }, L, Left, Right),
//     H=lazy_list.append(lazy_list.qsort(Left), lazy_list.append(lazy_list.single($a),
//                                                                 lazy_list.qsort(Right))).

// マージソート
sort @@
Hl=lazy_list.sort({@p. $p[]}, L) :-
    Hl=lazy_list.sort_lp({@p. $p[]},
                         lazy_list.force(lazy_list.map({H=','(A):-H=lazy_list.single(A)}, L))).

Hl=lazy_list.sort_lp({@p. $p[]}, lazy_list.nil) :- Hl=lazy_list.empty.
Hl=lazy_list.sort_lp({@p. $p[]}, lazy_list.tuple(A, L)) :-
    Hl=lazy_list.sort_lp2({@p. $p[]}, A, lazy_list.force(L)).
Hl=lazy_list.sort_lp2({@p. $p[]}, A, lazy_list.nil) :- Hl=A.
Hl=lazy_list.sort_lp2({@p. $p[]}, A, lazy_list.tuple(B, L)) :-
    Hl=lazy_list.sort_lp({@p. $p[]},
                         lazy_list.force(lazy_list.sort_mp({@p. $p[]}, A, B, lazy_list.force(L)))).

Hl=lazy_list.sort_mp({@p. $p[]}, A, B, lazy_list.nil) :- 
    Hl=lazy_list.single(lazy_list.merge({@p. $p[]}, A, B)).
Hl=lazy_list.sort_mp({@p. $p[]}, A, B, lazy_list.tuple(C, L)) :-
    Hl=lazy_list.cons(lazy_list.merge({@p. $p[]}, A, B),
                      lazy_list.sort_mp2({@p. $p[]}, C, lazy_list.force(L))).
Hl=lazy_list.sort_mp2({@p. $p[]}, A, lazy_list.nil) :- Hl=lazy_list.single(A).
Hl=lazy_list.sort_mp2({@p. $p[]}, A, lazy_list.tuple(B, L)) :- 
    Hl=lazy_list.sort_mp({@p. $p[]}, A, B, lazy_list.force(L)).


merge @@
Hl=lazy_list.merge({@p. $p[]}, A, B) :-
    Hl=lazy_list.lazy_mem({a({@p. $p[]}, A, B).
                           a({@p. $p[]}, A, B), call(Hf) :- 
                              Hf=lazy_list.merge_sub({@p. $p[]},
                                                     lazy_list.force(A),
                                                     lazy_list.force(B)). }).
Hf=lazy_list.merge_sub({@p. $p[]}, lazy_list.nil, Lf) :- Hf=Lf.
Hf=lazy_list.merge_sub({@p. $p[]}, Lf, lazy_list.nil) :- Hf=Lf.
Hf=lazy_list.merge_sub({@p. $p[]}, lazy_list.tuple($a, Al), lazy_list.tuple($b, Bl)) :-
    ground($a), ground($b) |
        Hf=lazy_list.merge_sub2({@p. $p[]}, R, $a, Al, $b, Bl),
        apply{@p. $p[]. R=','($a, $b)}.
Hf=lazy_list.merge_sub2({@p. $p[]}, true, A, Al, B, Bl) :-
    Hf=lazy_list.tuple(A, lazy_list.merge({@p. $p[]}, Al, lazy_list.cons(B, Bl))).
Hf=lazy_list.merge_sub2({@p. $p[]}, false, A, Al, B, Bl) :-
    Hf=lazy_list.tuple(B, lazy_list.merge({@p. $p[]}, lazy_list.cons(A, Al), Bl)).


// 構造変換

of_list @@
H=lazy_list.of_list([]) :- H=lazy_list.empty.
H=lazy_list.of_list([Hd|Tl]) :- H=lazy_list.cons(Hd, lazy_list.of_list(Tl)).

to_list @@
H=lazy_list.to_list(L) :- H=lazy_list.to_list_sub(lazy_list.force(L)).
H=lazy_list.to_list_sub(lazy_list.nil) :- H=[].
H=lazy_list.to_list_sub(lazy_list.tuple(A,L)) :- H=[A|lazy_list.to_list_sub(lazy_list.force(L))].


//////////////////////////////////////////////////////////////////////
// その他
//////////////////////////////////////////////////////////////////////

force_list @@
Org=lazy_list.force_list(L) :- Org=lazy_list.force_list_sub(lazy_list.force(L)).
Org=lazy_list.force_list_sub(lazy_list.nil) :- Org=lazy_list.empty.
Org=lazy_list.force_list_sub(lazy_list.tuple(A,L)) :-
    lazy_list.force_list_sub(lazy_list.force(L), Org2),
    Org=lazy_list.cons(A, Org2).

}.


// Map=lazy_list.map({H=','(N):-int(N) | H=N+100}, lazy_list.int_sequence(0, 10)).
// map=lazy_list.to_list(Left), lazy_list.split_at(10, Map, Left, right).

// Iterate=lazy_list.iterate({H=','(N):-int(N)|H=N*2}, 1).
// iterate=lazy_list.to_list(Left), lazy_list.split_at(10, Iterate, Left, right).

// Merged=lazy_list.merge({H=','(A, B) :- A<B | H=true.
//                         H=','(A, B) :- A>=B | H=false.},
//                        lazy_list.of_list([1,3,4,5,6,7,8]),
//                        lazy_list.of_list([1,2, 3,4,5,6,7,8])).
// merged=lazy_list.to_list(Merged).


// Sorted=lazy_list.sort({H=','(A,B):-A<B|H=true.
//                        H=','(A,B):-A>=B|H=false.},
//                       lazy_list.of_list([1,2,3,4,1,2,35,1,2,3,5,6,4,1,1,2,3,4,6,1,1,1])).
// sorted=lazy_list.to_list(Sorted).


// Scanl=lazy_list.scanl({H=','(A,B) :-  H=A+B}, 0, lazy_list.int_sequence(1, 1)).
// scanl=lazy_list.to_list(Left), lazy_list.split_at(10, Scanl, Left, right).

// Filter=lazy_list.filter({ H=','(A) :- A mod 2 =:= 1 | H=true.
//                           H=','(A) :- A mod 2 =:= 0 | H=false.},
//                         lazy_list.int_sequence(0, 1)).
// filter=lazy_list.to_list(Left), lazy_list.split_at(10, Filter, Left, right).

// Append=lazy_list.append(lazy_list.of_list([1,2,3]), lazy_list.of_list([4,5,6])).
// append=lazy_list.to_list(Left), lazy_list.split_at(10, Append, Left, right).

// len=lazy_list.length(lazy_list.of_list([1,2,3,4,5]), Org).
// org=lazy_list.to_list(Org).

// qsort=lazy_list.to_list(lazy_list.qsort(lazy_list.of_list([3,2,1,-1,10,2]))).

// lazy_list.partition({ H=','(N) :- N =< 20 | H=true.
//                       H=','(N) :- N > 20 | H=false.},
//                     lazy_list.of_list([1,10,15,20,25,30]),
//                                       x, y).
// x(L) :- r=lazy_list.to_list(L).
// y(L) :- s=lazy_list.to_list(L).

// single=lazy_list.to_list(lazy_list.single(10)).

// foldl=lazy_list.foldl({H=','(A, B) :- C=A*B | H=C}, 1, lazy_list.of_list([1,2,3,4,5])).

// L=lazy_list.repeat(lazy_list.of_list([1,2,3])),
// lazy_list.split_at(5, L, Left, right),
// lazy_list.skim(Left, Heads, Tails),
// lazy_list.skim(Tails, Heads2, tails2),
// heads=lazy_list.to_list(Heads), tails=lazy_list.to_list(Heads2).

// positive=lazy_list.all_i({ H=','(N) :- N>0 | H=true.
//                            H=','(N) :- N>0 | H=false.},
//                          lazy_list.of_list([1,2,3]),
//                          org).

// L=lazy_list.map({H=','([A,B]):-int(A), int(B)|H=B},
//                 lazy_list.iterate({ H=','([A,B]):-C=A+B|H=[B,C] }, [0,1])),
// lazy_list.split_at(10, L, Left ,right),
// fibonacci=lazy_list.to_list(Left).

// Iter=lazy_list.scanl({ io.use.
//                        H=','(done,N) :- H=io.println(N). },
//                      done,
//                      lazy_list.int_sequence(1, 3)).
// lazy_list.split_at(10, Iter, Left, right),
// left=lazy_list.to_list(Left).

// Unfoldr=lazy_list.unfoldr({ H=','(N) :- int(N) | H=','(N,N+1)},
//                           0).
// lazy_list.split_at(10, Unfoldr, Left, right),
// left=lazy_list.to_list(Left).


//////////////////////////////////////////////////////////////////////
// CAT コマンド
//////////////////////////////////////////////////////////////////////

// io.use.
// io.stdin($input) :- ground($input) |
//     lines=lazy_list.unfoldr({input($input).
//                              H=','(done), input(Input) :- io.readline(Input, Line, Done), H=read(Line, Done).
//                              H=read(Line, done) :-  H=','(Line, done).
//                              H=read(Line, nil)  :- ground(Line) | H=false.},
//                             done).
   
// lines(Lines), io.stdout($output) :- ground($output) |
//     r=lazy_list.foldl({out($output).
//                        H=','(done,Str), out(Output) :- H=io.println(Output, Str). },
//                      done,
//                      Lines).
