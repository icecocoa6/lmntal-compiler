%%% General Rules

{
module(general).
system_ruleset.

dup(A, B, C) :- int(A) |  B=A, C=A.
dup(A, B, C, D) :- int(A) | B=A, C=A, D=A.
dup(A, B, C, D, E) :- int(A) | B=A, C=A, D=A, E=A.

dup([], B, C) :- B=[], C=[].
dup([H|T], B, C) :-
  dup(H, H0, H1),
  dup(T, T0, T1),
  B=[H0|T0], C=[H1|T1].

dup(A, B, C), {+A, $p[], @p} :-
  {+B, $p[], @p},
  {+C, $p[], @p}.

dup_ref({$p}, B, C) :- |  {+B,+C, $p}.
dup_ref({$p}, B, C, D) :- |  {+B,+C,+D, $p}.

del(X) :- ground(X) | .
del({$p[], @p}) :- | .
del({$p[L0], @p}) :- | del(L0).
del({$p[L0,L1], @p}) :- | del(L0), del(L1).
del({$p[L0,L1,L2], @p}) :- | del(L0), del(L1), del(L2).

del([]) :- .
del([H|T]) :- del(H), del(T).

%%% List

H=append(A, B) :- H=appendl([A,B]).
H=append(A, B, C) :- H=appendl([A,B,C]).
H=append(A, B, C, D) :- H=appendl([A,B,C,D]).

R=appendl([]) :- R=[].
R=appendl([[]|T0]) :- R=appendl(T0).
R=appendl([[H|T]|T0]) :- R=[H|appendl([T|T0])].

R=length([]) :- R=t([], 0).
R=length([Head|Tail]) :-
  t(Tail0, N) = length(Tail),
  R=t([Head|Tail0],  N+1).

H=reverse(List) :- H=reverse(List, []).
H=reverse([], List) :- H=List.
H=reverse([Car|Cdr], List) :- H=reverse(Cdr, [Car|List]).

H=nth(0, [Car|Cdr]) :- ground(Cdr) | H=Car.
H=nth(I, [Car|Cdr]) :- ground(Car), I>0 | H=nth(I-1, Cdr).

R=fold({i(X,K), {$p[X,K,O]}, o(O)}, Knil, []) :- R=Knil.
R=fold({i(X,K), {$p[X,K,O]}, o(O)}, Knil, [H|T]) :-
  R=fold({i(X,K), {$p[X,K,O]}, o(O)}, $p[H,Knil], T).

R=foldr({i(X,K), {$p[X,K,O]}, o(O)}, Knil, []) :- R=Knil.
R=foldr({i(X,K), {$p[X,K,O]}, o(O)}, Knil, [H|T]) :-
  Y=foldr({i(X,K), {$p[X,K,O]}, o(O)}, Knil, T),
  $p[H,Y,R].

map({i(I), {$p[I,O]}, o(O)}, [], R) :- R = [].
map({i(I), {$p[I,O]}, o(O)}, [H0|T], R0) :-
    R0 = [H|R], $p[H0,H],
    map({i(I), {$p[I,O]}, o(O)}, T, R).

%%% Arithmetic

'+'(A,B,C) :- D=A+B | D=C.
'-'(A,B,C) :- D=A-B | D=C.
'*'(A,B,C) :- D=A*B | D=C.
'/'(A,B,C) :- D=A/B | D=C.

R=inc(A) :- int(A) | R=A+1.
R=dec(A) :- int(A) | R=A-1.

%%% Tuple

t(R0, R1) = t(L0,L1) :- L0=R0, L1=R1.
t(R0, R1, R2) = t(L0,L1,L2) :- L0=R0, L1=R1, L2=R2.

%%% Function
%%% F := {i(I), o(O), $p[I,O], @p}
R=call1({i(I), o(O), $p[I,O|*L], @p}, X) :- $p[X,R|*L].

fdup @@
dup(A, B, C), {+A, i(I), o(O), $p[O,I], @p} :-
  {+B, i(I), o(O), $p[O,I], @p},
  {+C, i(I), o(O), $p[O,I], @p}.

%% Duplicate a function with free links, links have to
%% connect to functions only.
fdup1 @@
dup(A, B, C), {+A, i(I), o(O), $p[O,I,L0], @p} :-
  dup(L0, L00, L01),
  {+B, i(I), o(O), $p[O,I,L00], @p}, 
  {+C, i(I), o(O), $p[O,I,L01], @p}.
fdup2 @@
dup(A, B, C), {+A, i(I), o(O), $p[O,I,L0,L1], @p} :-
  dup(L0, L00, L01),
  dup(L1, L10, L11),
  {+B, i(I), o(O), $p[O,I,L00,L10], @p},
  {+C, i(I), o(O), $p[O,I,L01,L11], @p}.
fdup3 @@
dup(A, B, C), {+A, i(I), o(O), $p[O,I,L0,L1,L2], @p} :-
  dup(L0, L00, L01),
  dup(L1, L10, L11),
  dup(L2, L20, L21),
  {+B, i(I), o(O), $p[O,I,L00,L10,L20], @p},
  {+C, i(I), o(O), $p[O,I,L01,L11,L21], @p}.

del({i(I), o(O), $p[O,I], @p}) :- .
del({i(I), o(O), $p[O,I,L0], @p}) :- del(L0).
  

%%% Coercion

//R=int_to_float(N) :- R= integer.floatValue(N). %% Java Only
R=int_to_float(N) :- float.use, R= N+0.0. %% Java Only
float.use :- .

%%% Option
%%% none or some(X)

R=opt_get(none) :- R=none.
R=opt_get(some(X)) :- R=X.
R=opt_default(some(X),Y) :- del(Y), R=X.
R=opt_default(none, Y) :- R=Y.
R=is_none(none) :- R=true.
R=is_none(some(X)) :- ground(X) | R=false.
R=is_some(none) :- R=false.
R=is_some(some(X)) :- del(X), R=true.

}.

