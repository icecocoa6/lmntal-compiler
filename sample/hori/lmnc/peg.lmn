%%% Parser Expression Grammar Parser

{
module(peg).

general.use.

%%%======================================================================
%%% Stream
%%%

S=list_to_stream(L) :- S=stream(0,P), list_to_stream_sub(L,{+P},0).
list_to_stream_sub([$h|T], {$p}, $i) :- $j=$i+1, ground($h) |
  list_to_stream_sub(T, {$p, e($i,$h)}, $j).
list_to_stream_sub([], {$p}, $i) :- int($i) | {$p, n($i)}.

stream_dup(stream($i, S), S0, S1), {+S, $p} :- int($i) |
  S0=stream($i, L0),
  S1=stream($i, L1),
  {+L0, +L1, $p}.

S=stream_next(stream($i,S0)), {+S0, n($j), $p}  :- $i=:=$j |
  S=stream($i,S0), {+S0, n($j), $p}.
S=stream_next(stream($i,S0)), {+S0, n($j), $p}  :- $i<$j, $i0=$i+1 |
  S=stream($i0,S0), {+S0, n($j), $p}.

X=stream_ref(stream($i,S0)), {+S0, e($j,$x), $p} :- $i=:=$j, ground($x) |
  X=e($x), {e($i,$x), $p}.
X=stream_ref(stream($i,S0)), {+S0, n($j), $p} :- $i=:=$j |
  X=eof, {n($j), $p}.
R=stream_take(stream($i,S0)), {+S0, e($j,$x), $p} :-
    $i=:=$j, $i0=$i+1, ground($x) |
  R=t(e($x), stream($i0, S)), {+S, e($i,$x), $p}.
R=stream_take(stream($i,S0)), {+S0, n($j), $p} :- $i=:=$j |
  R=t(eof, stream($i, S)), {+S, n($j), $p}.

B=stream_ended(stream($i,S0)), {+S0, n($j), $p} :- $i=:=$j |
  B=true, {n($j), $p}.
B=stream_ended(stream($i,S0)), {+S0, n($j), $p} :- $i=<$j |
  B=false, {n($j), $p}.

del(stream(I, S)), {+S, $p} :- int(I) | {$p}.

%%%======================================================================
%%% Function
%%%

dup(A, B, C), {+A, p(P), $p[P,L0]} :-
  dup(L0, L00, L01),
  {+B, p(P), $p[P,L00]},
  {+C, p(P), $p[P,L01]}.
    
dup(A, B, C), {+A, p(P), $p[P,L0,L1]} :-
  dup(L0, L00, L01),
  dup(L1, L10, L11),
  {+B, p(P), $p[P,L00,L10]},
  {+C, p(P), $p[P,L01,L11]}.
dup(A, B, C), {+A, p(P), $p[P,L0,L1,L2]} :-
  dup(L0, L00, L01),
  dup(L1, L10, L11),
  dup(L2, L20, L21),
  {+B, p(P), $p[P,L00,L10,L20]},
  {+C, p(P), $p[P,L01,L11,L21]}.
dup(A, B, C), {+A, p(P), $p[P,L0,L1,L2,L3]} :-
  dup(L0, L00, L01),
  dup(L1, L10, L11),
  dup(L2, L20, L21),
  dup(L3, L30, L31),
  {+B, p(P), $p[P,L00,L10,L20,L30]},
  {+C, p(P), $p[P,L01,L11,L21,L31]}.
    
%%%======================================================================
%%% Entry Point
%%%

/**
 * (+parser(), +[char()], -any())
 */

R=parse_list(P,Str) :-
  R = parse_finalize(parse(P, list_to_stream(Str))).

/**
 * (+(fun(parser) -> result) | {p(parser()),$p}, +stream(), -any())
 */

R=parse({i(I),o(O),$p[I,O|*X]}, S) :- R=call1({i(I),o(O),$p[I,O|*X]}, S).
R=parse({p(P), $p[P|*X].},S) :- R=parse(P, S), $p[P|*X].
    
R=parse_finalize(result_success(X, S)) :- del(S), R=X.
R=parse_finalize(result_fail(X)) :- R=error(X).

%%%======================================================================
%%% parsers
%%% 

%%% Primitives

R=p_return(X) :- R={o=result_success(X, i).}.
R=p_fail(Msg) :- R={o=result_fail(Msg).}.

%%% Combinators

%% string
 
/**
 * (+string(), -string())
 */

R=p_string(L) :- R=p_seq(p_string_sub(L)).
R=p_string_sub([]) :- R=[].
R=p_string_sub([H|T]) :- R=[p_char(H)|p_string_sub(T)].

%% ground

/**
 * (+ground(), -ground())
 */

R=p_ground(G) :- ground(G) | R={o=parse_ground(G, i).}.

R=parse_ground(G, S) :-
    stream_dup(S, S0, S1),
    R=parse_ground_cont0(G, stream_ref(S0), S1).
R=parse_ground_cont0(G, eof,  S) :- del(S), R=result_fail(G).
R=parse_ground_cont0(G, e(X), S) :- G==X | R=result_success(X, stream_next(S)).
R=parse_ground_cont0(G, e(X), S) :- G\=X | del(S), R=result_fail(G).

%% char

/**
 * (+char(), -char())
 */

R=p_char(C) :- int(C) | R=p_ground(C).

%% many

/**
 * (+[parser()], -any())
 */

R=p_many(L) :- R=p_many(L, 0).
R=p_many(L, Min) :- R=p_many(L, Min, none).
R=p_many(L, Min, Max) :- R={o=parse_many(L, Min, Max, i).}.

R=parse_many(P, Min, Max, S) :-
  R=parse_many_loop(P, S, 0, Min, Max, []).

R=parse_many_loop(P, S, $c, $min, $max, Ret) :- $c=:=$max, int($min) |
  del(P),
  R=result_success(reverse(Ret), S).

R=parse_many_loop(P, S, $c, Min, $max, Ret) :- $c<$max |
  dup(P, P0, P1), stream_dup(S, S0, S1),
  R=parse_many_cont(parse(P0, S0), P1, $c, Min, $max, S1, Ret).

R=parse_many_loop(P, S, C, Min, none, Ret) :- 
  dup(P, P0, P1), stream_dup(S, S0, S1),
  R=parse_many_cont(parse(P0, S0), P1, C, Min, none, S1, Ret).

R=parse_many_cont(result_success(X, S), P, $c, Min, Max, S0, Ret) :- $c0=$c+1 |
  del(S0),
  R=parse_many_loop(P, S, $c0, Min, Max, [X|Ret]).
R=parse_many_cont(result_success(X, S), P, $c, Min, Max, S0, Ret) :- $c0=$c+1 |
  del(S0),
  R=parse_many_loop(P, S, $c0, Min, Max, [X|Ret]).
R=parse_many_cont(result_fail(X), P, $c, $min, Max, S, Ret) :- $c>=$min |
  del(X), del(P), del(Max),
  R=result_success(reverse(Ret), S).
R=parse_many_cont(result_fail(X), P, $c, $min, Max, S, Ret) :- $c<$min |
  del(P), del(Ret), del(S), del(Max),
  R=result_fail(X).

%% many till

/**
 * (+parser(), +parser(), -any())
 */

R=p_many_till(P, End) :-
  R=p_many(p_do([p_not(End), P])).

%% or

/**
 * (+[parser()], -any())
 */

R=p_or(L) :-
  R={o=parse_or(L, i).}.

R=parse_or([], S) :- del(S), R=result_fail([]).
R=parse_or([H|T], S) :-
  stream_dup(S, S0, S1),
  R=parse_or_cont(parse(H, S0), T, S1).
R=parse_or_cont(result_success(X, S0), L, S1) :-
  del(S1), del(L),
  R=result_success(X, S0).
R=parse_or_cont(result_fail(X), L, S) :-
  del(X),
  R=parse_or(L, S).

%% seq

/**
 * (+[parser()], -any())
 */

R=p_seq(L) :-
  R={o=parse_seq(L,i).}.

R=parse_seq(L, S) :- R=parse_seq_sub(L, S).

R=parse_seq_sub([H], S) :- R=parse(H, S).
R=parse_seq_sub([H0,H1|T], S) :-
  R=parse_seq_cont(parse(H0, S), [H1|T]).
R=parse_seq_cont(result_success(X, S), L) :-
  del(X),
  R=parse_seq_sub(L, S).
R=parse_seq_cont(result_fail(X), L) :-
  del(L),
  R=result_fail(X).

%% optional

/**
 * (+parser(), -option(any()))
 */

R=p_optional(P) :-
  R={o=parse_optional(P,i).}.

R=parse_optional(P, S) :-
  stream_dup(S, S0, S1),
  R=parse_optional_cont(parse(P, S0), S1).
R=parse_optional_cont(result_success(X, S), S0) :-
  del(S0),
  R=result_success(some(X), S).
R=parse_optional_cont(result_fail(X), S) :-
  del(X),
  R=result_success(none, S).

%% Do

/**
 * (+[parser()], any())
 */

R=p_do(L) :-
  R={o=parse_do(L,i).}.

R=parse_do(L, S) :- R=parse_do_sub(L, S).
R=parse_do_sub([H], S) :- R=parse(H, S).
R=parse_do_sub([H0,H1|T], S) :-
  R=parse_do_sub0(H0, [H1|T], S).
R=parse_do_sub0(bind(V, P), L, S) :-
  stream_dup(S, S0, S1),
  R=parse_do_sub_bind(V, parse(P, S0), S1, L).
R=parse_do_sub_bind(V, result_success(X, S), S0, L) :-
  V = X, del(S0),
  R=parse_do_sub(L, S).
R=parse_do_sub_bind(V, result_fail(X), S, L) :-
  V = none, del(L), del(S),
  R=result_fail(X).
R=parse_do_sub0({$p,@p}, L, S) :-
  stream_dup(S, S0, S1),
  R=parse_do_sub_parser(parse({$p,@p}, S0), S1, L).
R=parse_do_sub_parser(result_success(X, S), S0, L) :-
  del(X), del(S0),
  R=parse_do_sub(L, S).
R=parse_do_sub_parser(result_fail(X), S, L) :-
  del(L), del(S),
  R=result_fail(X).

del(bind(X,Y)) :- del(X), del(Y).

%% not

/**
 * (+[parser()], -void())
 */

R=p_not(P) :- R={o=parse_not(P,i).}.

R=parse_not(P, S) :-
  stream_dup(S, S0, S1),
  R=parse_not_cont(parse(P, S0), S1).
R=parse_not_cont(result_success(X, S), S0) :-
  del(S), del(S0),
  R=result_fail(X).
R=parse_not_cont(result_fail(X), S) :-
  del(X),
  R=result_success(none, S).

%% any

/**
 * (-any())
 */

R=p_any :-
  R={o=parse_any(i).}.
R=parse_any(S) :-
  stream_dup(S, S0, S1),
  R=parse_any_cont(stream_ref(S0), S1).
R=parse_any_cont(e(X), S) :- R=result_success(X, stream_next(S)).
R=parse_any_cont(eof, S) :- del(S), R=result_fail(any).

%% between

/**
 * (+parser(), +parser(), +parser(), -any())
 */

R=p_between(Open, P, Close) :-
  R=p_do([Open, bind(V, P), Close, p_return(V)]).


%% sep by

/**
 * (+parser(), +parser(), -any())
 */

R=p_sep_by(P, Sep) :- R=p_sep_by(P, Sep, 0).
R=p_sep_by(P, Sep, Min) :- R=p_sep_by(P, Sep, Min, none).
R=p_sep_by(P, Sep, $min, none) :-
    $min0=$min-1 |
  R=p_sep_by_cont(P, Sep, $min0, none).
R=p_sep_by(P, Sep, $min, $max) :-
    $min0=$min-1, $max0=$max-1 |
  R=p_sep_by_cont(P, Sep, $min0, $max0).

R=p_sep_by_cont(P, Sep, Min, Max) :- Min=<0 |
  dup(P, P0, P1),
  R=p_or([p_do([bind(H, P0),
                bind(T, p_many({p=p_do([Sep,
                                        bind(X, P1),
                                        p_return(X)])},
                               0, Max)),
                p_return([H|T])]),
          p_return([])]).
R=p_sep_by_cont(P, Sep, Min, Max) :-
  dup(P, P0, P1),
  R=p_do([bind(H, P0),
          bind(T, p_many({p=p_do([Sep,
                                  bind(X, P1),
                                  p_return(X)])},
                         Min, Max)),
          p_return([H|T])]).

%% end by

/**
 * (+parser(), +parser(), -any())
 */

R=p_end_by(P, Sep) :- R=p_end_by(P, Sep, 0, none).
R=p_end_by(P, Sep, Min) :- R=p_end_by(P, Sep, Min, none).
R=p_end_by(P, Sep, Min, Max) :- 
  R=p_many({p=p_do([bind(V, P),
                    Sep,
                    p_return(V)])},
           Min, Max).


R=p_end_by1(P, End) :-
  R=p_do([bind(V, P),
          End,
          p_return(V)]).

%% sep end by

/**
 * (+parser(), +parser(), -any())
 */

R=p_sep_end_by(P, Sep) :- R=p_sep_end_by(P, Sep, 0, none).
R=p_sep_end_by(P, Sep, Min) :- R=p_sep_end_by(P, Sep, Min, none).
R=p_sep_end_by(P, Sep, Min, Max) :-
  dup(Sep, Sep0, Sep1),
  R=p_do([bind(V, p_sep_by(P, Sep0, Min, Max)),
          p_optional(Sep1),
          p_return(V)]).

}.

