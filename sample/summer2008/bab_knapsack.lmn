/*
input{
  {n("au"),p(16.0),w(2.0)}.
  {n("ir"),p(28.0),w(5.0)}.
  {n("cu"),p(23.0),w(4.0)}.
  {n("ag"),p(19.0),w(3.0)}.
  limit(7.0). }.
*/
input{
  {n("i1"), p(15.0), w(5.0)}.
  {n("i2"), p(17.0), w(7.0)}.
  {n("i3"), p(13.0), w(3.0)}.
  {n("i4"), p(18.0), w(8.0)}.
  {n("i5"), p(19.0), w(9.0)}.
  {n("i6"), p(15.0), w(5.0)}.
  {n("i7"), p(12.0), w(2.0)}.
  {n("i8"), p(17.0), w(7.0)}.
  limit(22.0).
}.
/*
input{
  {n("i3"), p(23.0), w(13.0)}.
  {n("i5"), p(29.0), w(19.0)}.
  {n("i7"), p(22.0), w(12.0)}.
  {n("i8"), p(27.0), w(17.0)}.
  {n("i9"), p(23.0), w(13.0)}.
  {n("i16"), p(27.0), w(17.0)}.
  {n("i17"), p(20.0), w(10.0)}.
  {n("i18"), p(26.0), w(16.0)}.
  {n("i19"), p(25.0), w(15.0)}.
  limit(40.0).
}.
*/
/*
input{
  {n("i1"), p(15.0), w(5.0)}.
  {n("i2"), p(17.0), w(7.0)}.
  {n("i3"), p(23.0), w(13.0)}.
  {n("i4"), p(18.0), w(8.0)}.
  {n("i5"), p(29.0), w(19.0)}.
  {n("i6"), p(15.0), w(5.0)}.
  {n("i7"), p(22.0), w(12.0)}.
  {n("i8"), p(27.0), w(17.0)}.
  {n("i9"), p(23.0), w(13.0)}.
  {n("i10"), p(13.0), w(3.0)}.
  {n("i11"), p(13.0), w(3.0)}.
  {n("i12"), p(12.0), w(2.0)}.
  {n("i13"), p(12.0), w(2.0)}.
  {n("i14"), p(17.0), w(7.0)}.
  {n("i15"), p(11.0), w(1.0)}.
  {n("i16"), p(27.0), w(17.0)}.
  {n("i17"), p(20.0), w(10.0)}.
  {n("i18"), p(26.0), w(16.0)}.
  {n("i19"), p(25.0), w(15.0)}.
  {n("i20"), p(18.0), w(8.0)}.
  limit(91.0).
}.
*/
z(-999.0).
answer{}.

init{ //フリップ変数の導入と価値の計算
ex(0.0).
{n(N),p(P),w(W)} :-
        string(N), float(P), float(W) |
          {n(N), f(-1), p(P), w(W)}.
{n(N), f(-1), p(P), w(W)} :-
        string(N),float(P),float(W),P2=P/.W | 
          {n(N),f(-1.0), p(P2),q(P),w(W)}. }.

sort_{ //価値の順にソート
b2=L, {n(N),f(F1), p(P2),q(P),w(W)} :-
       string(N), float(F1),float(P2),float(P), float(W) |
      b2=[{n(N),f(F1), p(P2),q(P),w(W)}|L].
L=[{n($n1),f($f1), p($p1),q($q1),w($w1)},{n($n2),f($f2), p($p2),q($q2),w($w2)}|L2] :-
       string($n1),float($f1),float($p1),float($q1),float($w1),string($n2),float($f2),float($p2),float($q2),float($w2),
       $p2 >. $p1 |
      L=[{n($n2),f($f2), p($p2),q($q2),w($w2)},{n($n1),f($f1), p($p1),q($q1),w($w1)}|L2].}.

flip_{ //フリップすべき変数の決定
limit(M),check(N),b2=[{n(Na),f(F), p(P),q(Q), w(W)}|L2],b3=L :- 
         float(M),float(N),string(Na),float(F), float(P), float(W),float(T),float(Q),
         T = N+.W ,T=<.M | 
         limit(M),check(T),b2=L2,b3=[{n(Na),f(1.0), p(P),q(Q), w(W)}|L].
limit(M),check(N),b2=[{n(Na),f(F), p(P),q(Q), w(W)}|L2],b3=L :- 
         float(M),float(N),string(Na),float(F), float(P), float(W),float(T),float(Q),float(TMP1),
         T = N+.W, T>.M,TMP1=M-.N| 
         limit(M),check(M),b2=L2,b3=[{n(Na),f(TMP1/.W), p(P),q(Q),w(W)}|L].
limit(M),check(N),b2=[{n(Na),f(F), p(P),q(Q), w(W)}|L2],b3=L :- 
         float(M),float(N),string(Na),float(F), float(P),float(Q),float(W),
         M == N | 
         limit(M),check(N),b2=L2,b3=[{n(Na),f(0.0), p(P),q(Q), w(W)}|L].
//b2=[] :-.
 }.

solution_{ //実数解
b3=[{n(N),f(F), p(P),q(Q), w(W)}|L2], b2=L :-
       string(N),float(F), float(P), float(Q), float(W),
       F == 0.0|
       b3=L2,b2=[{n(N),f(F), p(P),q(Q), w(W)}|L],f(F).
b3=[{n(N),f(F), p(P),q(Q), w(W)}|L2], g(G) :-
       string(N),float(F), float(P), float(Q), float(W), float(TMP1), float(TMP2),float(G),
       TMP1 = F*.Q, TMP2 = G+.TMP1, F >. 0.0, F <. 1.0|
       b3=L2,g(TMP2),{n(N),f(F), p(P),q(Q), w(W)},f(F).
b3=[{n(N),f(F), p(P),q(Q), w(W)}|L2], b2=L, g(G) :-
       string(N),float(F), float(P), float(Q), float(W),float(G),
       F == 1.0|
       b3=L2,g(G+.Q),b2=[{n(N),f(F), p(P),q(Q), w(W)}|L],f(F).
b3=[] :- ok(1).
g(G), ex(E),ok(1) :- float(G), float(E) | g(G+.E), ex(E).
f(F) :- float(F), F >. 0.0, F <. 1.0 | zissu(1).
f(F) :- float(F), F == 1.0 | seisu(1).
f(F) :- float(F), F == 0.0 | seisu(1).
zissu(1),seisu(1) :- zissu(1).
zissu(1),zissu(1) :- zissu(1).
}.

prebranch_{ //分岐準備. 終了は、整数解もしくはG<Zのとき
{n(N),f(F), p(P),q(Q), w(W)},check(C),ex(E),limit(L) :- //整数でないFを持つ膜を削除
        string(N),float(F),float(P),float(Q),float(W),float(C),float(E),float(L),
        1.0 >. F, 0.0 <. F |
        limit_t(L-.W), limit_f(L), ex_t(E+.Q), ex_f(E),check(0.0), n_t(N).
}.

//----------------------------------------------------------------
input{$r, @r}, init{$rb, @rb} :- init{$r,$rb,@rb}. //初期化膜に入れる
init{$r1. @r1}/ ,sort_{$r2_.@r2_}:-  //初期化し終わったら、ソート膜に入れる
      sort{$r1. b2=[]. check(0.0),@r2_},sort_{$r2_. @r2_}.
sort{$r2, @r2}/, flip_{$r3_, @r3_} :-  //ソートが終わったら、フリップ膜に入れる
          flip{$r2, b3=[],@r3_},flip_{$r3_, @r3_}.
flip{limit(L),$r3, @r3}/, solution_{$r4_, @r4_}:- float(L), 0.0 <. L |
               solution{g(0.0).limit(L),$r3. @r4_},solution_{$r4_, @r4_}.
solution{$r4, @r4}/, prebranch_{$r5_, @r5_} :- prebranch{$r4, @r5_},prebranch_{$r5_, @r5_}.

//--------------------------------------------------------------------
//  親を持たない場合の分岐ルール（根からの分岐）
//--------------------------------------------------------------------
prebranch{ex_t(ET),ex_f(EF),limit_t(LT),limit_f(LF),n_t(N),zissu(1),g(G),$r5[]. @r5.}/ :-     
         float(LT), float(LF), float(G), float(ET), float(EF), string(N) | 
         branched{lp(L),lp(R) },
         remove{lc(L),$r5[],limit(LF),ex(EF)},
         remove{lc(R),$r5[],limit(LT),ex(ET),n(N)}.
//--------------------------------------------------------------------
//  親を持つ場合の分岐ルール                 
//--------------------------------------------------------------------
branched{lp(L0), $r0},
prebranch{ lc(L0), $r[],ex_t(ET), ex_f(EF),limit_t(LT),limit_f(LF),n_t(N),zissu(1),g(G),@r5}/,z(Z) :- 
          float(LT), float(LF),float(G),float(ET),float(EF),float(Z),G >. Z,string(N)|
 branched{lp(L0), $r0},
 branched{ lp(L), lp(R), lc(L0) },
 remove{ lc(L),$r[],limit(LF),ex(EF)},
 remove{ lc(R),$r[],limit(LT),ex(ET),n(N)},z(Z).
//------------------------------------------------------------------
//  分岐することによってできたremove膜をsort膜にする（再帰開始点）
//------------------------------------------------------------------
remove{$r5. @r5. check(C). limit(L)}/,sort_{$r2_[], @r2_} :- float(L),float(C),
  L >. 0.0 |
sort{$r5, @r2_,check(C), limit(L) },sort_{$r2_[], @r2_}.
//----------------------------------------------------------------------
//  ゴミ掃除と目的関数値の更新
//----------------------------------------------------------------------
branched{lp(L0), $r0},
prebranch{ lc(L0), $r[],ex_t(ET), ex_f(EF),limit_t(LT),limit_f(LF),zissu(1),g(G),@r5}/,z(Z) :- 
          float(LT), float(LF),float(G),float(ET),float(EF),float(Z),G <. Z|
branched{$r0},z(Z).
branched{lp(L0), $r0},remove{ lc(L0),limit(L) ,$r[],@r} :- float(L), 0.0 >. L | branched{$r0}.

branched{lp(L0), $r0},remove{ lc(L0),limit(L),ex(E),$r[],@r} :- float(L), L == 0.0 ,float(E) | 
branched{lp(L0),$r0},leaf{ lc(L0), g(E), $r[],@r}.
/*
branched{lp(L0), $r0},remove{ lc(L0),limit(Li),ex(E),n(N),$r[],@r} 
:- float(Li), Li == 0.0 ,float(E),string(N) | 
branched{lp(L0),$r0},remove{ lc(L0),limit(Li),ex(E), $r[],@r}.
branched{lp(L0), $r0},remove{ lc(L0),limit(L),ex(E),b2=[],$r[],@r} :-
 float(L), float(E), L == 0.0 |
branched{lp(L0),$r0},leaf{lc(L0),g(E),$r[],@r}.
*/


branched{lp(L0),$r0},prebranch{lc(L0), seisu(1), g(G), $r[], @r} :- float(G) |
branched{lp(L0),$r0},leaf{lc(L0),g(G), $r[]}.
branched{lp(L0),$r0},leaf{lc(L0),g(G),$r[],@r},z(Z) :- float(G),float(Z),
 G >. Z |
 branched{lp(L0),$r0},leaf{lc(L0),g(G),$r[],@r},z(G).
/*
branched{lp(L0),$r0},leaf{lc(L0),$r[],@r},answer{$k[],@k} :- 
 branched{$r0},answer{leaf{$r[]}, $k[]}.
*/

answer{leaf{g(G1),$l1[]},leaf{g(G2),$l2[]},$k[],@k} :- float(G1),float(G2),G1>.G2 |
answer{leaf{g(G1),$l1[]},$k[]}.

//answer{leaf{g(G),$l}/, $r[], @r}, z(Z) :- float(G), float(Z), G == Z | answer{$l}. 

