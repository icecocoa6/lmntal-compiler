{
module(mapSite).
H=mapSite.new :- H={
	}.
}.

{
module(room).
H=room.new(N) :- int(N) | H={
	oop.extends(mapSite.new).
	//field
	roomNo(N).
	sides=ooplist.new(4).
	//method
	getSide(N), sides=Sides :- sides=list.ref(Sides, N, return).
	setSide(N, MapSite), sides=Sides :- sides=list.set(Sides, N, MapSite, old).
	old({}) :- nlmem.kill({}).//他に参照がなかったら消す
	}.
}.

{
module(wall).
H=wall.new :- H={
	oop.extends(mapSite.new).
	wall.//目印
	//method
	}.
}.

{
module(door).
H=door.new(R1, R2) :- H={
	oop.extends(mapSite.new).
	//field
	room1(R1).
	room2(R2).
	isopen(false).
	//method
	//TODO
	otherSideFrom(R) :-return({room(R)}).
	}.
}.

{
module(maze).
H=maze.new :- H={
	//field
	rooms=ooplist.new(0).
	//method
	addRoom(R), rooms=Rooms :- rooms=[R|Rooms].
	roomNo(N), rooms=Rooms :- int(N) | rooms=ooplist.get(Rooms, N, return).
	}.
}.

{
module(mazeGame).
H=mazeGame.createMaze :- H=mazeGame.createMaze2(maze.new).
H=mazeGame.createMaze2(Maze) :- H=oop.msg(Maze, {
	r1=oop.ref(oop.ref(room.new(1), r12), r13).
	r2=oop.ref(oop.ref(room.new(2), r22), r23).

	r1(R1), r2(R2), r12(R12), r22(R22) :-
		door1=oop.ref(door.new(R1, R2), door12),
		addRoom(R12), addRoom(R22).
		
	r13(R), door1(D) :- oop.msg(R, {
		setSide(0, wall.new).
		setSide(1, D).
		setSide(2, wall.new).
		setSide(3, wall.new).
		}).
	r23(R), door12(D) :- oop.msg(R, {
		setSide(0, wall.new).
		setSide(1, wall.new).
		setSide(2, wall.new).
		setSide(3, D).
		}).
	}).

H=mazeGame.createMaze({$p,@p}) :- H={
	mf1=oop.ref(oop.ref(oop.ref({$p,@p}, mf2), mf3), mf4).
	mf1(MF) :- maze=oop.msg(MF, {makeMaze}).
	mf2(MF) :- r11=oop.ref(oop.ref(oop.msg(MF, {makeRoom(1)}), r12), r13).
	mf3(MF) :- r21=oop.ref(oop.ref(oop.msg(MF, {makeRoom(2)}), r22), r23).
	mf4(MF), r11(R1), r21(R2) :- d11=oop.ref(oop.msg(MF, {makeDoor(R1, R2)}), d12).

	maze(Maze), r12(R1), r22(R2) :- oop.msg(Maze, {addRoom(R1),addRoom(R2)}).
		
	r13(R), d11(D) :- oop.msg(R, {
			setSide(0, wall.new).
			setSide(1, D).
			setSide(2, wall.new).
			setSide(3, wall.new).
		}).
	r23(R), d12(D) :- oop.msg(R, {
			setSide(0, wall.new).
			setSide(1, wall.new).
			setSide(2, wall.new).
			setSide(3, D).
		}).
	}.
		
//H=mazeGame.createMaze(MazeBuilder) :- H=oop.msg(MazeBuilder, {buildMaze}).

}.

{
module(mazeFactory).
H=mazeFactory.new :- H={
	//method
	makeMaze :- return(maze.new).
	makeWall :- return(wall.new).
	makeRoom(N) :- int(N) | return(room.new(N)).
	makeDoor(R1, R2) :- return(door.new(R1, R2)).
	}.
}.

{
module(enchantedMazeFactory).
H=enchantedMazeFactory.new :- H={
	oop.extends(mazeFactory.new).
	makeRoom(N) :- return(enchantedRoom.new(N, castSpell.new)).
	makeDoor(R1, R2) :- return(doorNeedingSpell(R1, R2)).
	}.
}.

{
module(bombedMazeFactory).
H=bombedMazeFactory.new :- H={
	makeWall :- return(bombedWall.new).
	makeRoom(N) :- return(roomWithABomb(N)).
	}.
}.

oop.use.
//maze=mazeGame.createMaze().
maze=mazeGame.createMaze(mazeFactory.new).