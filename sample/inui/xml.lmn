/*
 * Coyright(C) 2006 Ueda Laboratory LMNtal Group, All rights reserved. 
 * $Author$
 *
 * SYNOPSIS
 *  XMLライブラリ
 * 
 * HISTORY
 *	2006.1.23 作成開始
 *  2006.1.24 ノードの表現を膜に変更
 */
 
% XMLファイルを開く
r=xml.open("sample.xml").

% valueを持つタグを表すアトムを取り出すルール
{value(X), $p,@q} :- unary(X) | value(X), {$p,@q}.
{{value(X), $p},$q} :- unary(X) | value(X), {{$p},$q}.
{{{value(X), $p},$q},$r} :- unary(X) | value(X), {{{$p},$q},$r}.

% nameを持つタグを表すアトムを取り出すルール
{name(X), $p,@q} :- unary(X) | name(X), {$p,@q}.
{{name(X), $p},$q} :- unary(X) | name(X), {{$p},$q}.
{{{name(X), $p},$q},$r} :- unary(X) | name(X), {{{$p},$q},$r}.

{
module(xml).

/**
 * xml.open(+Filename, -Res):
 * 与えられたファイル名のXMLファイルを読み込んでLMNtalデータ構造を生成します。
 * @param +Filename XMLファイル名
 * @param -Res ルートアトムを返します。
 * @example r=xml.open("sample.xml").
 */
H=xml.open(Filename) :- unary(Filename) | H=[:/*inline*/
	Atom a = LMNtalXML.open(me.nth(0), mem);
	mem.relink(a, 0, me, 1);
	mem.removeAtom(me.nthAtom(0));
	mem.removeAtom(me);
	:](Filename).

/**
 * xml.open(+Filename, -Res):
 * 与えられたファイル名にXML形式で膜構造を書き出します
 * @param +Filename XMLファイル名
 * @param -Res ルートアトムを返します。
 * @example r=xml.open("sample.xml").
 */
H=xml.write(Filename) :- unary(Filename) | H=[:/*inline*/
	LMNtalXML.write(me.nth(0));
	:](Filename).
}.

[:/*inline_define*/
import java.io.*;

import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.*;

import runtime.*;

/**
 * XMLファイルを読んでLMNtalデータ構造を構築する
 * @author inui
 * @since 2006.1.23
 */
class LMNtalXML {
	protected static final Functor nameFunctor = new SymbolFunctor("name", 1);
	protected static final Functor valueFunctor = new SymbolFunctor("value", 1);
	
	protected Membrane mem;
	protected Document doc;
	
	private static LMNtalXML xml;

	/**
	 * コンストラクタ
	 * @param filename 読み込むXMLファイル
	 * @param mem データ構造を追加したい膜
	 */
	private LMNtalXML(String filename, Membrane mem) {
		this.mem = mem;
		try {
			DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
			DocumentBuilder db = dbf.newDocumentBuilder();
			//XML文書を読み込む
			doc = db.parse(new FileInputStream(filename));
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	public static Atom open(String filename, Membrane mem) {
		xml = new LMNtalXML(filename, mem);
		return xml.walkThrough();
	}
	
	public static void write(String filename) {
		try {
		    TransformerFactory transFactory = TransformerFactory.newInstance();
		    Transformer transformer = transFactory.newTransformer();
		    Source source = new DOMSource(xml.doc);
		    Result result = new StreamResult(new File(filename));
		    transformer.transform(source, result);
		} catch (TransformerConfigurationException e) {
		} catch (TransformerException e) {
		}
	}
	
	/**
	 * ノードを受け取って対応するアトムを生成します
	 * @param node ノード
	 * @return このノードに対応するアトム
	 */
	private Membrane newNodeMembrane(Node node, Membrane mem) {
		Membrane m = mem.newMem();
		Atom nameAtom1 = m.newAtom(nameFunctor);
		Atom nameAtom2 = m.newAtom(new StringFunctor(node.getNodeName()+""));
		m.newLink(nameAtom1, 0, nameAtom2, 0);
		
		Atom valueAtom1 = m.newAtom(valueFunctor);
		Atom valueAtom2 = m.newAtom(new StringFunctor(node.getNodeValue()+""));
		mem.newLink(valueAtom1, 0, valueAtom2, 0);
		return m;
	}

	/**
	 * 全ノードを探索
	 * @return ルートノードを表すアトム
	 */
	private Atom walkThrough() {
		Node root = doc.getDocumentElement();
		traverse(root, mem);
		return mem.newAtom(new SymbolFunctor("root", 1));
	}
	
	/**
	 * 有効なノードかどうか判定する
	 * @param node ノード
	 * @return 有効なノードならtrue
	 */
	private boolean isValidNode(Node node) {
		return !(node.getNodeType() == Node.TEXT_NODE && node.getNodeValue().trim().length() == 0);
	}
	
	/**
	 * 有効な子ノードの数を返す
	 * @param node ノード
	 * @return 子ノードの数
	 */
//	private int getValidChildNodesLength(Node node) {
//		int length = 0;
//		for (Node child = node.getFirstChild(); child != null; child = child.getNextSibling()) {
//			if (isValidNode(child)) length++;
//		}
//		return length;
//	}

	/**
	 * 再帰的にノードをたどる
	 * @param node ノード
	 * @param atom アトム
	 */
	private void traverse(Node node, Membrane mem) {
		for (Node child = node.getFirstChild(); child != null; child = child.getNextSibling()) {
			if (!isValidNode(child)) continue;
			
			Membrane m = newNodeMembrane(child, mem);
			
			traverse(child, m);
		}
	}
}
:]