% 狼と羊とキャベツの問題 by kudo

% 説明:
% 狼と羊とキャベツが左岸にある。これらを右岸に運びたいが、ボートは一隻しかない。なので一度に一匹（一つ）しか運べない。
% 狼と羊を残して往復すると、狼が羊を食べてしまう。羊とキャベツを残して往復すると、羊がキャベツを食べてしまう。それは避けたい。
% 何も運ばずにボートを移動することも可能。
% 最も早く、三つを運ぶことができるのはどんな手順か。

% 膜を複製しまくって探索する方法なので、とても時間がかかる。たかだか深さ7だが、10秒くらい。
% 「一度辿った状態になった膜の判定」と「目標に辿りついた膜の判定」にgroundの比較を利用している。

% 初期状態（三つとも左岸にあり、ボートも左岸にある。）
space={state(0,left,[mark,p(left,wolf),p(left,goat),p(left,cabbege)])}.

% 目標の状態は
% space={
% state(7,right,[p(right,wolf),p(right,goat),p(right,cabbege)]),
% move=(1,right,goat),
% move=(2,left,nil),
% move=(3,right,wolf),
% move=(4,left,goat),
% move=(5,right,cabbege),
% move=(6,left,nil),
% move=(7,right,goat),
% }.
% こんな感じ。
% ただし,3と5は入れ替わるのも可.

% 最終状態（三つとも右岸にあり、ボートも右岸にある。）
goal(right,[p(right,wolf),p(right,goat),p(right,cabbege)]).

% 幅優先探索にする為の変数。stage(N)の時、N番目の手順のspaceが優先して複製される
% （ただしこの優先性はルールの記述順序を利用しているので、保証はない（おいおい））
stage(0).

% 解けたらsolvedとなり、探索はストップ。
unsolved.

% notを使うためのルール。not(left)をrigthtに、not(right)をleftに。
unsolved,space={N=not(left) ,$sp[N]} :- unsolved,space={N=right,$sp[N]}.
unsolved,space={N=not(right),$sp[N]} :- unsolved,space={N=left ,$sp[N]}.

% 検証ルール1(膜の除去)

% ダメな膜の除去(unaryの'='の否定条件が書けないので、二本ずつ)
unsolved,space={W=p(right,wolf),G=p(right,goat)   ,state(N,left ,ST),$sp[ST,N,W,G]} :- unsolved.    % 狼が羊を食べる
unsolved,space={W=p(left ,wolf),G=p(left ,goat)   ,state(N,right,ST),$sp[ST,N,W,G]} :- unsolved.    % 狼が羊を食べる
unsolved,space={G=p(right,goat),C=p(right,cabbege),state(N,left ,ST),$sp[ST,N,G,C]} :- unsolved.    % 羊がキャベツを食べる
unsolved,space={G=p(left ,goat),C=p(left ,cabbege),state(N,right,ST),$sp[ST,N,G,C]} :- unsolved.    % 羊がキャベツを食べる

% 一度探索した状態になった膜の除去
unsolved,space={state(SN1,BS1,[mark|ST1]),$sp1[]},space={state(SN2,BS2,[mark|ST2]),$sp2[]} :-
  unary(BS1),unary(BS2),BS1=BS2, int(SN1),int(SN2), SN1>SN2, ground(ST1),ground(ST2),ST1=ST2|
unsolved,                                         space={state(SN2,BS2,[mark|ST2]),$sp2[]}.

% 検証ルール2(目標に辿りついた膜の判定)
unsolved,   space={state(SN,BS,[mark|ST]),$st[]},goal(GS,GL) :- int(SN),unary(BS),unary(GS),GS=BS,ground(ST),ground(GL),ST=GL |
  solved,solution={state(SN,BS,      ST ),$st[]},goal(GS,GL).

% 検証ルール3（複製）
% countを一つ増やす
% ボートを移動。
% moveを挿入。
% 複製元の、markを一つずつ後ろに移動。
% 複製された膜についてはmarkは先頭に。markが先頭にあるということが、複製されたばかりの膜だということを表す。

% ボートがある岸にある物については複製される
unsolved,space={state(N,BS,ST)              ,LIST=[mark,p(CS,      CAR)     |CDR],$sp[ST,LIST,CDR]                      } , stage(SN) :-
unary(CS),unary(BS),unary(CAR),CS=BS,int(N),int(SN) ,N=SN|
unsolved,space={state(N,BS,ST)              ,LIST=[     p(CS      ,CAR),mark|CDR],$sp[ST,LIST,CDR]                      } , stage(SN),
         space={state(N+1,not(BS),[mark|ST]),LIST=[     p(not(CS) ,CAR)     |CDR],$sp[ST,LIST,CDR],move(N+1,not(BS),CAR)}.

% 対岸にある物については複製されない
unsolved,space={state(N,BS,ST)              ,LIST=[mark,p(CS,      CAR)     |CDR],$sp[ST,LIST,CDR]                      } , stage(SN) :-
unary(CS),unary(BS),unary(CAR),int(N),int(SN) , N=SN|
unsolved,space={state(N,BS,ST)              ,LIST=[     p(CS      ,CAR),mark|CDR],$sp[ST,LIST,CDR]                      } , stage(SN) .

% リストの最後（空のボートが移動するケース）
unsolved,space={state(N,BS,ST)              ,LIST=[mark                         ],$sp[ST,LIST    ]                      } , stage(SN) :-
           unary(BS),int(N),int(SN),N=SN|
unsolved,space={state(N+1,not(BS),[mark|ST]),LIST=[                             ],$sp[ST,LIST    ],move(N+1,not(BS),nil)} , stage(SN).

% 幅優先探索にするための変数を増やすルールは最も優先度が低い
unsolved,stage(N) :- int(N) | unsolved,stage(N+1).

% 正解を残して残りを消す(この行をコメントアウトすれば、最後の時点での探索状態を見られるが、どれが正解かわかりにくくなる)
solved,space={$sp[]} :- solved.
