% times server simulation
% 分散シミュレーション
% リスト逆順

{% brie: client
connect("gouda",60000,S,R).
S=["hoge","moge"].
R=ret.
}.

{% gouda: server
port(60000,P).
P=[accept(S,R)].
S=times(R,3).
% server's rule
Ret=times([H|T],N) :- int(N),string(H) | Ret=[string.times(H,N)|times(T,N)].
}.

% connect and accept rule
{connect(Host,Port1,S1,R1),$p[S1,R1|*C],@p},
{port(Port2,[accept(S2,R2)|T]),$q[S2,R2,T|*C],@q} :- 
  string(Host),Port1=:=Port2 |
    {socket(C,S1,R1),$p[S1,R1|*C],@p},
    {port(Port2,T),socket(C,S2,R2),$q[S2,R2,T|*C],@q}.

% send and receive rule
{socket(C,[H|T],R1),$p[T,R1|*C],@p},
{socket(C,S2,R2),$q[S2,R2|*C],@q} :-
  string(H) |
    {socket(C,T,R1),$p[T,R1|*C],@p},
    {socket(C,S2,RR2),$q[S2,R2|*C],@q,
      RR2 = 
      [:/*inline*/
        String str = me.nth(0);
        Atom dataAtom = mem.newAtom(new StringFunctor(str));
        Atom consAtom = mem.newAtom(new Functor(".",3));
        mem.newLink(consAtom,0,dataAtom,0);
        mem.unifyAtomArgs(me,1,me,2);
        mem.relinkAtomArgs(consAtom,2,me.nthAtom(2),2);
        mem.newLink(consAtom,1,me.nthAtom(2),2);
        me.nthAtom(0).remove();
        me.remove();
      :](H,R2)}.
