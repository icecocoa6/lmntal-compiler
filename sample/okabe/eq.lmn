% Membrane comparator

[:/*inline_define*/
  // for atom sorting
  class AtomComparator implements java.util.Comparator {
    public int compare(Object o1, Object o2) {
      Atom a1 = (Atom)o1;
      Atom a2 = (Atom)o2;
      String fs1 = a1.getFunctor().toString();
      String fs2 = a2.getFunctor().toString();
      if(fs1.compareTo(fs2) > 0)
        return 1;
      else if(fs1.compareTo(fs2) < 0)
        return -1;
      // ファンクタが等しいとき
      // リンク数でソートする
      else {
        int e1 = a1.getEdgeCount();
        int e2 = a1.getEdgeCount();
        if(e1-e2 > 0)
          return 1;
        else if(e1-e2 < 0)
          return -1;
        // リンク数が等しいとき
        // リンク先ファンクタでソートする
        else {
          for(int i=0; i<e1; i++) {
            String fss1 = a1.nthAtom(i).getFunctor().toString();
            String fss2 = a2.nthAtom(i).getFunctor().toString();
            if(fss1.compareTo(fss2) > 0)
              return 1;
            else if(fss1.compareTo(fss2) < 0)
              return -1;
          }
          return 0;
        }
      }
    }
  }
  
  // for ruleset sorting
  class RulesetComparator implements java.util.Comparator {
    public int compare(Object o1, Object o2) {
      Ruleset r1 = (Ruleset)o1;
      Ruleset r2 = (Ruleset)o2;
      String s1 = r1.encode();
      String s2 = r2.encode();
      if(s1.compareTo(s2) > 0)
        return 1;
      else if(s1.compareTo(s2) < 0)
        return -1;
      else
        return 0;
    }
  }
  
  class C {
    public static boolean memEq(Membrane m1, Membrane m2) {
      // 前処理
      if(!auxMemEq(m1,m2))
        return false;
      // phase 1
      // AtomSet の同一性判定
      if(!(atomEq(m1,m2))) {
        //System.out.println("atom: false");
        return false;
        }
      // phase 2
      // RuleSet の同一性判定
      if(!(rulesetEq(m1,m2))) {
        //System.out.println("ruleset: false");
        return false;
        }
      // phase 3
      // 子膜の同一性判定
      if(childMemEq(m1,m2))
        return true;
      else
        {
        //System.out.println("childMem: false");
        return false;
        }
    }
    
    // 前処理
    // 膜の構成要素の個数を比較する
    public static boolean auxMemEq(Membrane m1, Membrane m2) {
      if(m1.getAtomCount() != m2.getAtomCount()) {
        //System.out.println("atomCount");
        return false;
      }
      if(m1.getMemCount() != m2.getMemCount()) {
        //System.out.println("memCount");
        return false;
      }
      if(m1.getFreeLinkCount() != m2.getFreeLinkCount()) {
        //System.out.println("freeLinkCount");
        return false;
      }
      if(m1.getRulesetCount() != m2.getRulesetCount()) {
        //System.out.println("rulesetCount");
        return false;
      }
      return true;      
    }
    
    // 子膜の同一性判定を行う
    public static boolean childMemEq(Membrane m1, Membrane m2) {
      HashSet h1 = m1.getMemCopy();
      HashSet h2 = m2.getMemCopy();
      Iterator memIt1 = h1.iterator();
      while(memIt1.hasNext()) {
        Membrane mm1 = (Membrane)memIt1.next();
        Iterator memIt2 = h2.iterator();
        while(memIt2.hasNext()) {
          //System.out.println("it1: " + mm1);
          Membrane mm2 = (Membrane)memIt2.next();
          //System.out.println("it2: " + mm2);
          if(memEq(mm1,mm2)) {
            //System.out.println("remove: " + mm1 + ", " + mm2);
            memIt1.remove();
            memIt2.remove();
            if(h1.isEmpty() ^ h2.isEmpty()) {
              return false;
            }
            break;
          }
        }
      }
      if(h1.isEmpty() && h2.isEmpty())
        return true;
      else
        return false;    
    }
    
    // アトムの同一性判定を行う
    public static boolean atomEq(Membrane m1, Membrane m2) {
      Atom[] a1 = (Atom[])m1.getAtomArray();
      Atom[] a2 = (Atom[])m2.getAtomArray();

      AtomComparator ac = new AtomComparator();
      Arrays.sort(a1,ac);
      Arrays.sort(a2,ac);
      /*
      for(int i=0; i<a1.length; i++) {
        System.out.println(a1[i] + ", " + a2[i]);
      }
      */
      for(int i=0; i<a1.length; i++) {
        // ファンクタが等しいか？
        Functor f1 = a1[i].getFunctor();
        Functor f2 = a2[i].getFunctor();
        if(!(f1.equals(f2))) {
          return false;
        }
        // 隣接するアトムのファンクタ が等しいか？
        for(int j=0; j<a1[i].getEdgeCount(); j++) {
          if(!((a1[i].nthAtom(j).getFunctor()).equals
            (a2[i].nthAtom(j).getFunctor()))) {
            return false;
          }
        }
      }
      return true;
    }
    
    // ルールセットの同一性判定を行う
    public static boolean rulesetEq(Membrane m1, Membrane m2) {
      if(m1.getRulesetCount() != m2.getRulesetCount())
        return false;
      ArrayList a1 = m1.getRuleset();
      ArrayList a2 = m2.getRuleset();
            
      RulesetComparator rc = new RulesetComparator();
      Collections.sort(a1,rc);
      Collections.sort(a2,rc);
      
      Iterator it1 = a1.iterator();
      Iterator it2 = a2.iterator();
      while(it1.hasNext()) {
        String e1 = ((Ruleset)it1.next()).encode();
        String e2 = ((Ruleset)it2.next()).encode();
        if(!(e1.equals(e2))) {
          //System.out.println("not equal: ");
          //System.out.println(e1);
          //System.out.println(e2);
          return false;
        }
      }
      return true;
    }
  }
:].

res1=contains(S1,D1).
S1={{b,c(Y),{b(x,Y)}. a:-b. hoge=integer.set(0,9).}}.
D1={{a,c(X),{b(x,X)}. a:-b. hoge=integer.set(0,9).}}.

res2=contains(S2,D2).
S2={{{a(b),a(c),a(b,A),q(X)},
  g(X),a(b),a(c),a(b),{a(b,A),a(c),a(b)},b(c),c(a)}}.
D2={{{a(b),a(b,B),a(c),q(Y)},
  g(Y),a(b),b(c),c(a),{a(b,B),a(c),a(b)},a(b),a(c)}}.

res3=contains(S3,D3).
S3={{hoge=string.times("ho",3)}}.
D3={{hoge=string.times("ho",3)}}.
/*
res4=contains(S4,D4).
S4={{string.use}}.
D4={{string.use}}.
*/
move@@ {foo. {@p}} :- S5={{@p}},D5={{@p. a:-c}},res5=contains(S5,D5).
{foo. {a :- b.}}.

H = contains(Src,Dst) :- H =
[:/*inline*/
  Atom a1 = me.nthAtom(0).nthAtom(0);
  Atom a2 = me.nthAtom(1).nthAtom(0);
  Membrane m1 = (Membrane)(a1.getMem());
  Membrane m2 = (Membrane)(a2.getMem());
  Iterator it1 = m1.memIterator();
  Iterator it2 = m2.memIterator();
  
  boolean eq = false;
  if(it1.hasNext()) {
    Membrane mm1 = (Membrane)it1.next();
    while(it2.hasNext()) {
      Membrane mm2 = (Membrane)it2.next();
      //System.out.println(mm1 + ", " + mm2);
      if(C.memEq(mm1,mm2)) {
        Atom a = mem.newAtom(new Functor("true",1));
        mem.relinkAtomArgs(a,0,me,2);
        eq = true;
        break;
      }
    }
    if(!eq) {
      Atom a = mem.newAtom(new Functor("false",1));
      mem.relinkAtomArgs(a,0,me,2);
    }
  }
  me.remove();
:](Src,Dst).
