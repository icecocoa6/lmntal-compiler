% Simple Membrane Comparator
%
% 膜比較モジュール簡易版
% 自由リンクを持たない膜に対してのみ有効
%
% AUTHOR: Ryo OKABE
%

[:/*inline_define*/
  // for atom sorting
  class AtomComparator implements java.util.Comparator {
    public int compare(Object o1, Object o2) {
      Atom a1 = (Atom)o1;
      Atom a2 = (Atom)o2;
      String fs1 = a1.getFunctor().toString();
      String fs2 = a2.getFunctor().toString();
      if(fs1.compareTo(fs2) > 0)
        return 1;
      else if(fs1.compareTo(fs2) < 0)
        return -1;
      // ファンクタが等しいとき
      // リンク数でソートする
      else {
        int e1 = a1.getEdgeCount();
        int e2 = a1.getEdgeCount();
        if(e1-e2 > 0)
          return 1;
        else if(e1-e2 < 0)
          return -1;
        // リンク数が等しいとき
        // リンク先ファンクタでソートする
        // リンク先ファンクタについて再帰しなくても大丈夫なはず？
        else {
          for(int i=0; i<e1; i++) {
            String ffs1 = a1.nthAtom(i).getFunctor().toString();
            String ffs2 = a2.nthAtom(i).getFunctor().toString();
            if(ffs1.compareTo(ffs2) > 0)
              return 1;
            else if(ffs1.compareTo(ffs2) < 0)
              return -1;
          }
          return 0;
        }
      }
    }
  }
  
  // for ruleset sorting
  class RulesetComparator implements java.util.Comparator {
    public int compare(Object o1, Object o2) {
      Ruleset r1 = (Ruleset)o1;
      Ruleset r2 = (Ruleset)o2;
      String s1 = r1.encode();
      String s2 = r2.encode();
      return s1.compareTo(s2);
    }
  }
  
  class C {
    public static boolean memEq(Membrane m1, Membrane m2) {
      // 前処理	
      if(!auxMemEq(m1,m2))
        return false;
      // phase 1
      // アトムの比較
      if(!(atomEq(m1,m2))) {
        //System.out.println("atom: false");
        return false;
      }
      // phase 2
      // ルールセットの比較
      if(!(rulesetEq(m1,m2))) {
        //System.out.println("ruleset: false");
        return false;
      }
      // phase 3
      // 子膜の比較
      if(childMemEq(m1,m2))
        return true;
      else {
        //System.out.println("childMem: false");
        return false;
      }
    }
    
    // 前処理
    // 膜の構成要素の個数を比較する
    public static boolean auxMemEq(Membrane m1, Membrane m2) {
      if(m1.getAtomCount() != m2.getAtomCount()) {
        //System.out.println("!atomCount");
        return false;
      }
      if(m1.getMemCount() != m2.getMemCount()) {
        //System.out.println("!memCount");
        return false;
      }
      if(m1.getRulesetCount() != m2.getRulesetCount()) {
        //System.out.println("!rulesetCount");
        return false;
      }
      return true;      
    }
    
    // 子膜の比較
    public static boolean childMemEq(Membrane m1, Membrane m2) {
      HashSet h1 = m1.getMemCopy();
      HashSet h2 = m2.getMemCopy();
      Iterator it1 = h1.iterator();
      while(it1.hasNext()) {
        Membrane mm1 = (Membrane)it1.next();
        Iterator it2 = h2.iterator();
        while(it2.hasNext()) {
          //System.out.println("it1: " + mm1);
          Membrane mm2 = (Membrane)it2.next();
          //System.out.println("it2: " + mm2);
          if(memEq(mm1,mm2)) {
            //System.out.println("equals: " + mm1 + ", " + mm2);
            it1.remove();
            it2.remove();
            if(h1.isEmpty() ^ h2.isEmpty()) {
              return false;
            }
            break;
          }
        }
      }
      if(h1.isEmpty() && h2.isEmpty())
        return true;
      else
        return false;    
    }
    
    // アトムの比較
    public static boolean atomEq(Membrane m1, Membrane m2) {
      Atom[] a1 = (Atom[])m1.getAtomArray();
      Atom[] a2 = (Atom[])m2.getAtomArray();

      AtomComparator ac = new AtomComparator();
      Arrays.sort(a1,ac);
      Arrays.sort(a2,ac);
      /*
      for(int i=0; i<a1.length; i++) {
        System.out.println(a1[i] + " ?= " + a2[i]);
      }
      */
      for(int i=0; i<a1.length; i++) {
        // ファンクタを比較
        Functor f1 = a1[i].getFunctor();
        Functor f2 = a2[i].getFunctor();
        if(!(f1.equals(f2))) {
          return false;
        }
        // 隣接するアトムのファンクタを比較
        for(int j=0; j<a1[i].getEdgeCount(); j++) {
          Functor ff1 = a1[i].nthAtom(j).getFunctor();
          Functor ff2 = a2[i].nthAtom(j).getFunctor();
          if(!(ff1.equals(ff2))) {
            return false;
          }
        }
      }
      return true;
    }
    
    // ルールセットの比較
    public static boolean rulesetEq(Membrane m1, Membrane m2) {
      ArrayList a1 = m1.getRuleset();
      ArrayList a2 = m2.getRuleset();
      
      RulesetComparator rc = new RulesetComparator();
      Collections.sort(a1,rc);
      Collections.sort(a2,rc);
      
      Iterator it1 = a1.iterator();
      while(it1.hasNext()) {
        Iterator it2 = a2.iterator();
        String s1 = ((Ruleset)it1.next()).encode();
        String s2 = ((Ruleset)it2.next()).encode();
        if(!(s1.equals(s2))) {
          return false;
        }
      }
      return true;
    }
  }
:].

H = contains(Src,Dst) :- H =
[:/*inline*/
  Atom a1 = me.nthAtom(0).nthAtom(0);
  Atom a2 = me.nthAtom(1).nthAtom(0);
  Membrane m1 = (Membrane)(a1.getMem());
  Membrane m2 = (Membrane)(a2.getMem());
  Iterator it1 = m1.memIterator();
  Iterator it2 = m2.memIterator();
  
  boolean eq = false;
  if(it1.hasNext()) {
    Membrane mm1 = (Membrane)it1.next();
    while(it2.hasNext()) {
      Membrane mm2 = (Membrane)it2.next();
      if(C.memEq(mm1,mm2)) {
        Atom a = mem.newAtom(new Functor("true",1));
        mem.relinkAtomArgs(a,0,me,2);
        eq = true;
        break;
      }
    }
    if(!eq) {
      Atom a = mem.newAtom(new Functor("false",1));
      mem.relinkAtomArgs(a,0,me,2);
    }
  }
  me.nthAtom(0).nthAtom(0).nthAtom(1).remove();
  me.nthAtom(1).nthAtom(0).nthAtom(1).remove();
  me.remove();
:](Src,Dst).

% sample
res = contains(S,D).
S={{a. a:-b. b:-c.},'+'(X1)}, X1=mem1.
D={{b. a:-b. b:-c.},'+'(X2)}, X2=mem2.
