[:/*inline_define*/
  import test.Node;
  import test.Tableau;
:].

% preprocess
pre={$p,@p}/ :- $p.
pre={
% LTL formula
res = create_graph(F).
//F=until(a,until(b,c)).
F=(future(global(p))).

% preprocess rules
// F ¦× ¢Î True U ¦×
H = future(Psi) :- H = until(true,Psi).
// G ¦× ¢Î False R ¦×
H = global(Psi) :- H = release(false,Psi).
// ¢Ì(¦Ì U ¦Ç) = (¢Ì¦Ì) R (¢Ì¦Ç)
H = not(until(Mu,Eta)) :- H = release(not(Mu),not(Eta)).
// ¢Ì(¦Ì R ¦Ç) = (¢Ì¦Ì) U (¢Ì¦Ç)
H = not(release(Mu,Eta)) :- H = until(not(Mu),not(Eta)).
// ¢ÌX¦Ì = X¢Ì¦Ì
H = not(next(Mu)) :- H = next(not(Mu)).
// boolean equivalences
H = implication(G1,G2) :- ground(G1),ground(G2) | H = or(not(G1),G2).
H = not(not(G)) :- ground(G) | H = G.
H = not(and(G1,G2)) :- ground(G1),ground(G2) | H = or(not(G1),not(G2)).
H = not(or(G1,G2)) :- ground(G1),ground(G2) | H = and(not(G1),not(G2)).
}.


% function create_graph
H = create_graph(Psi) :- ground(Psi) | H =
[:/*inline*/
  ArrayList<Integer> incoming = new ArrayList<Integer>(); incoming.add(-1);
  HashSet<Link> older = new HashSet<Link>();
  HashSet<Link> newer = new HashSet<Link>(); newer.add(me.getArg(0));
  HashSet<Link> next = new HashSet<Link>();
  HashSet<Node> nodes = new HashSet<Node>();
  Node node = new Node(Tableau.counter++, incoming, older, newer, next);
  HashSet<Node> result = Tableau.expand(node, nodes); // expand

  Atom resultAtom = mem.newAtom(new ObjectFunctor(result));
  mem.relinkAtomArgs(resultAtom, 0, me, 1);
  mem.removeGround(me.getArg(0));
  me.remove();

  for(Node resultNode : result) {
  	resultNode.printv();
  }
:](Psi).

% method toAutomaton
H = make(O) :- class(O, "java.util.HashSet") |
H =
[:/*inline*/
  HashSet<Node> nodes = (HashSet)((ObjectFunctor)me.nthAtom(0).getFunctor()).getObject();
  Tableau.toAutomaton(mem,nodes);
:](O).
