/*
 * Alternating Bit Protocol
 * 2007/06/19(Tue) by okabe
 * 
 * データは通信路上で損失・重複・破損する可能性がある
 * ただしプロセスはデータの破損を検出することができる
 * fairnessは仮定していない（損失・重複・破損が無限回繰り返されうる）
 * 
 * 参考
 * Alternating bit protocol - Wikipedia
 *  http://en.wikipedia.org/wiki/Alternating_bit_protocol
 * Promela Reference -- timeout(5)
 *  http://spinroot.com/spin/Man/timeout.html
 */

//妄想
//define
// p@@ {sender,out([msg(I,0)|T],SR),$p[SR|*X],@p} :- int(I),ground(T) | true.
// q@@ {sender,in(R,RS),msg=[ack(0)|R],$p[RS|*X],@p} :- true.
//LTL
// global(implication(p,future(q))).

% sender
{out([],SR), in(msg,RS), sender, expected(0), start}.
% receiver
{out([],RS), in(msg,SR), receiver, expected(0), queue([])}.

% 通信開始
start@@
{start, out([],SR), $p[SR|*X], @p} :-
	{out([msg(0,0)],SR), msgid(0), $p[SR|*X], @p}.

% 通信処理（正常）
channel_ok@@
{out([H|T],X),$p[|*Y1],@p}, {in(msg,X),$q[|*Y2],@q} :-
	ground(H), ground(T) |
	{out(T,X),$p[|*Y1],@p}, {in(M,X),msg([H|M]),$q[|*Y2],@q}.
% 通信処理（データ損失）
channel_loss@@
{out([H|T],X),$p[|*Y1],@p}, {in(msg,X),$q[|*Y2],@q} :-
	ground(H), ground(T) |
	{out(T,X),$p[|*Y1],@p}, {in(msg,X),$q[|*Y2],@q}.
% 通信処理（データ重複）
channel_dupulication@@
{out([H|T],X),$p[|*Y1],@p}, {in(msg,X),$q[|*Y2],@q} :-
	ground(H), ground(T) |
	{out([H|T],X),$p[|*Y1],@p}, {in(M,X),msg([H|M]),$q[|*Y2],@q}.
% 通信処理（データ破損）
channel_corruption@@
{out([H|T],X),$p[|*Y1],@p}, {in(msg,X),$q[|*Y2],@q} :-
	ground(H), ground(T) |
	{out(T,X),$p[|*Y1],@p}, {in(M,X),msg([corrupted|M]),$q[|*Y2],@q}.

% 送り手（正常に受信）
send_ok@@
{sender,out(S,SR),in(R,RS),msg=[ack(B)|R],expected(E),msgid(I),$p[SR,RS|*X],@p} :-
	B=:=E, B2=(B+1) mod 2, E2=B2, I2=I+1, ground(S) |
	{sender,out(list.append(S,[msg(I2,B2)]),SR),in(msg,RS),expected(E2),msgid(I2),$p[SR,RS|*X],@p}.
% 送り手（制御ビットが期待通りでない場合）
send_ng_bit@@
{sender,out(S,SR),in(R,RS),msg=[ack(B)|R],expected(E),msgid(I),$p[SR,RS|*X],@p} :-
	B=\=E, int(I), ground(S) |
	{sender,out(list.append(S,[msg(I,E)]),SR),in(msg,RS),expected(E),msgid(I),$p[SR,RS|*X],@p}.
% 送り手（返答が返ってこない場合）
timeout@@
{sender,out([],SR),in(msg,RS),expected(E),msgid(I),$p[|*X1],@p}/, 
{receiver,out([],RS),in(msg,SR),$q[|*X2],@q}/ :-
	int(E), int(I) |
	{sender,out([msg(I,E)],SR),in(msg,RS),expected(E),msgid(I),$p[|*X1],@p},
	{receiver,out([],RS),in(msg,SR),$q[|*X2],@q}.
% 送り手（データ破損）
sender_corruption@@
{sender,out(S,SR),in(R,RS),msg=[corrupted|R],expected(E),msgid(I),$p[SR,RS|*X],@p} :-
	int(E), int(I), ground(S) |
	{sender,out(list.append(S,[msg(I,E)]),SR),in(msg,RS),expected(E),msgid(I),$p[SR,RS|*X],@p}.

% 受け手（正常に受信）
recv_ok@@
{receiver,out(S,RS),in(R,SR),msg=[msg(I,B)|R],expected(E),queue(Q),$p[RS,SR|*X],@p} :-
	B=:=E, E2=(E+1) mod 2, int(I), ground(S), ground(Q) |
	{receiver,out(list.append(S,[ack(B)]),RS),in(msg,SR),expected(E2),queue([msg(I)|Q]),$p[RS,SR|*X],@p}.
% 受け手（制御ビットが期待通りでない場合）
recv_ng_bit@@
{receiver,out(S,RS),in(R,SR),msg=[msg(I,B)|R],expected(E),$p[RS,SR|*X],@p} :-
	B=\=E, B2=(E+1) mod 2, int(I), ground(S) |
	{receiver,out(list.append(S,[ack(B2)]),RS),in(msg,SR),expected(E),$p[RS,SR|*X],@p}.
% 受け手（データ破損）
receiver_corruption@@
{receiver,out(S,RS),in(R,SR),msg=[corrupted|R],expected(E),$p[RS,SR|*X],@p} :-
	B2=(E+1) mod 2, ground(S) |
	{receiver,out(list.append(S,[ack(B2)]),RS),in(msg,SR),expected(E),$p[RS,SR|*X],@p}.
