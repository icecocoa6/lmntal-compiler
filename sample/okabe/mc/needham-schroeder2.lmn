/*
 * Needham-Schroeder Public Key Protocol
 * 2007/12/01(Sat) by okabe
 * 
 * ２つの主体が公開鍵を用いて互いのノンスを交換する
 * 名前管理はアトム名で行う
 *
 * A->B: {Na,A}Kb
 * B->A: {Na,Nb}Ka
 * A->B: {Nb}Kb
 *
 * 参考
 * Needham-Schroeder protocol - Wikipedia
 *  http://en.wikipedia.org/wiki/Needham-Schroeder
 */

/* 
 * TODO:
 * 主体の挙動を表すルールは主体を表す膜の中に書くべき
 * （SLIMにモジュール機能が欲しい）
 */

% principal
initiator1@@
princ{id(I0, L), conn_to(X0), send{$s}, knonce{$k}, nonce_gen(N), $p} :-
  unary(I0), unary(X0), N2=N+1 |
princ{id(I0, L), send{enc{pubk(X0), nonce(N), id(I0)}, $s}, state_send(X0, N), knonce{nonce(N), $k},
  nonce_gen(N2), $p}.

initiator2@@
princ{id(I0, L), state_send(X0, N0), recv{enc{pubk(I1), nonce(NX0), nonce(N1)}, $r}, send{$s}, knonce{$k}, $p} :-
  unary(I0), unary(X0), unary(N0), unary(I1), unary(NX0), unary(N1), I0==I1, N0==N1 |
princ{id(I0, L), recv{$r}, send{enc{pubk(X0), nonce(NX0)}, $s}, knonce{nonce(NX0), $k}, est_to(X0), $p}.

responder1@@
princ{id(I0, L), recv{enc{pubk(I1), nonce(NX0), id(X0)}, $r}, send{$s}, knonce{$k}, nonce_gen(N), $p} :-
  unary(I0), unary(I1), unary(NX0), unary(X0), I0==I1, N2=N+1 |
princ{id(I0, L), recv{$r}, send{enc{pubk(X0), nonce(N), nonce(NX0)}, $s}, state_recv(X0, N),
  knonce{nonce(N), nonce(NX0), $k}, nonce_gen(N2), $p}.

responder2@@
princ{id(I0, L), state_recv(X0, N0), recv{enc{pubk(I1), nonce(N1)}, $r}, $p} :-
  unary(I0), unary(X0), unary(N0), unary(I1), unary(N1), I0==I1, N0==N1 |
princ{id(I0, L), recv{$r}, est_from(X0), $p}.

% network
send@@
princ{send{$s[]}, $p}, nodes=L :- \+($s=()) | princ{send{}, $p}, nodes=bcast({{$s[]}}, L).

recv@@
Res = bcast({{$s[]}}, [H|T]), princ{id(I,H), recv{$r}, $p} :- unary(I) |
Res = [H|bcast({{$s[]}}, T)], princ{id(I,H), recv{$s[], $r}, $p}.

gc@@
Res = bcast({$s[]}, []) :- Res=[].

% simulation
nodes=[X0, X1].
princ{id(a, X0), conn_to(b), recv{}, send{}, knonce{}, nonce_gen(100)}.
princ{id(b, X1), recv{}, send{}, knonce{}, nonce_gen(200)}.

