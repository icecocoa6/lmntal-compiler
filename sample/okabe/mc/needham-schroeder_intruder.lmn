/*
 * Needham-Schroeder with intruder
 * 2007/12/28(Fri) by okabe
 *
 * A->B : {A,Na}Kb
 * B->A : {Na,Nb}Ka
 * A->B : {Nb}Kb
 *
 * @see
 *   I. Cervesato, N.A. Durgin, P.D. Lincoln, J.C. Mitchell, A. Scedrov.
 *   A Meta-notation for Protocol Analysis, 1999
 */

% system rule
t0_init{

initiator(alice,bob), responder(bob).
use_(5), gen(0).

% initiator role
i1@@
initiator(A,B) :- unary(A), unary(B) |
  n([asym(k(pubK,B), [n(NA1),p(A)])]),
  l(p(A),p(B),k(pubK,B),n(NA2)),
  nonce{'+'(NA1), '+'(NA2)}.

i2@@
n([asym(k(pubK,A1), [n(NA1),n(NB1)])]), l(p(A2),p(B1),k(pubK,B2),n(NA2)),
  nonce{'+'(NA1),'+'(NA2),$na}, nonce{'+'(NB1),$nb} :-
  A1==A2, B1==B2 |
  n([asym(k(pubK,B1), [n(NB2)])]),
  nonce{$na},
  nonce{'+'(NB2),$nb}.

% responder role
r1@@
responder(B1), n([asym(k(pubK,B2), [n(NA1),p(A)])]), nonce{'+'(NA1),$p} :-
  unary(A), B1==B2 |
  n([asym(k(pubK,A), [n(NA2),n(NB1)])]),
  l(B1,k(pubK,B1),k(privK,B1),p(A),n(NA3),k(pubK,A),n(NB2)),
  nonce{'+'(NA2),'+'(NA3),$p},
  nonce{'+'(NB1),'+'(NB2)}.

r2@@
n([asym(k(pubK,B1), [n(NB1)])]), l(B2,k(pubK,B3),k(privK,B4),p(A1),n(NA1),k(pubK,A2),n(NB2)),
  nonce{'+'(NB1),'+'(NB2),$nb}, nonce{'+'(NA1),$na} :-
  A1==A2, B1==B2, B2==B3, B3==B4 |
  nonce{$nb}, nonce{$na}.

% gc
gc@@
nonce{} :- .

% intruder role
%% I/O rules
rec@@
n(T) :- d(T).

snd@@
c(T) :- n(T).

%% decomposition rules
dcmp@@
d([H1,H2|T]) :- d([H1]), d([H2|T]).

lrn_p@@
d([p(A)]) :- a([p(A)]).
lrn_k@@
d([k(A)]) :- a([k(A)]).
lrn_n@@
d([n(A)]) :- a([n(A)]).

lrn_aux@@
d([asym(k(K,T),X)]) :- a([cp([asym(k(K,T),X)],[],aux)]).
dec_aux@@
a([k(T1,K1)]), aux(asym(k(T2,K2), T)) :- T1==T2, K1==K2 | a(T).

%% composition rules
comp@@
c(T1), c(T2) :- c(append(T1,T2)).

use_@@
use_(N1), a(T) :- N1>0, N2=N1-1 | use_(N2), a(cp(T,[],c)).

enc@@
enc(N1), c(X), a([k(T,K)]) :- N1>0, N2=N1-1, unary(T), unary(K) | enc(N2), c([asym(k(T,K), X)]), a([k(T,K)]).

gen@@
gen(N1) :- N1>0, N2=N1-1 | gen(N2), m([n(N)]), nonce{'+'(N)}.

/* auxiliary rules for copying */
/* 多重暗号化に未対応 */
/* コピー中に他の操作をされるのを防ぐため膜で制御する */
cp_1@@
Res=cp([SrcH|SrcT], Dst, Func) :- ground(SrcH) | Res=[SrcH|cp(SrcT, append(Dst,[SrcH]), Func)].
cp_2@@
Res=cp([n(nonce{$n})|SrcT], Dst, Func) :- Res=[n(nonce{'+'(N),$n})|cp(SrcT, append(Dst, [n(N)]), Func)].
cp_3@@
Res=cp([], Dst, Func) :- ground(Func) | Res=[], Func=Dst.
cp_aux@@
Res=cp([asym(k(K,T),X)],D1,Func) :- unary(K), unary(T),unary(Func) | Res=asym(k(K,T),cp(X,D1,aux([asym(k(K,T))]))).

/* auxiliary rules for message concatenation */
append@@ R=append([],L) :- R=L.
append@@ R=append([H|T], L) :- R=[H|append(T, L)].

}.

/*
% property rule
ltl_1@@
t0_init{$p,@p} :- t0_init{$p,@p}.
ltl_2@@
t0_init{m(N1),m(N2),l2(B,N3,N4),nonce{'+'(N1),'+'(N3),$n1},nonce{'+'(N2),'+'(N4),$n2},$p,@p} :-
  accept_all_end{m(N1),m(N2),l2(B,N3,N4),nonce{'+'(N1),'+'(N3),$n1},nonce{'+'(N2),'+'(N4),$n2},$p,@p}.
*/

/* ltl2ba output (never claim)
> ~/workspace/mc/ltl2ba-1.0/ltl2ba -f '!([]!(p))'
never {
T0_init:
        if
        :: (1) -> goto T0_init
        :: (p) -> goto accept_all
        fi;
accept_all:
        skip
}
*/

/* literal definition
p@@
{ m(N1),m(N2),l2(B,N3,N4),nonce{'+'(N1),'+'(N3),$n1},nonce{'+'(N2),'+'(N4),$n2}, $p, @p } :- { $p, @p }.
*/
