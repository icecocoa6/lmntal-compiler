% chat simulation
% 分散シミュレーション（チャット）
% 受信リスト正順

{% brie: client
connect("gouda",60000,S,R).
S=["hello,brie","brie to gouda."].
R=[].
}.

{% pave: client
connect("gouda",60000,S,R).
S=["hello,pave!","pave to gouda."].
R=[].
}.

{% murol: client
connect("gouda",60000,S,R).
S=["hello,murol!","murol to gouda"].
R=[].
}.

{% gouda: server
port(60000,G).
G=[accept(S1,R1),accept(S2,R2),accept(S3,R3)].
S1=[],S2=[],S3=[],R1=[],R2=[],R3=[].
socket(C1,S1,[H|T]),socket(C2,S2,R2),socket(C3,S3,R3) :- string(H) |
  socket(C1,list.append(S1,[H]),T),
  socket(C2,list.append(S2,[H]),R2),
  socket(C3,list.append(S3,[H]),R3).
}.

% connect and accept rule
{connect(Host,Port1,S1,R1),$p[S1,R1|*C],@p},
{port(Port2,[accept(S2,R2)|T]),$q[S2,R2,T|*C],@q} :- 
  string(Host),Port1=:=Port2 |
    {socket(C,S1,R1),$p[S1,R1|*C],@p},
    {port(Port2,T),socket(C,S2,R2),$q[S2,R2,T|*C],@q}.

% send and receive rule
{socket(C,[H|T],R1),$p[T,R1|*C],@p},
{socket(C,S2,R2),$q[S2,R2|*C],@q} :- string(H) |
  {socket(C,T,R1),$p[T,R1|*C],@p},
  {socket(C,S2,list.append(R2,[H])),$q[S2,R2|*C],@q}.
