[:/*inline_define*/
  class C {
    public static HashSet visited = new HashSet(); // for traverse
    public static HashSet checked = new HashSet(); // for until
    
    // リダクショングラフの全点を走査する．
    public static boolean traverse(Atom from, Functor p, Functor q) {
      // アトムfrom の接続先to を取得する．
      Atom to = from.nthAtom(0).nthAtom(0).nthAtom(1).nthAtom(1).nthAtom(0).nthAtom(1);
      Iterator ii = to.getMem().atomIteratorOfFunctor(new SymbolFunctor("id",1));
      Integer id = new Integer(((IntegerFunctor)((Atom)ii.next()).nthAtom(0).getFunctor()).intValue());
//System.out.print("traverse: ");
//System.out.println(id);
//System.out.println(to.getMem());
      if(visited.contains(id)) {
        return true; // Strong Until
      }
      visited.add(id);
      
      // 現時点を起点としてすべてのパスでuntil が成立することを確認する．
      if(!until(from, p, q))
        return false;
      
      // 遷移先について再帰する．
      Iterator it = to.getMem().atomIteratorOfFunctor(from.getFunctor());
      while(it.hasNext()) {
        Atom nextFrom = (Atom)it.next();
        if(!traverse(nextFrom, p, q)) {
//System.out.println("id = " + id + ": traverse is false");
          return false;
        }
      }
//System.out.println("id = " + id + ": traverse is true");
      Atom aatom = to.getMem().newAtom(new SymbolFunctor("p",1));
      Atom batom = to.getMem().newAtom(new SymbolFunctor("("+p.getName()+" U "+q.getName()+")",1));
      to.getMem().newLink(aatom,0,batom,0);
      return true;
    }
    
    // 基準点からすべてのパスについてuntil が成立することを確認する．
    public static boolean until(Atom from, Functor p, Functor q) {
      // アトムfrom の接続先to を取得する．
      Atom to = from.nthAtom(0).nthAtom(0).nthAtom(1).nthAtom(1).nthAtom(0).nthAtom(1);
      Iterator ii = to.getMem().atomIteratorOfFunctor(new SymbolFunctor("id",1));
      Integer id = new Integer(((IntegerFunctor)((Atom)ii.next()).nthAtom(0).getFunctor()).intValue());
//System.out.print("until: ");
//System.out.println(id);
//System.out.println(to.getMem());
      if(checked.contains(id)) return false; // Strong Until
      checked.add(id);

      // q が成立->return true
      Iterator iq = to.getMem().atomIteratorOfFunctor(q);
//System.out.print(q + ": ");
      if(iq.hasNext()) {
        checked.remove(id);
//System.out.println("true");
        return true;
      }
//System.out.println("false");
      
      // p が不成立->return false
      Iterator ip = to.getMem().atomIteratorOfFunctor(p);
//System.out.print(p + ": ");
      if(!(ip.hasNext())) {
        checked.remove(id);
//System.out.println("false");
        return false;
      }
//System.out.println("true");

      // X(pUq) が成立->return true
      Iterator it = to.getMem().atomIteratorOfFunctor(from.getFunctor());
      if(!(it.hasNext())) {
        System.out.println("id = " + id + ": (X (p U q)) is false"); // Strong Until
        return false;
      }
      while(it.hasNext()) {
        Atom nextFrom = (Atom)it.next();
        if(!(until(nextFrom,p,q))) {
          checked.remove(id);
//System.out.println("id = " + id + ": (X (p U q)) is false");
          return false;
        }
      }
      checked.remove(id);
//System.out.println("id = " + id + ": (X (p U q)) is true");
      return true;
    }
  }
:].


check(M,[C1,C2,C3,C4,C5]).
check({$p,@p}/,[{$q,@q}|L]) :- check({$p,@p,$q,@q},L).
check({$p,@p},[]) :- {$p,@p}.

M={
  nd.exec({{
    init.
    init :- a,s.
    a:-b. b:-d. d:-c. c:-b.
  }*}).
  nd.genid.
  % 下で定めた原始論理式を用いてLTL式を記述する．
  ret = ltl(u(has_s, has_c)).
}.

% まず原始論理式を定義する．
% has_s: there exists s
% has_c: there exists c
C1={{id(I),{s,$p,@p}*,$q,@q} :- uniq(I) | {id(I),p(has_s),{s,$p,@p}*,$q,@q}}.
C2={{id(I),{$p,@p}*,$q,@q} :- uniq(I),\+($p=(s,$pp)) | {id(I),p(not_has_s),{$p,@p}*,$q,@q}}.
C3={{id(I),{c,$p,@p}*,$q,@q} :- uniq(I) | {id(I),p(has_c),{c,$p,@p}*,$q,@q}}.
C4={{id(I),{$p,@p}*,$q,@q} :- uniq(I),\+($p=(c,$pp)) | {id(I),p(not_has_c),{$p,@p}*,$q,@q}}.

% U: Until
% H = u(P,Q,A) が実行されると，それを満たす膜にアトムA ができる．
% or
% H = u(P,Q) が実行されると，それを満たす膜にアトム'PUQ' ができる．

C5={
H = u(P,Q), {id(I),{init,$p,@p}*,$q,@q} :- uniq(I),unary(P),unary(Q) |
  H = [:/*inline*/
	Atom out = me.nthAtom(0);
	Atom in = out.nthAtom(0);
	Atom plus = in.nthAtom(1);
	Membrane mem1 = (Membrane)in.getMem();
	
	Functor p = me.nthAtom(1).getFunctor();
	Functor q = me.nthAtom(2).getFunctor();
	Iterator it = mem1.atomIteratorOfFunctor(new SymbolFunctor("from",1));
	if(it.hasNext()) {
	  Atom from = (Atom)it.next();
	  if(C.traverse(from,p,q)) {
        Atom tAtom = mem.newAtom(new SymbolFunctor("("+p.getName()+" U "+q.getName()+")",1));
        mem.relinkAtomArgs(tAtom,0,me.nthAtom(3),0);
      } else {
	    Atom fAtom = mem.newAtom(new SymbolFunctor("not("+p.getName()+" U "+q.getName()+")",1));
	    mem.relinkAtomArgs(fAtom,0,me.nthAtom(3),0);
	  }
	}

	mem.removeAtom(me);
	mem.removeAtom(out);
	mem1.removeAtom(in);
	plus.dequeue();
	mem1.removeAtom(plus);
  :]({id(I),{init,$p,@p}*,$q,@q},P,Q).
}.
