% chat simulation
% 分散シミュレーション（チャット）
% 受信リスト逆順

{% brie: client
connect("gouda",60000,S,R).
S=["hello,brie!","brie to gouda."].
R=recv.
}.

{% pave: client
connect("gouda",60000,S,R).
S=["hello,pave!","pave to gouda."].
R=recv.
}.

{% murol: client
connect("gouda",60000,S,R).
S=["hello,murol!","murol to gouda"].
R=recv.
}.

{% gouda: server
port(60000,G).
G=[accept(S1,R1),accept(S2,R2),accept(S3,R3)].
recv(R1,S1),recv(R2,S2),recv(R3,S3).
% server's rule
S1=recv([H|T]),S2=recv(R2),S3=recv(R3):- string(H) |
  S1=[H|recv(T)],
  S2=[H|recv(R2)],
  S3=[H|recv(R3)].
}.

% connect and accept rule
{connect(Host,Port1,S1,R1),$p[S1,R1|*C],@p},
{port(Port2,[accept(S2,R2)|T]),$q[S2,R2,T|*C],@q} :- 
  string(Host),Port1=:=Port2 |
    {socket(C,S1,R1),$p[S1,R1|*C],@p},
    {port(Port2,T),socket(C,S2,R2),$q[S2,R2,T|*C],@q}.

% send and receive rule
{socket(C,[H|T],R1),$p[T,R1|*C],@p},
{socket(C,S2,R2),$q[S2,R2|*C],@q} :-
  string(H) |
    {socket(C,T,R1),$p[T,R1|*C],@p},
    {socket(C,S2,RR2),$q[S2,R2|*C],@q,
      RR2 = 
      [:/*inline*/
        String str = me.nth(0);
        Atom dataAtom = mem.newAtom(new StringFunctor(str));
        Atom consAtom = mem.newAtom(new Functor(".",3));
        mem.newLink(consAtom,0,dataAtom,0);
        mem.unifyAtomArgs(me,1,me,2);
        mem.relinkAtomArgs(consAtom,2,me.nthAtom(2),2);
        mem.newLink(consAtom,1,me.nthAtom(2),2);
        me.nthAtom(0).remove();
        me.remove();
      :](H,R2)}.
