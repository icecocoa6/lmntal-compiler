	public static String groundString(List<Link> linklist){
		// 2引数で、ただのリンクにマッチする場合"Link"を特別に返す
		if(linklist.size() == 2){
			Link l1 = linklist.get(0);
			Link l2 = linklist.get(1);
			if(l1 == l2.getBuddy())return "Link";
		}
		Set<Atom> srcSet = new HashSet<Atom>(); // 辿ったアトム
		Stack<Link> s = new Stack<Link>(); //リンクを積むスタック
		HashMap<Link, String> linkStr = new HashMap<Link, String>(); // リンク -> リンク名
		StringBuffer sb = new StringBuffer();
		int linkNo=0;
		s.push(linklist.get(0)); // 第1引数から辿る
//		s.push(this);
		while(!s.isEmpty()){
			Link l = s.pop();
			Atom a = l.getAtom();
			if(srcSet.contains(a))continue; //既に辿ったアトム
			sb.append(a.getFunctor().getName());
			sb.append("(");
			srcSet.add(a);
			for(int i=0;i<a.getArity();i++){
				Link l0 = a.args[i];
				Link l1 = l0.getBuddy();
				int argi = linklist.indexOf(l1);
				if(argi >= 0){ // プロセス文脈の引数にマッチした場合、"F+<引数番号>"をリンク名として加える
					sb.append("F"+argi);
				}else{
					if(!linkStr.containsKey(l0)) {
						String ss="L"+(linkNo++);
						linkStr.put(l0, ss);
						linkStr.put(l1, ss);
					}
					sb.append(linkStr.get(l0));
					if(i==l.getPos())continue;
					s.push(a.getArg(i));
				}
			}
			sb.append(")");
			System.out.println(sb.toString());//seiji
		}
		System.out.println(sb.toString()); //seiji
		return sb.toString();
	}
	public String groundString(){
		List<Link> linklist = new ArrayList<Link>();
		linklist.add(this);
		return Link.groundString(linklist);
	}