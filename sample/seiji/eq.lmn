/*
 * CHR(SWI-Prolog)にならったX=Yの振る舞いを提供(できてるつもり)
 * 各階層で定義
 * 
 * X=Y <=> eq(X, Y)
 * 変数 X <=> var(X)
 * (X;Y) <=> ";"(X, Y)
 *   X,Yに=式でないものがくる場合には対応していない。しかし=式でない場合は、モジュール使わないで簡単に書けるのでユーザ頑張れ。
 * 複数true, falseの整理
 * 
 */
	
{

module(eq).

%eq($p, $q) :- $p=:=$q | true.
%eq($p, $q) :- $p=\=$q | false.

eq(X, Y), $p[X], $q[Y] :- unary($p), unary($q), $p=$q | true.
eq(X, Y), $p[X], $q[Y] :- unary($p), unary($q), $p\=$q | false.


true, true   :- true. 
false, false :- false.
false, true  :- false.


/*
 * (X ; Y)は今のところ使わない
 * 
 */


/*
";"(X, Y) :- ";"(X, Y, r1, r2).

%var型無し
";"(eq(A, B), C, r1, D) :- unary(A), unary(B), A=B  | ";"(eq(A, B), C, true,  D).
";"(eq(A, B), C, r1, D) :- unary(A), unary(B), A\=B | ";"(eq(A, B), C, false, D).
";"(A, eq(B, C), D, r2) :- unary(B), unary(C), B=C  | ";"(A, eq(B, C), D, true ).
";"(A, eq(B, C), D, r2) :- unary(B), unary(C), B\=C | ";"(A, eq(B, C), D, false).

%EQ1がvar型を含むときは、EQ2の結果に関わらずEQ1を出力
";"(eq(var(A), B), EQ2, R1,    R2) :- ground(EQ2), unary(R1) , unary(R2) | eq(var(A), B).
";"(eq(A, var(B)), EQ2, R1,    R2) :- ground(EQ2), unary(R1) , unary(R2) | eq(A, var(B)).
%EQ1がfalse、EQ2がvar型を含むときは、EQ2を出力
";"(EQ1, eq(var(C), D), false, R2) :- ground(EQ1),             unary(R2) | eq(var(C), D).
";"(EQ1, eq(C, var(D)), false, R2) :- ground(EQ1),             unary(R2) | eq(C, var(D)).

%EQ1がtrueならEQ1, EQ1がfalseかつEQ2がtrueならEQ2, どちらもfalseならfalseを出力
";"(eq(A, B), EQ2, true , R2)    :- ground(EQ2), unary(R2)   | eq(A, B).
";"(EQ1, eq(C, D), false, true)  :- ground(EQ1)	 		     | eq(C, D).
";"(EQ1, EQ2     , false, false) :- ground(EQ1), ground(EQ2) | false.
*/


}.