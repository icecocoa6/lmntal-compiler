%
% Monkey and Bananas:
%
% Forward chaining rules via CHR.
% rules inspired from ftp://ftp.cs.unibo.it:/pub/gaspari/fw_rules/
% Quite fast because no dynamic predicates are used to
% represent the facts.
% The amount of code generated is substantial however.
% Not optimized
%
% 970213 Christian Holzbaur

/*
:- use_module(library(chr)).

handler monkey.

constraints phys_object/7, monkey/3, goal/5, found/0.
% explaination of constraints is missing here

:- op(900,fy,not).
% There is no such fact ('not exists' in SQL)
not Fact :- find_constraint( Fact, _), !, fail.
not _.


testcase(1) :-
	phys_object(bananas,9-9,light,ceiling,_,_,ok),
	phys_object(couch,7-7,heavy,floor,_,low,_),
	phys_object(ladder,4-3,light,floor,_,high,_),
	phys_object(blanket,7-7,light,_,_,_,_),
	phys_object(garbage_can,3-5,light,floor,_,low,_),
	monkey(7-7,couch,blanket),
	goal(active,holds,bananas,_,_).
*/
testcase(1) :-
  phys_object(bananas,9-9,light,ceiling,"_","_",ok),
  phys_object(couch,7-7,heavy,floor,"_",low,"_"),
  phys_object(ladder,4-3,light,floor,"_",high,"_"),
  phys_object(blanket,7-7,light,"_","_","_","_"),
  phys_object(garbage_can,3-5,light,floor,"_",low,"_"),
  monkey(7-7,couch,blanket),
  goal(active,holds,bananas,"_","_").

  goal(active,holds,bananas,"_","_").



io.use.

functor1(floor).
functor2(nothing).
functor3(ladder).
functor4(ceiling).

/*
 rule(1) @
  goal(active,on,floor,A,B), 
    monkey(D,E,F) <=>

    E\==floor
    |
    write('Jump onto the floor'),
    nl,
    monkey(D,floor,F),
    goal(satisfied,on,floor,A,B).
*/
rule1 @@
	functor1(Func) \
	goal(active, on, floor, A, B), 
	monkey(D, E, F) 
	 :-
		E\=Func | 
			io.println("Jump onto the floor.", res), 
			nl, 
			monkey(D, floor, F), 
			goal(satisfied, on, floor, A, B).
//goal(active, on, floor, a, b), monkey(d, e, f).

/*
 rule(2) @
  monkey(A,floor,B) \ 
    goal(active,on,floor,D,E) <=>

    write('Monkey is already on floor'),
    nl,
    goal(satisfied,on,floor,D,E).
*/
rule2 @@
	monkey(A, floor, B) \ 
	goal(active, on, floor, D, E) :-
		io.println("Monkey is already on floor.", res), 
		nl, 
		goal(satisfied, on, floor, D, E).
 
/*
 rule(3) @
  phys_object(A,B,C,floor,D,E,F) \ 
    goal(active,on,A,H,I), 
      monkey(B,K,nothing) <=>

      K\==A
      |
      write('Climb onto '),
      write(A),
      nl,
      monkey(B,A,nothing),
      goal(satisfied,on,A,H,I).
*/
rule3 @@
	phys_object(A1, B1, C, floor, D, E, F) \ 
	goal(active, on, A2, H, I), 
	monkey(B2, K, nothing) :-
		A1=A2, B1=B2, K\=A1 |
			io.print("Climb onto ", res),
			io.println(A1, res),
			nl,
			monkey(B1, A1, nothing),
			goal(satisfied, on, A1, H, I).
//phys_object(a, b, c, floor, d, e, f),goal(active, on, a, h, i),monkey(b, k, nothing).

/*
 rule(4) @
  goal(active,on,A,B,C), 
    phys_object(A,E,F,G,H,I,J), 
      monkey(E,L,M) ==>

      M\==nothing
      |
      write('Put '),
      nl,
      goal(active,holds,nothing,O,P).
*/
rule4 @@ 
	goal(active, on, A1, B, C), 
	phys_object(A2, E1, F, G, H, I, J),
	monkey(E2, L, M),
	functor2(Func) \:-
		A1=A2, E1=E2, M\=Func, 
		uniq(A1, B, C, A2, E1, F, G, H, I, J, E2, L, M, Func) |
			io.print("Put "), 
			nl, 
			goal(active, holds, nothing, o, p).	
	
/*
 rule(5) @
  goal(active,on,A,B,C), 
    phys_object(A,E,F,floor,G,H,I), 
      monkey(K,L,M) ==>

      K\==E
      |
      goal(active,at,nothing,O,E).
*/
rule5 @@
	goal(active, on, A1, B, C),
	phys_object(A2, E, F, floor, G, H, I),
	monkey(K, L, M) \:-
		K\=E |
			goal(active, holds, nothing, o, p).			

/*
 rule(6) @
  phys_object(A,B,C,floor,D,E,F), 
    monkey(B,A,H) \ 
      goal(active,on,A,J,K) <=>

      write('Monkey is already on '),
      write(A),
      nl,
      goal(satisfied,on,A,J,K).
*/
rule6 @@
	phys_object(A1,B1,C,floor,D,E,F), 
	monkey(B2,A2,H) \ 
	goal(active,on,A3,J,K) :-
		A1=A2, A1=A3 |
			io.print("Monkey is already on ", res),
			io.println(A1, res),
			nl,
			goal(satisfied,on,A1,J,K).
			
/*
 rule(7) @
  goal(active,holds,nothing,A,B), 
    monkey(D,E,F), 
      phys_object(F,H,I,J,K,L,M) <=>

      F\==nothing
      |
      write('Drop '),
      write(F),
      nl,
      goal(satisfied,holds,nothing,A,B),
      monkey(D,E,nothing),
      phys_object(F,H,I,floor,K,L,M).
*/
rule7 @@
	functor2(Func) \
	goal(active, holds, nothing, A, B), 
	monkey(D, E, F1), 
	phys_object(F2, H, I, J, K, L, M) :-
		F1=F2, F1\=Func, unary(J) |
			io.print("Drop ", res),
			io.println(F1, res),
			nl,
			goal(satisfied, holds, nothing, A, B),
			monkey(D, E, nothing),
			phys_object(F1, H, I, floor, K, L, M).

/*
 rule(8) @
  goal(active,holds,nothing,A,B), 
    monkey(D,E,nothing) ==>

    write('Monkey is holding nothing'),
    nl,
    goal(satisfied,holds,nothing,A,B).
*/
rule8 @@
	goal(active, holds, nothing, A, B),
	monkey(D, E, nothing) \:-
		uniq(A, B, D, E) |
			io.println("Monkey is holding, nothing", res),
			nl,
			goal(satisfied, holds, nothing, A, B).
			
/*
 rule(9) @
  phys_object(ladder,A,B,floor,C,D,E) \ 
    goal(active,holds,G,H,I), 
      phys_object(G,A,light,ceiling,K,L,M), 
        monkey(O,ladder,nothing) <=>

        not phys_object(Q,R,S,G,T,U,V)
        |
        write('Grab '),
        write(G),
        nl,
        monkey(O,ladder,G),
        phys_object(G,A,light,nothing,K,L,M),
        goal(satisfied,holds,G,H,I).
*/
rule9 @@
	phys_object(ladder, A1, B, floor, C, D, E) \
	goal(active, holds, G1, H, I),
	phys_object(G2, A2, light, ceiling, K, L, M),
	monkey(O, ladder, nothing) :-
		A1=A2, G1=G2 |
			io.print("Grab ", res),
			io.println(G1, res),
			nl,
			monkey(O, ladder, G1),
			phys_object(G1, A1, light, nothing, K, L, M),
			goal(satisfied, holds, G1, H, I).
			
/*
 rule(10) @
  goal(active,holds,A,B,C), 
    phys_object(A,E,light,ceiling,F,G,H), 
      phys_object(ladder,E,J,floor,K,L,M), 
        monkey(O,P,Q) ==>

        P\==ladder
        |
        goal(active,on,ladder,S,T).
*/
rule10 @@
	functor3(Func),
	goal(active, holds, A1, B, C),
	phys_object(A2, E1, light, ceiling, F, G, H),
	phys_object(ladder, E2, J, floor, K, L, M),
	monkey(O, P, Q) \:-
		A1=A2, E1=E2,
		P\=Func,
		uniq(A1, B, C, A2, E1, F, G, H, E2, J, K, L, M) |
			goal(active, on, ladder, s, t).

/*
 rule(11) @
  goal(active,holds,A,B,C), 
    phys_object(A,E,light,ceiling,F,G,H), 
      phys_object(ladder,J,K,L,M,N,O) ==>

      J\==E,
      not goal(active,at,ladder,Q,E)
      |
      goal(active,at,ladder,R,E).
*/
rule11 @@
	goal(active, holds, A1, B, C),
	phys_object(A2, E, light, ceiling, F, G, H), 
	phys_object(ladder, J, K, L, M, N, O) \:- 
		A1=A2,
		J\=E,
		uniq(A1, B, C, A2, E, F, G, H, J, K, L, M, N, O) |
			goal(active, at, ladder, r, E).
			
/*
 rule(12) @
  goal(active,holds,A,B,C), 
    phys_object(A,E,light,F,G,H,I), 
      monkey(E,floor,nothing) <=>

      F\==ceiling,
      not phys_object(L,M,N,A,O,P,Q)
      |
      write('Grab '),
      write(A),
      nl,
      phys_object(A,E,light,nothing,G,H,I),
      monkey(E,floor,A),
      goal(satisfied,holds,A,B,C).
*/
rule12 @@
	functor4(Func) \
	goal(active, holds, A1, B, C),
	phys_object(A2, E1, light, F, G, H, I),
	monkey(E2, floor, nothing) :- 
		A1=A2, E1=E2,
		F\=Func |
			io.print("Grap "),
			io.println(A1),
			nl,
			phys_object(A1, E1, light, nothing, G, H, I),
			monkey(E1, floor, A1),
			goal(satisfied, holds, A1, B, C).

/*
 rule(13) @
  goal(active,holds,A,B,C), 
    phys_object(A,E,light,F,G,H,I), 
      monkey(E,F,K) ==>

      F\==ceiling,
      F\==floor
      |
      goal(active,on,floor,M,N).
*/
rule13 @@
	functor1(Func1), functor4(Func4),
	goal(active, holds, A1, B, C),
	phys_object(A2, E1, light, F1, G, H, I),
	monkey(E2, F2, K) \:-
		A1=A2, E1=E2, F1=F2,
		F1\=Func1,
		F1\=Func4 |
			goal(active, on, floor, m, n).
			
/*
 rule(14) @
  goal(active,holds,A,B,C), 
    phys_object(A,E,light,F,G,H,I), 
      monkey(K,L,M) ==>

      F\==ceiling,
      K\==E,
      not goal(active,at,nothing,O,P)
      |
      goal(active,at,nothing,Q,E).
*/
rule14 @@
	functor4(Func),
	goal(active, holds, A1, B, C),
	phys_object(A2, E, light, F, G, H, I),
	monkey(K, L, M) \:-
		A1=A2,
		F\=Func,
		K\=E,
		uniq(A1, B, C, A2, E, F, G, H, I, K, L, M) |
			goal(active, at, nothing, q, E).

/*
 rule(15) @
  goal(active,holds,A,B,C), 
    phys_object(A,E,light,F,G,H,I), 
      monkey(E,K,L) ==>

      L\==nothing,
      L\==A,
      not goal(active,holds,nothing,N,O)
      |
      goal(active,holds,nothing,P,Q).
*/
rule15 @@
	functor2(Func),
	goal(active, holds, A1, B, C),
	phys_object(A2, E1, light, F, G, H, I),
	monkey(E2, K, L) \:-
		A1=A2, E1=E2,
		L\=Func,
		L\=A1,
		uniq(A1, B, C, A2, E1, F, G, H, I, E2, K, L) |
			goal(active, holds, nothing, p, q).
			
/*
 rule(16) @
  goal(active,at,A,B,C), 
    monkey(E,floor,A), 
      phys_object(A,G,H,I,J,K,L) <=>

      E\==C
      |
      write('Move '),
      write(A),
      write(' to '),
      write(C),
      nl,
      phys_object(A,C,H,I,J,K,L),
      monkey(C,floor,A),
      goal(satisfied,at,A,B,C).
*/
rule16 @@
	goal(active, at, A1, B, C),
	monkey(E, floor, A2),
	phys_object(A3, G, H, I, J, K, L) :-
		A1=A2, A1=A3, unary(G),
		E\=C |
			io.print("Move ", res),
			io.print(A1, res),
			io.print(" to ", res),
			io.println(C, res),	
			nl,
			phys_object(A1, C, H, I, J, K, L),
			monkey(C, floor, A1),
			goal(satisfied, at, A1, B, C).

/*			
 rule(17) @
  goal(active,at,A,B,C), 
    monkey(E,F,A), 
      phys_object(A,H,I,J,K,L,M) ==>

      F\==floor,
      H\==C,
      not goal(active,on,floor,O,P)
      |
      goal(active,on,floor,Q,R).
*/
rule17 @@
	functor1(Func),
	goal(active, at, A1, B, C),
	monkey(E, F, A2),
	phys_object(A3, H, I, J, K, L, M) \:-
		A1=A2, A1=A3,
		F\=Func,
		H\=C |
			goal(active, on, floor, q, r).

/*
 rule(18) @
  goal(active,at,A,B,C), 
    phys_object(A,E,light,F,G,H,I), 
      monkey(K,L,M) ==>

      E\==C,
      M\==A,
      not goal(active,holds,A,O,P)
      |
      goal(active,holds,A,Q,R).
*/
rule18 @@
	goal(active, at, A1, B, C),
	phys_object(A2, E, light, F, G, H, I),
	monkey(K, L, M) \:-
		A1=A2,
		E\=C,
		M\=A1,
		uniq(A1, B, C, A2, E, F, G, H, I, K, L, M) |
			goal(active, on, floor, q, r).

/*			
 rule(19) @
  phys_object(A,B,light,C,D,E,F) \ 
    goal(active,at,A,H,B) <=>

    write('The object '),
    write(A),
    write(' is already at '),
    write(B),
    nl,
    goal(satisfied,at,A,H,B).
*/
rule19 @@
	phys_object(A1, B1, light, C, D, E, F) \
	goal(active, at, A2, H, B2) :-
		A1=A2, B1=B2 |
			io.print("The object ", res),
			io.print(A1, res),
			io.print(" is already at ", res),
			io.println(B1, res),
			nl,
			goal(satisfied, at, A1, H, B1).

/*			
 rule(20) @
  goal(active,at,nothing,A,B), 
    monkey(B,floor,nothing) <=>

    write('Walk to '),
    write(B),
    nl,
    monkey(B,floor,nothing),
    goal(satisfied,at,nothing,A,B).
*/
rule20 @@
	goal(active, at, nothing, A, B1),
	monkey(B2, floor, nothing) :-
		B1=B2 |
			io.print("Walk to ", res),
			io.print(B1, res),
			nl,
			monkey(B1, floor, nothing),
			goal(satisfied, at, nothing, A, B1).
			
/*
 rule(21) @
  goal(active,at,nothing,A,B), 
    monkey(D,floor,E), 
      phys_object(E,G,H,I,J,K,L) <=>

      D\==B
      |
      write('Walk to '),
      write(B),
      write(' carrying '),
      write(E),
      nl,
      monkey(B,floor,E),
      phys_object(E,B,H,I,J,K,L),
      goal(satisfied,at,nothing,A,B).
*/
rule21 @@
  goal(active, at, nothing, A, B),
  monkey(D, floor, E1),
  phys_object(E2, G, H, I, J, K, L) :-
  	E1=E2, unary(B), unary(G),
  	D\=B |
  	  io.print("Walk to ", res),
  	  io.print(B, res),
  	  io.print(" carrying ", res),
  	  io.println(E1, res),
  	  nl,
  	  monkey(B, floor, E1),
  	  phys_object(E1, B, H, I, J, K, L),
  	  goal(satisfied, at, nothing, A, B).
  	  
/*
rule(22) @
  goal(active,at,nothing,A,B), 
    monkey(D,E,F) ==>

    E\==floor,
    D\==B
    |
    goal(active,on,floor,H,I).
*/
rule22 @@
  functor1(Func),
  goal(active, at, nothing, A, B),
  monkey(D, E, F) \:-
  	E\=Func,
  	D\=B,
  	uniq(A, B, D, E, F) |
  	  goal(active, on, floor, h, i).

 /* 	  
 rule(23) @
  monkey(A,B,C) \ 
    goal(active,at,nothing,E,A) <=>

    write('Monkey is already at '),
    write(A),
    nl,
    goal(satisfied,at,nothing,E,A).
*/
rule23 @@
  monkey(A1, B, C) \
  goal(active, at, nothing, E, A2) :-
  	A1=A2 |
  	  io.print("Monkey is alreafy at ", res),
  	  io.println(A1, res),
  	  nl,
  	  goal(satisfied, at, nothing, E, A1).

 /* 	  
 rule(24) @
  goal(satisfied,A,B,C,D) ==>

  not goal(active,F,G,H,I),
  not found
  |
  write('CONGRATULATIONS the goals are satisfied'),
  nl,
  found.
*/
rule24 @@
  goal(satisfied, A, B, C, D) \:-
  	io.print("CONGRATULATIONS the goals are satisfied"),
  	nl,
  	found.
 
/*  	
 rule(25) @
  goal(active,holds,A,B,C), 
    phys_object(A,E,light,nothing,F,G,H), 
      monkey(E,J,A) ==>

      write('Object '),
      write(A),
      write(' is already being held'),
      nl,
      goal(satisfied,holds,A,B,C).
*/
rule25 @@
  goal(active, holds, A1, B, C),
  phys_object(A2, E1, light, nothing, F, G, H),
  monkey(E2, J, A3) \:-
    A1=A2, A1=A3, E1=E2,
    uniq(A1, B, C, A2, E1, F, G, H, E2, J, A3) |
      io.print("Object ", res),
      io.print(A1, res),
      io.print(" is already being held", res),
      nl,
      goal(satisfied, holds, A1, B, C).
      
%end_of_file.