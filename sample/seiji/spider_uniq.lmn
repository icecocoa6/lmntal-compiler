make_graph{

	input{
		//edge(a,b), edge(b,c), edge(d,b), edge(c,d).
		//edge(a,b), edge(b,c), edge(c,d), edge(d,e).
		//edge(a,b), edge(a,c),edge(a,d),edge(a,e),edge(c,f),edge(f,b).
  	edge(d,a).  edge(d,b).   edge(d,c). 
  	edge(d,e).  edge(a,x).   edge(b,y).
  	edge(c,z).  edge(a,b).   edge(y,c).
	}.

	number{
		edge_num(0).
		node_num(0).
	
		edge(X, Y) \ edge_num(N) :- uniq(X, Y) | edge_num(N+1).
		edge(X, Y) \ :- uniq(X, Y) | node(X, 1), node(Y, 1).
		node(X1, N1), node(X2, N2) :- X1=X2 | node(X1, N1+N2).
		node(X, N) \ node_num(M) :- uniq(X) | node_num(M+1).
	}.

	//number膜内にedgeがあり、かつ膜内に反応するルールがないとき、
	//gen_max生成＆膜名をelementsに
	number{edge(X, Y), edge_num(E), node_num(N), $p, @p}/ :- unary(X), unary(Y), uniq(E, N) | 
		elements{edge(X, Y), edge_num(E), node_num(N), $p, @p}, gen_max(E-(N-1)).

	time(0).

	input{$p[]}, number{$q[], @p} :- uniq | 
		input{$p[]}, number{$p[], $q[], @p}, graph{gen(0), $p[]}.


	time(T), graph{gen(G), edge(X, Y), $p[]} \ :- T=:=G, uniq(X, Y, G) | graph{gen(G+1), $p[]}.

}.

check{

	non_cycle{check, edge(X, Y), $p} :- unary(X), unary(Y) | 
		non_cycle{visit(X), visit(Y), node(X, 1), node(Y, 1), $p}.
	non_cycle{visit(X1), edge(X2, Y), $p} :- X1=X2, unary(Y) | 
		non_cycle{visit(X1), visit(Y), node(X2, 1), node(Y, 1), $p}.
	non_cycle{visit(Y1), edge(X, Y2), $p} :- unary(X), Y1=Y2 | 
		non_cycle{visit(Y1), visit(X), node(X, 1), node(Y2, 1), $p}.
	non_cycle{visit(X1), visit(X2), $p[]} :- X1=X2 | 
		non_cycle{cycle}.

	non_cycle{node(X1, N1), node(X2, N2), $p} :- X1=X2, unary(N1), unary(N2) | 
		non_cycle{node(X1, N1+N2), $p}.
	non_cycle{node(X1, N1), node(X2, N2), $p[]} :- X1\=X2, N1>=3, N2>=3 | 
		non_cycle{not_spider}.
		
}.

output{}.

make_graph{time(T), gen_max(G), $p, @p}/ :- T<G | make_graph{time(T+1), gen_max(G), $p, @p}.

check{$c, @c}, make_graph{gen_max(G1), graph{gen(G2), $p[]}, $q, @q}/ :- G1=:=G2 | 
	check{$c, @c, non_cycle{check, graph{$p[]}, $p[]}}, make_graph{gen_max(G1), $q, @q}.

check{non_cycle{node(X, N), graph{$p}, $q[]}, $c, @c}, output{$r} :- unary(X), N>=3 |
	check{$c, @c}, output{graph{$p}, $r}.


//掃除
make_graph{$p[], @p}, check{$c[], @c}, output{$q, @q}/ :- output{$q, @q}.