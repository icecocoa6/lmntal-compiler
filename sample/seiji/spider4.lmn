make_graph{


input{
	edge(a,b), edge(b,c), edge(d,b), edge(c,d).
	/*
  edge(d,a).  edge(d,b).   edge(d,c). 
  edge(d,e).  edge(a,x).   edge(b,y).
  edge(c,z).  edge(a,b).   edge(y,c).*/
}.




number{
	edge_num(0).
	node_num(0).
	edge(X, Y) \ edge_num(N) :- uniq(X, Y) | edge_num(N+1).
	edge(X, Y) \ :- uniq(X, Y) | node(X, 1), node(Y, 1).
	node(X1, N1), node(X2, N2) :- X1=X2 | node(X1, N1+N2).
	node(X, N) \ node_num(M) :- uniq(X) | node_num(M+1).
}.
//size{edge_num(E), node_num(N), $p[], @p}/ :- E>N-1 | no_spanning_tree.

//number膜内にedgeがあり、かつ膜内に反応するルールがないとき、
//gen_max生成＆膜名をelementsに
number{edge(X, Y), edge_num(E), node_num(N), $p, @p}/ :- unary(X), unary(Y), uniq(E, N) | 
elements{edge(X, Y), edge_num(E), node_num(N), $p, @p}, gen_max(E-(N-1)).

//不要なedgeを除去
//elements{edge(X, Y), $p, @p}/ :- unary(X), unary(Y) | elements{$p, @p}.




//number{edge_num(E), node_num(N), gen_max(G), $p, @p}/ :- int(E), int(N), int(G), uniq | 
//number{edge_num(E), node_num(N), $p, @p}, gen_max(E-(N-1)).


/*
graph_rule{

times(T),  sub{anc_index(A), index(I), edge(X, Y), $p[]} :- int(T), int(A), uniq(X, Y, I) | 
times(T+1),sub{
							 anc_index(A), 
						   index(I), 
						   edge(X, Y), 
						   $p[], 
						   graph{
						   			 sub{anc_index(I), index(T+1), $p[]}
						   			 }
						   }.

}.
*/
time(0).

input{$p[]}, number{$q[], @p} :- uniq | 
input{$p[]}, number{$p[], $q[], @p}, graph{gen(0), $p[]}.


time(T), graph{gen(G), edge(X, Y), $p[]} \ :- T=:=G, uniq(X, Y, G) | graph{gen(G+1), $p[]}.
/*上の式の旧版
time(T), graph{gen(G), edge(X, Y), $p[]} :- T=:=G, uniq(X, Y) | 
time(T), graph{gen(G), edge(X, Y), $p[]}, graph{gen(G+1), $p[]}.
*/


//graph{$p}, graph_rule{@p} :- uniq | graph{$p, @p}, graph_rule{@p}.


/*
times(0).
//times(T) :- T>100 | .

//第I世代から次世代のgraph生成
sub{anc_index(A), index(I), edge(X, Y), $q[]} \ times(T):- int(A), int(T), uniq(X, Y, I) | 
times(T+1), graph{edge(X, Y), sub{anc_index(I), index(T+1), $q[]}}.

graph{sub{$p[]}, $q[]} :- \+($p=(edge(X, Y), $pp)) |.


next_graph{edge(X, Y), sub{anc_index(A), $q}} :- uniq(X, Y, A) | sub{anc_index(A), $q}.
*/

}.

check{


non_cycle{check, edge(X, Y), $p} :- unary(X), unary(Y) | 
non_cycle{visit(X), visit(Y), node(X, 1), node(Y, 1), $p}.

non_cycle{visit(X1), edge(X2, Y), $p} :- X1=X2, unary(Y) | 
non_cycle{visit(X1), visit(Y), node(X2, 1), node(Y, 1), $p}.

non_cycle{visit(Y1), edge(X, Y2), $p} :- unary(X), Y1=Y2 | 
non_cycle{visit(Y1), visit(X), node(X, 1), node(Y2, 1), $p}.

non_cycle{visit(X1), visit(X2), $p[]} :- X1=X2 | 
non_cycle{cycle}.

non_cycle{node(X1, N1), node(X2, N2), $p} :- X1=X2, unary(N1), unary(N2) | 
non_cycle{node(X1, N1+N2), $p}.

non_cycle{node(X1, N1), node(X2, N2), $p[]} :- X1\=X2, N1>=3, N2>=3 | 
non_cycle{not_spider}.



}.

output{}.

make_graph{time(T), gen_max(G), $p, @p}/ :- T<G | make_graph{time(T+1), gen_max(G), $p, @p}.

check{$c, @c}, make_graph{gen_max(G1), graph{gen(G2), $p[]}, $q, @q}/ :- G1=:=G2 | 
check{$c, @c, non_cycle{check, graph{$p[]}, $p[]}}, make_graph{gen_max(G1), $q, @q}.

check{non_cycle{node(X, N), graph{$p}, $q[]}, $c, @c}, output{$r} :- unary(X), N>=3 |
check{$c, @c}, output{graph{$p}, $r}.


//いらないものを消去
make_graph{$p[], @p}, check{$c[], @c}, output{$q, @q}/ :- output{$q, @q}.
