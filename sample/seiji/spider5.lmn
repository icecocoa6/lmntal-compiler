{
make_graph{


input{
	/*
	edge(a,b), 
	edge(c,d),
	edge(e,f), 
	edge(g,h).
	*/	
	edge(a,b), edge(b,c), edge(c,b), edge(d,b).
  /*
  edge(d,a).  edge(d,b).   edge(d,c). 
  edge(d,e).  edge(a,x).   edge(b,y).
  edge(c,z).  edge(a,b).   edge(y,c).*/
}.


number{
	edge_num(0).
	node_num(0).
	edge(X, Y) \ edge_num(N) :- uniq(X, Y) | edge_num(N+1).
	edge(X, Y) \ :- uniq(X, Y) | node(X, 1), node(Y, 1).
	node(X1, N1), node(X2, N2) :- X1=X2 | node(X1, N1+N2).
	node(X, N) \ node_num(M) :- uniq(X) | node_num(M+1).
}.

gen_max(G) :- G<0 | false.

//number膜内にedgeがあり、かつ膜内に反応するルールがないとき、
//gen_max生成＆膜名をelementsに
number{edge(X, Y), edge_num(E), node_num(N), $p, @p}/ :- unary(X), unary(Y), uniq(E, N) | 
elements{edge(X, Y), edge_num(E), node_num(N), $p, @p}, gen_max(E-(N-1)).

//不要なedgeを除去
//elements{edge(X, Y), $p, @p}/ :- unary(X), unary(Y) | elements{$p, @p}.


time(0).

input{$p[]}, number{$q[], @p} :- uniq | 
input{$p[]}, number{$p[], $q[], @p}, graph{gen(0), $p[]}.


time(T), graph{gen(G), edge(X, Y), $p[]} \ :- T=:=G, uniq(X, Y, G) | graph{gen(G+1), $p[]}.

//end of make_graph{}
}.


check{
	/*訪れたノードとノードが持つ枝の数を求める*/
	

	//non_cycle{check, $q[], graph{$p[]}} :- non_cycle{ok, $q[], graph{$p[]}}
	
//	visit(X1), edge(X2, Y):- X1=X2 | visit(X1), visit(Y).
//  visit(Y1), edge(X, Y2):- Y1=Y2 | visit(Y1), visit(X).
	
	
	non_cycle{check, edge(X, Y), graph{$q[]}, $p[]} :- unary(X), unary(Y) | 
		non_cycle{visit(X), visit(Y), node(X, 1), node(Y, 1), graph{$q[]}, $p[]}.
		
	non_cycle{visit(X1), edge(X2, Y), $p} :- X1=X2, unary(Y) | 
		non_cycle{visit(X1), visit(Y), node(X2, 1), node(Y, 1), $p}.
	
	non_cycle{visit(Y1), edge(X, Y2), $p} :- Y1=Y2, unary(X) | 
		non_cycle{visit(Y1), visit(X), node(X, 1), node(Y2, 1), $p}.
	
	non_cycle{visit(X1), visit(X2), $p[]} :- X1=X2 | .
	
	non_cycle{node(X1, N1), node(X2, N2), $p} :- X1=X2, int(N1), int(N2) | 
		non_cycle{node(X1, N1+N2), $p}.
	
	//non_cycle{node(X, N), graph$p[]}
	
	/*
	graph{edge(X, Y), $p} :- graph{node(X, 1), node(Y, 1), $p}.
	graph{node(X1, N1), node(X2, N2), $p} :- X1=X2, int(N1), int(N2) | 
		graph{node(X1, N1+N2), $p}.	*/
}.
//check{non_cycle{graph{$p}, $q[]}, $c, @c}/ :- check{graph{$p}, $c, @c}.


//check{non_cycle{visit(X1), visit(X2), $p[]}, $c, @c}/ :- X1=X2 | check{$c, @c}.

//make_graph{false, $p[], @p}, check{$q[], @q} :- false.


make_graph{time(T), gen_max(G), $p, @p}/ :- T<G | make_graph{time(T+1), gen_max(G), $p, @p}.

//check{$c, @c}, make_graph{time(T), gen_max(G), elements{$p, @p}, $q, @q}/ :- T=:=G | 
//check{elements{$p}, $c, @c}, make_graph{time(T), gen_max(G), $q, @q}.

check{$c}, make_graph{gen_max(G1), graph{gen(G2), $p[]}, $q, @q}/ :- G1=:=G2 | 
check{non_cycle{check, $p[], graph{$p[]}}, $c}, make_graph{gen_max(G1), $q, @q}.



}.

{make_graph{$p[], @p}, $q, @q}/ :-{$q, @q}.
/*
check{$c, @c}, make_graph{time(T), gen_max(G), elements{$p, @p}, $q, @q}/ :- T=:=G | 
check{elements{$p}, $c, @c}, make_graph{time(T), gen_max(G), $q, @q}.

check{$c, @c}, make_graph{gen_max(G1), graph{gen(G2), $p}, $q, @q}/ :- G1=:=G2 | 
check{graph{$p}, $c, @c}, make_graph{gen_max(G1), $q, @q}.
*/