//var.use.

/*
VarDeclare @@
H=var(_GName) :- H=v({name=_GName}).

VarUnify @@
{name=_GName0, $e0}, {name=_GName1, $e1} :- _GName0=_GName1 | {name=_GName0, $e0, $e1}.

VarBind @@
var.bind(_GName0, _GValue), {name=_GName1, $e} :- {name=_GName1, value=_GValue, $e}.

VarBindEach @@
H=v({name=_GName1, value=_GValue, $e}) :- H=_GValue, {name=_GName1, value=_GValue, $e}.

VarUnify @@
var.unify(_GName0, _GName1), {name=_GName2, $e0}, {name=_GName3, $e1} :- _GName0=_GName2, _GName1=_GName3 |
{name=_GName3, $e0, $e1}.
*/

//a(var(x)), b(var(y)).
//var.bind(x, 5).
//var.unify(x, y).
/*
reflexivity  @@ leq(var(X1), var(X2)) :- X1=X2 | unify(X1, X2).

antisymmetry @@ leq(var(X1), var(Y1)), leq(var(Y2), var(X2)) 
						:- X1=X2, Y1=Y2 | unify(X1, Y1).

transitivity @@ leq(var(X), var(Y1)), leq(var(Y2), var(Z)) \ 
						:- Y1=Y2, uniq(X, Y1, Z) | leq(var(X), var(Z)).

idempotence  @@ leq(var(X1), var(Y1)) \ leq(var(X2), var(Y2)) 
						:- X1=X2, Y1=Y2 |.
\*/



						
/*
reflexivity  @@ leq(var(X1), var(X2)) :- X1=X2 | var.unify(X1, X2).

antisymmetry @@ leq(var(X1), var(Y1)), leq(var(Y2), var(X2)) 
						:- X1=X2, Y1=Y2 | var.unify(X1, Y1).

transitivity @@ leq(var(X), var(Y1)), leq(var(Y2), var(Z)) \ 
						:- Y1=Y2, uniq(X, Y1, Z) | leq(X, Z).

idempotence  @@ leq(var(X1), var(Y1)) \ leq(var(X2), var(Y2)) 
						:- X1=X2, Y1=Y2 |.
*/


//leq(var(a), var(b)).leq(var(b), var(c)), leq(var(c), var(a)).
leq(var(a), var(b)).
leq(var(b), var(c)).
leq(var(c), var(a)).



eq.use.

%%モジュールeq使用
reflexivity  @@ leq(X1, X2) :- X1=X2 | true.
transitivity @@ leq(X, Y1), leq(Y2, Z) \:- Y1=Y2, uniq(X, Y1, Z) | leq(X, Z).
antisymmetry @@ leq(X1, Y1) , leq(Y2, X2) :- X1=X2, Y1=Y2 | eq(X1, Y1).
idempotence  @@ leq(X1, Y1) \ leq(X2, Y2) :- X1=X2, Y1=Y2 | true.


/*
reflexivity  @ X leq X <=> true.
antisymmetry @ X leq Y , Y leq X <=> X=Y.
idempotence  @ X leq Y \ X leq Y <=> true.
transitivity @ X leq Y , Y leq Z ==> X leq Z.
*/


