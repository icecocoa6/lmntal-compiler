% これはLMNParserに相当する。

% 入力:抽象構文木
% 構文規則:
%   プロセス := [] | [プロセス要素|プロセス] % プロセスはプロセス要素のリスト
%   プロセス要素 := アトム | 膜 | リンク | ルール | プロセス文脈 | ルール文脈 | リンク束
%   アトム := srcatom(アトム名, 子プロセス)
%   膜 := srcmem(子プロセス)
%   リンク := srclink(リンク名)
%   ルール := srcrule(ルール名, プロセス, プロセス, プロセス) %ヘッド、ガード、ボディ
%   プロセス文脈 := srcproccxt(プロセス文脈名, プロセス, プロセス) %明示プロセス、非明示プロセス)
%   ルール文脈 := srcrulecxt(ルール文脈名)
%   リンク束 := srcbundle(リンク束名)
% ※リンク名、リンク束名、アトム名、ルール名、プロセス文脈名、ルール文脈名は、全て文字列アトム
% 特殊な中置記法演算子は、equalとかbackslashとかの名前のアトムになっているが、なんで区別したのかよくわからん
%
% what to do:
%   - アトムの引数の展開とcheck
%     -- アトム引数のアトム展開
%       a(..,b(..),..)  --> a(..,NEW_LINK,..), b(..,NEW_LINK)
%     -- アトム引数の膜の展開
%       a(..,{..},..)  --> a(..,NEW_LINK,..), {'+'(NEW_LINK),..}
%     -- アトム引数にsrcatom, srcmem, srclink以外があったらエラー
%     -- アトム引数にsrcbundleがあったら、アトム集団にする(今はエラーでいいや)
%   - プロセス文脈の引数のcheck
%     -- プロセス文脈の明示プロセスにsrclink以外があったらエラー
%     -- プロセス文脈の非明示プロセスにsrcbundle以外があったらエラー
%   - 膜の引数のcheck
%     -- srclink, srcbundleがあったらエラー
%   - ルールの引数のcheck
%     -- ヘッド、ガード、ボディにsrclink,srcbundleが出たらエラー
%   - 同名のリンクはつなぐ
%     -- 同じ膜内にリンクが双方あれば、つなぐ
%     -- その膜に一個しか無ければ、$inを作ってつなぎ、膜の外に$outを作ってそこにリンクを作る
%       ..,X,.. --> ..,X,.. $in(NEWLINK,X) }, $out(NEWLINK, NEWLINK2)
%     -- 三個出現したら、それはプロセス文脈とする
%       ..,X,.. --> ..,NEW_LINK,.. $X[NEWLINK]
%   - プロセス文脈からプロセス文脈定義を生成する
%     -- 
%
% how to do
%   - ルールごとに個別に処理するべきだが、一方でそのどこからでも使いたいルールというものがあるわけで、さてどうしたものか…。

{ module(lmnconstructor).

Construct_GlobalRule1@@
lmnconstructor.construct(Src) :- ground(Src) |
% 

lmnconstructor.collect_rules({global=collect_rule([],[srcrule("",[],[],Src)]). % 世界生成ルール

	R=collect_rule(Rules, [srcatom(N,P)     |Rest]):-R=[srcatom(N,P)     |collect_rule(Rules, Rest)].
	R=collect_rule(Rules, [srcmem(P)        |Rest]):-R=[srcmem(P)        |collect_rule(Rules, Rest)].
	R=collect_rule(Rules, [srclink(N)       |Rest]):-R=[srclink(N)       |collect_rule(Rules, Rest)].
	R=collect_rule(Rules, [srcbundle(N)     |Rest]):-R=[srcbundle(N)     |collect_rule(Rules, Rest)].
	R=collect_rule(Rules, [srcproccxt(N,I,E)|Rest]):-R=[srcproccxt(N,I,E)|collect_rule(Rules, Rest)].
	R=collect_rule(Rules, [srcrulecxt(N)    |Rest]):-R=[srcrulecxt(N)    |collect_rule(Rules, Rest)].
	R=collect_rule(Rules, [srcrule(N,H,G,B) |Rest]):-R=collect_rule([srcrule(N,H,G,collect_rule([],B))|Rules], Rest).
	R=collect_rule(Rules, []) :- R=[srcrules(Rules)].

	rulesetcount=600.

	Separate_Rules@@
	rulesetcount=RC, S=srcrules([Rule|Rules]) :- RC1=RC+1 |
		ruleset(RC1, [Rule|Rules]), S=rulesetid(RC1), rulesetcount=RC1.
	S=[srcrules([])] :- S=[].

}).
lmnconstructor.collect_rules({$g, rulesetcount=RC, @g}/) :- int(RC) |

lmnconstructor.construct_rule({$g.

	S=srcrule(N,H,G,B) :- string(N), ground(H), ground(G), ground(B) |
		rule={name(N), '+'(S),
		mem={childs(He), '+'(L)}, He=H, lhs=L,
		mem={childs(Gu), '+'(C)}, Gu=G, guard=C,
		mem={childs(Bo), '+'(R)}, Bo=B, rhs=R.
		}.

}).

lmnconstructor.construct_rule({$g, @g}/) :-
%
lmnconstructor.construct1({$g.

	rule={$rule} :- constructing_rule={$rule.
	
		% リンク名を新しく生成する
		linkcount(0).
		{$link1[L1|*Link1]}, {$link2[L2|*Link2]}, lmnconstructor.new_linknames(L1,L2), linkcount(LN) :- LN1=LN+1|
			{$link1[L1|*Link1], L1=string.concat("~", string.str_of_int(LN)), with_rule},
			{$link2[L2|*Link2], L2=string.concat("~", string.str_of_int(LN)), with_rule},
			linkcount(LN1).
		% リンク内のルールは除去する(反応後)
		link={with_rule, @link, $link}/ :- link={$link}.
	
		% アトムオブジェクトを作る
		Construct_Atom@@
		S=srcatom(Functor, Childs) :- ground(Functor) | 
			atom={'+'(S), functorkind(Functor), childs(0, Childs)}.
	
		% 膜オブジェクトを作る		
		Construct_Mem@@
		S=srcmem(Childs) :- mem={childs(Childs), '+'(S)}.
	
		% 膜オブジェクトの子要素のリストを切り離す
		CreateChild1@@
		mem={$mem, childs(C)}, C=[Child|R] :- mem={$mem, child(Child), childs=R}.	
		CreateChild1_1@@
		mem={$mem, childs(C)}, C=[] :- mem={$mem}.
	
		% アトムオブジェクトの子要素を番号をふりながら切り離す
		CreateChild2@@
		atom={$process, childs(N, C)}, C=[Child|R] :- M=N+1|atom={$process, child(N, Child), childs(M,R)}.
	
		% 膜オブジェクトの子要素のうち，アトムはatomで参照する
		mem={$mem, child(A)}, atom={'+'(A), $atom} :-
			mem={$mem, atom(A), '+'(M)}, atom={mem(M), '+'(A), $atom}.
		% 膜オブジェクトの子要素のうち，膜はmemで参照する
		mem={$mem, child(M)}, mem={'+'(M), $childmem} :-
			mem={$mem, mem(C), '+'(M)}, mem={parent(M), '+'(C), $childmem}.
	
		% 子要素がつきた時のindex番号がそのアトムの引数数．ファンクタを作る
		CreateFunctor@@
		atom={$atom, functorkind(K), childs(A,C)},C=[] :- ground(K), int(A)|
			atom={$atom, functor(K,A)}.
		
		% 略記法展開時に使用する，リンクオブジェクトを作る手続き
		NewLink@@
		lmnconstructor.newlink(L1,A1,P1,L2,A2,P2) :- int(P1), int(P2) |
			link={name(NN1), '+'(L1), buddy(B1), '+'(B2), atom(A1), pos(P1)},
			link={name(NN2), '+'(L2), buddy(B2), '+'(B1), atom(A2), pos(P2)},
			lmnconstructor.new_linknames(NN1,NN2).
	
		% アトム引数の略記法展開 : アトム
		% a(b) --> a(~0), b(~0)
		ExpandAtom@@
		mem={$mem, atom(Atom)},
		atom={'+'(Atom), $atom, child(P,C)}, atom={'+'(C), functor(K,Arity), $child[K|*Child]} :- A1=Arity+1, int(P) |
			mem={$mem, atom(Atom1), atom(Atom2), '+'(M2)},
			atom={$atom, '+'(A), link(P,L1), '+'(Atom1)},
			atom={$child[K|*Child], '+'(CA), link(Arity, L2), functor(K, A1), '+'(Atom2), mem(M2)},
			lmnconstructor.newlink(L1,A,P,L2,CA,Arity).
	
		% アトム引数の略記法展開 : 膜
		% a(..,{..},..) --> a(..,L1,..),$out(U1,L1),{$in(U1,L2),'+'(L2),..}
		ExpandMem@@
		mem={$mem, atom(Atom)},
		atom={'+'(Atom), $atom, child(P,C)}, mem={'+'(C), $child} :- int(P) |
			mem={$mem, atom(Atom1), mem(Mem), '+'(M2), atom(Out), '+'(OutM)},
			atom={$atom, '+'(A), link(P,L1), '+'(Atom1)},
			atom={'+'(Out), '+'(L_O), '+'(L_UO), functor(normalfunc("$out",2)),
				link(0, L_Out0), link(1, L_Out1), mem(OutM)},
			lmnconstructor.newlink(L1,A,P,L_Out1,L_O,1),
			atom={'+'(In), '+'(L_I), '+'(L_UI), functor(normalfunc("$in",2)),
				link(0, L_In0), link(1, L_In1), mem(InM)},
			lmnconstructor.newlink(L_Out0,L_UO,0,L_In0,L_UI,0),
			atom={'+'(Plus), '+'(L_P),functor(normalfunc("+",1)), link(0, L_Plus0), mem(PlusM)},
			lmnconstructor.newlink(L_In1,L_I,1, L_Plus0, L_P, 0),
			mem={'+'(Mem), parent(M2), '+'(PlusM), atom(Plus), '+'(InM), atom(In), $child}.
	
		% リンクオブジェクトを作る
		% nobuddy は，buddyを持たないことを意味する．二回反応しないように(uniq使えばいい？)
		ConstructLink@@
		S=srclink(LinkName) :- string(LinkName) | link={name(LinkName), '+'(S), nobuddy }.
		
		% リンクオブジェクトへはlinkで参照する
		ConstructLink_1@@
		atom={$atom, child(Index, L)}, link={'+'(L), $link} :- int(Index) |
			atom={$atom, link(Index, L), '+'(A)}, link={'+'(L), $link, atom(A), pos(Index)}.
		
		% 同名のリンクはbuddy関係にある ( 左辺に二回，右辺に二回は未対応)
		ConnectLink@@
		link={$link1, atom(A1), name(Name1), nobuddy}, link={$link2, atom(A2), name(Name2), nobuddy},
			:- string(Name1), string(Name2), Name1=Name2 |
			link={$link1, atom(A1), name(Name1), buddy(B1), '+'(B2)},
			link={$link2, atom(A2), name(Name2), buddy(B2), '+'(B1)}.
	}.
	
}).

lmnconstructor.construct1({$g, @g}/) :-

lmnconstructor.construct2({$g. 

	constructing_rule={$rule, linkcount(LC), @rule}/ :- int(LC) | rule={$rule}.

}).

lmnconstructor.construct2({$g, @g}/) :-

%
lmnconstructor.constructed_({$g}).

lmnconstructor.constructed_({global(G), $g[G]}/) :-

lmnconstructor.constructed(G),$g[G].

}.