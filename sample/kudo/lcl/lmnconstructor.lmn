% これはLMNParserに相当する。

% 入力:抽象構文木
% 構文規則:
%   プロセス := [] | [プロセス要素|プロセス] % プロセスはプロセス要素のリスト
%   プロセス要素 := アトム | 膜 | リンク | ルール | プロセス文脈 | ルール文脈 | リンク束
%   アトム := srcatom(アトム名, 子プロセス)
%   膜 := srcmem(子プロセス, stableフラグ, ホスト指定項(default:none), 種類指定(default:0))
%   リンク := srclink(リンク名)
%   ルール := srcrule(ルール名, プロセス, プロセス, プロセス) %ヘッド、ガード、ボディ
%   プロセス文脈 := srcproccxt(プロセス文脈名, プロセス, プロセス) %明示プロセス、非明示プロセス)
%   ルール文脈 := srcrulecxt(ルール文脈名)
%   リンク束 := srcbundle(リンク束名)
% ※リンク名、リンク束名、アトム名、ルール名、プロセス文脈名、ルール文脈名は、全て文字列アトム
% 特殊な中置記法演算子は、equalとかbackslashとかの名前のアトムになっているが、なんで区別したのかよくわからん
%
% what to do:
%   - アトムの引数の展開とcheck
%     -- アトム引数のアトム展開
%       a(..,b(..),..)  --> a(..,NEW_LINK,..), b(..,NEW_LINK)
%     -- アトム引数の膜の展開
%       a(..,{..},..)  --> a(..,NEW_LINK,..), {'+'(NEW_LINK),..}
%     -- アトム引数にsrcrule, srcrulecxtがあったらエラー
%     -- アトム引数にsrcbundleがあったら、アトム集団にする(今はエラーでいいや)
%   - プロセス文脈の引数のcheck
%     -- プロセス文脈の明示プロセスにsrclink以外があったらエラー
%     -- プロセス文脈の非明示プロセスにsrcbundle以外があったらエラー
%   - 膜の引数のcheck
%     -- srclink, srcbundleがあったらエラー
%   - ルールの引数のcheck
%     -- ヘッド、ガード、ボディにsrclink,srcbundleが出たらエラー
%   - 同名のリンクはつなぐ
%     -- 同じ膜内にリンクが双方あれば、つなぐ
%     -- その膜に一個しか無ければ、$inを作ってつなぎ、膜の外に$outを作ってそこにリンクを作る
%       ..,X,.. --> ..,X,.. $in(NEWLINK,X) }, $out(NEWLINK, NEWLINK2)
%     -- 三個出現したら、それはプロセス文脈とする
%       ..,X,.. --> ..,NEW_LINK,.. $X[NEWLINK]
%   - プロセス文脈からプロセス文脈定義を生成する
%     -- 
%
% how to do
%   - ルールごとに個別に処理するべきだが、一方でそのどこからでも使いたいルールというものがあるわけで、さてどうしたものか…。

{ module(lmnconstructor).

Construct_GlobalRule1@@
lmnconstructor.construct(Src) :- ground(Src) |
% 

lmnconstructor.collect_rules({global=collect_rule([],[srcrule("",[],[],Src)]). % 世界生成ルール

	R=collect_rule(Rules, [srcatom(N, P)     |Rest]):-R=[srcatom(N, P)     |collect_rule(Rules, Rest)].
	R=collect_rule(Rules, [srcmem(P, S, H, K)|Rest]):-R=[srcmem(P, S, H, K)        |collect_rule(Rules, Rest)].
	R=collect_rule(Rules, [srclink(N)       |Rest]):-R=[srclink(N)       |collect_rule(Rules, Rest)].
	R=collect_rule(Rules, [srcbundle(N)     |Rest]):-R=[srcbundle(N)     |collect_rule(Rules, Rest)].
	R=collect_rule(Rules, [srcproccxt(N, I, E)|Rest]):-R=[srcproccxt(N, I, E)|collect_rule(Rules, Rest)].
	R=collect_rule(Rules, [srcrulecxt(N)    |Rest]):-R=[srcrulecxt(N)    |collect_rule(Rules, Rest)].
	R=collect_rule(Rules, [srcrule(N, H, G, B) |Rest]):-R=collect_rule([srcrule(N,H,G,collect_rule([],B))|Rules], Rest).
	R=collect_rule(Rules, []) :- R=[srcrules(Rules)].

	rulesetcount=600.

	Separate_Rules@@
	rulesetcount=RC, S=srcrules([Rule|Rules]) :- RC1=RC+1 |
		ruleset(RC1, [Rule|Rules]), S=rulesetid(RC1), rulesetcount=RC1.
	S=[srcrules([])] :- S=[].

}).
lmnconstructor.collect_rules({$g, rulesetcount=RC, @g}/) :- int(RC) |

lmnconstructor.construct_rule({$g.

	S=srcrule(N,H,G,B) :- string(N), ground(H), ground(G), ground(B) |
		rule={rulename(N), '+'(S),
		mem={childs(He), '+'(L)}, He=H, lhs=L,
		mem={childs(Gu), '+'(C)}, Gu=G, guard=C,
		mem={childs(Bo), '+'(R)}, Bo=B, rhs=R.
		}.

}).

lmnconstructor.construct_rule({$g, @g}/) :-
%
lmnconstructor.construct1({$g.

	rule={$rule} :- constructing_rule={$rule.
	
		% リンク名を新しく生成する
		linkcount(0).
		lmnconstructor.new_linknames(L1,L2), linkcount(LN),
		{$link1[L1|*Link1]}, {$link2[L2|*Link2]} :- LN1=LN+1|
			{$link1[L1|*Link1], L1=string.concat("~", string.str_of_int(LN)), with_rule},
			{$link2[L2|*Link2], L2=string.concat("~", string.str_of_int(LN)), with_rule},
			linkcount(LN1).
		% リンク内のルールは除去する(反応後)
		link={with_rule, @link, $link}/ :- link={$link}.
	
		% アトムオブジェクトを作る
		Construct_Atom@@
		S=srcatom(Functor, Childs) :- ground(Functor) | 
			atom={'+'(S), functorkind(Functor), childs(0, Childs)}.
	
		% 膜オブジェクトを作る		
		Construct_Mem@@
		S=srcmem(Childs, Stable_flug, Host, Kind) :- ground(Host), int(Kind) |
			mem={childs(Childs), '+'(S), s_flg=Stable_flug, host=Host, kind=Kind}.
		
		% stableかどうか
		Construct_Mem_1@@
		mem={s_flg=F, $mem}, F=true :- mem={stable, $mem}.
		Construct_Mem_2@@
		mem={s_flg=F, $mem}, F=false :- mem={$mem}.
		
		% ルール文脈オブジェクトを作る
		Construct_RuleCxt@@
		S=srcrulecxt($rn) :- string($rn) | 
			rulecxt={'+'(S), def(D), '+'(O)}, cxtdef={'+'(D), occ=O, name=$rn}.
		
		% プロセス文脈オブジェクトを作る
		Construct_ProcCxt@@
		S=srcproccxt($pn, Ex, Im) :- string($pn) |
			proccxt={'+'(S), def(D), '+'(O), expls(0, Ex), impls(0, Im)}, cxtdef={'+'(D), occ=O, name=$pn}.
		
		% 同名の文脈定義を単一化する
		cxtdef={$cxtdef1, name=$n1}, cxtdef={$cxtdef2, name=$n2} :- string($n1), string($n2), $n1=$n2 |
			cxtdef={$cxtdef1, $cxtdef2, name=$n1}.
	
		% 膜オブジェクトの子要素のリストを切り離す
		CreateChild1@@
		mem={$mem, childs(C)}, C=[Child|R] :- mem={$mem, child(Child), childs=R}.	
		CreateChild1_1@@
		mem={$mem, childs(C)}, C=[] :- mem={$mem}.
	
		% アトムオブジェクトの子要素を番号をふりながら切り離す
		CreateChild2@@
		atom={$process, childs(N, C)}, C=[Child|R] :- M=N+1|atom={$process, child(N, Child), childs(M,R)}.

		% 子要素がつきた時のindex番号がそのアトムの引数数．ファンクタを作る
		CreateFunctor@@
		atom={$atom, functorkind($k), childs($a,C)},C=[] :- ground($k), int($a)|
			atom={$atom, functor($k,$a)}.

		% プロセス文脈オブジェクトの子要素を番号をふりながら切り離す
		CreateImpl@@
		proccxt={$proccxt, impls($n, I)}, I=[Impl|R] :- $m=$n+1|proccxt={$proccxt, impl($n, Impl), impls($m, R)}.
		
		CreateImpl2@@
		proccxt={$proccxt, impls($n, I)}, I=[] :- int($n) | proccxt={$proccxt}.

		CreateExpl@@
		proccxt={$proccxt, expls($n, E)}, E=[Expl|R] :- $m=$n+1|proccxt={$proccxt, expl($n, Expl), expls($m, R)}.
		
		CreateExpl2@@
		proccxt={$proccxt, expls($n, E)}, E=[] :- int($n) | proccxt={$proccxt}.
	
		% 膜オブジェクトの子要素のうち，アトムはatomで参照し，逆に所属膜としてmemで参照させる
		mem={$mem, child(A)}, atom={'+'(A), $atom} :-
			mem={$mem, atom(A), '+'(M)}, atom={mem(M), '+'(A), $atom}.
		% 膜オブジェクトの子要素のうち，膜はmemで参照し，逆に親膜としてparentで参照させる
		mem={$mem, child(M)}, mem={'+'(M), $childmem} :-
			mem={$mem, mem(C), '+'(M)}, mem={parent(M), '+'(C), $childmem}.
		% 膜オブジェクトの子要素のうち，ルールセットはrulesで参照する
		mem={$mem, child(R)}, R=rulesetid(RID) :-
			mem={$mem, rules(R)}, R=rulesetid(RID).
		% 膜オブジェクトの子要素のうち，ルール文脈はrulecxtで参照し，逆に所属膜としてmemで参照させる
		mem={$mem, child(R)}, rulecxt={'+'(R), $rulecxt} :-
			mem={$mem, rulecxt(R), '+'(M)}, rulecxt={'+'(R), mem(M), $rulecxt}.
		% 膜オブジェクトの子要素のうち，プロセス文脈はproccxtで参照し，逆に所属膜としてmemで参照させる
		mem={$mem, child(R)}, proccxt={'+'(R), $proccxt} :-
			mem={$mem, proccxt(R), '+'(M)}, proccxt={'+'(R), mem(M), $proccxt}.
	
		% 略記法展開時に使用する，リンクオブジェクトを作る手続き
		NewLink@@
		lmnconstructor.newlink(L1,A1,P1,L2,A2,P2) :- int(P1), int(P2) |
			link={name(NN1), '+'(L1), buddy(B1), '+'(B2), atom(A1), pos(P1)},
			link={name(NN2), '+'(L2), buddy(B2), '+'(B1), atom(A2), pos(P2)},
			lmnconstructor.new_linknames(NN1,NN2).
	
		% アトム引数の略記法展開 : アトム
		% a(b) --> a(~0), b(~0)
		ExpandAtom@@
		mem={$mem, atom(Atom)},
		atom={'+'(Atom), $atom, child(P,C)}, atom={'+'(C), functor(K,Arity), $child[K|*Child]} :- A1=Arity+1, int(P) |
			mem={$mem, atom(Atom1), atom(Atom2), '+'(M2)},
			atom={$atom, '+'(A), link(P,L1), '+'(Atom1)},
			atom={$child[K|*Child], '+'(CA), link(Arity, L2), functor(K, A1), '+'(Atom2), mem(M2)},
			lmnconstructor.newlink(L1,A,P,L2,CA,Arity).
	
		% アトム引数の略記法展開 : 膜
		% a(..,{..},..) --> a(..,L1,..),$out(U1,L1),{$in(U1,L2),'+'(L2),..}
		ExpandMem@@
		mem={$mem, atom(Atom)},
		atom={'+'(Atom), $atom, child(P,C)}, mem={'+'(C), $child} :- int(P) |
			mem={$mem, atom(Atom1), mem(Mem), '+'(M2), atom(Out), '+'(OutM)},
			atom={$atom, '+'(A), link(P,L1), '+'(Atom1)},
			atom={'+'(Out), '+'(L_O), '+'(L_UO), functor(out, 2),
				link(0, L_Out0), link(1, L_Out1), mem(OutM)},
			lmnconstructor.newlink(L1,A,P,L_Out1,L_O,1),
			atom={'+'(In), '+'(L_I), '+'(L_UI), functor(in, 2),
				link(0, L_In0), link(1, L_In1), mem(InM)},
			lmnconstructor.newlink(L_Out0,L_UO,0,L_In0,L_UI,0),
			atom={'+'(Plus), '+'(L_P),functor(normalfunc("+"),1), link(0, L_Plus0), mem(PlusM)},
			lmnconstructor.newlink(L_In1,L_I,1, L_Plus0, L_P, 0),
			mem={'+'(Mem), parent(M2), '+'(PlusM), atom(Plus), '+'(InM), atom(In), $child}.
	
		% リンクオブジェクトを作る
		% nobuddy は，buddyを持たないことを意味する．二回反応しないように(uniq使えばいい？)
		ConstructLink@@
		S=srclink(LinkName) :- string(LinkName) | link={name(LinkName), '+'(S), nobuddy }.
		
		% リンクオブジェクトへはlinkで参照する
		ConstructLink_1@@
		atom={$atom, child(Index, L)}, link={'+'(L), $link} :- int(Index) |
			atom={$atom, link(Index, L), '+'(A)}, link={'+'(L), $link, atom(A), pos(Index)}.
		
		%ConstructLink_2@@
		%proccxt={$proccxt, Impl(Index, L)}, link

		% 同膜内の同名のリンクはbuddy関係にある
		ConnectLink@@
		link={$link1, atom(A1), name(Name1), nobuddy}, A1={$atom1, mem(M1)},
		link={$link2, atom(A2), name(Name2), nobuddy}, A2={$atom2, mem(M2)},
		{$mem, '+'(M1), '+'(M2)}
			:- string(Name1), string(Name2), Name1=Name2 |
			link={$link1, atom(A1), name(Name1), buddy(B1), '+'(B2)}, A1={$atom1, mem(M1)},
			link={$link2, atom(A2), name(Name2), buddy(B2), '+'(B1)}, A2={$atom2, mem(M2)},
			{$mem, '+'(M1), '+'(M2)}.

		% 左辺最外部と右辺最外部にある同名リンクはbuddy関係にある
		ConnectLink2@@
		link={$link1, atom(A1), name(Name1), nobuddy}, A1={$atom1, mem(M1)},
		link={$link2, atom(A2), name(Name2), nobuddy}, A2={$atom2, mem(M2)},
		lhs={$lhs, '+'(M1)}, rhs={$rhs, '+'(M2)}
			:- string(Name1), string(Name2), Name1=Name2 |
			link={$link1, atom(A1), name(Name1), buddy(B1), '+'(B2)}, A1={$atom1, mem(M1)},
			link={$link2, atom(A2), name(Name2), buddy(B2), '+'(B1)}, A2={$atom2, mem(M2)},
			lhs={$lhs, '+'(M1)}, rhs={$rhs, '+'(M2)}.
		
		% 異なる膜内に同名のリンクがある場合、プロキシを挟んで親膜へ移動する
		% {a(X), ..}, {b(X), ..} ==> {a(~0), .., $in(~1, ~0)}, $out(~1, X), {b(X), ..}
		AddProxy1@@
		link={nobuddy, $link1, name(Name1), atom(A1), pos(PL), '+'(AL1)}, A1={$atom1, mem(M1), link(PA, AL1)}, M1={$mem1, parent(P)}, P={$parent},
		link={nobuddy, $link2, name(Name2), atom(A2)}, A2={$atom2, mem(M2)}, M2={$mem2},
			:- string(Name1), string(Name2), Name1=Name2, int(PL), int(PA) |
			link={nobuddy, $link1, name(Name1), atom(O1), pos(1), '+'(LOUT1)}, 
			atom={functor(out,2), '+'(O), '+'(O1), '+'(OutAtom), mem(MO), link(1, LOUT1), link(0, LOUT0)},
			lmnconstructor.newlink(LOUT0, O, 0, LIN0, I, 0),
			atom={functor(in, 2), '+'(I), '+'(I0), '+'(InAtom), mem(MI), link(1, LIN1), link(0, LIN0)},
			lmnconstructor.newlink(LIN1, I0, 1, AL, A0, PL),
			A0={$atom1, mem(M1), link(PA, AL)},
			M1={$mem1, parent(P), atom(InAtom), '+'(MI)},
			P={$parent, atom(OutAtom), '+'(MO)},
			link={nobuddy, $link2, name(Name2), atom(A2)}, A2={$atom2, mem(M2)}, M2={$mem2}.

		% 異なる膜内に同名のリンクがある場合、プロキシを挟んで親膜へ移動する
		% {a(X), {b(X)} ==> {a(X), .., $out(~1, X), {$in(~1, ~0), b(~0)}}
		AddProxy2@@
		link={nobuddy, $link1, name(Name1), atom(A1), pos(PL), '+'(AL1)}, A1={$atom1, mem(M1), link(PA, AL1)}, M1={$mem1, parent(P)},
		link={nobuddy, $link2, name(Name2), atom(A2)}, A2={$atom2, mem(M2)}, M2={$mem2, '+'(P)},
			:- string(Name1), string(Name2), Name1=Name2, int(PL), int(PA) |
			link={nobuddy, $link1, name(Name1), atom(O1), pos(1), '+'(LOUT1)}, 
			atom={functor(out,2), '+'(OFromL), '+'(O1), '+'(OutAtom), mem(MO), link(1, LOUT1), link(0, LOUT0)},
			lmnconstructor.newlink(LOUT0, OFromL, 0, LIN0, IFromL, 0),
			atom={functor(in, 2), '+'(IFromL), '+'(IFromL2), '+'(InAtom), mem(MI), link(1, LIN1), link(0, LIN0)},
			lmnconstructor.newlink(LIN1, IFromL2, 1, AL, A0, PL),
			A0={$atom1, mem(M1), link(PA, AL)},
			M1={$mem1, parent(P), atom(InAtom), '+'(MI)},
			P={$mem2, atom(OutAtom), '+'(MO), '+'(M2)},
			link={nobuddy, $link2, name(Name2), atom(A2)}, A2={$atom2, mem(M2)}.
		
	}.
	
}).

lmnconstructor.construct1({$g, @g}/) :-

lmnconstructor.construct2({$g. 

	constructing_rule={$rule, linkcount(LC), @rule}/ :- int(LC) | constructing_rule={$rule.

		% 左辺の膜か，右辺の膜かという情報を配る
		lhs={$lhs, mem(M)}, rhs={$rhs}, mem={'+'(M), $mem} :-
			lhs={$lhs, mem(M)}, rhs={$rhs}, lhsmem={'+'(M), $mem}.
		rhs={$rhs, mem(M)}, lhs={$lhs}, mem={'+'(M), $mem} :- 
			rhs={$rhs, mem(M)}, lhs={$lhs}, rhsmem={'+'(M), $mem}.
		lhs={$lhs}, rhs={$rhs}, lhsmem={$lhsmem, mem(M)}, mem={'+'(M), $mem} :-
			lhs={$lhs}, rhs={$rhs}, lhsmem={$lhsmem, mem(M)}, lhsmem={'+'(M), $mem}.
		rhs={$rhs}, lhs={$lhs}, rhsmem={$rhsmem, mem(M)}, mem={'+'(M), $mem} :- 
			rhs={$rhs}, lhs={$lhs}, rhsmem={$rhsmem, mem(M)}, rhsmem={'+'(M), $mem}.

		% 文脈定義に対し，左辺出現か右辺出現かという情報を配る
		cxtdef={$def, occ=O}, O={$cxt, mem=M}, lhsmem={'+'(M), $mem} :-
			cxtdef={$def, lhsocc=O}, O={$cxt, mem=M}, lhsmem={'+'(M), $mem}.
	
		cxtdef={$def, occ=O}, O={$cxt, mem=M}, rhsmem={'+'(M), $mem} :-
			cxtdef={$def, rhsocc=O}, O={$cxt, mem=M}, rhsmem={'+'(M), $mem}.
		
		% 右辺のみ、最外部出現あり(左辺の最外部出現はエラー)
		cxtdef={$def, occ=O}, O={$cxt, mem=M}, rhs={'+'(M), $mem} :-
			cxtdef={$def, rhsocc=O}, O={$cxt, mem=M}, rhs={'+'(M), $mem}.

		% リンク出現に対し、左辺出現か右辺出現かという情報を配る
		lhsmem={$lhsmem, atom(A)}, A={$atom, link(P,L)}, link={'+'(L), $link} :- int(P) |
			lhsmem={$lhsmem, atom(A)}, A={$atom, link(P,L)}, lhslink={'+'(L), $link}.
		rhsmem={$rhsmem, atom(A)}, A={$atom, link(P,L)}, link={'+'(L), $link} :- int(P) |
			lhsmem={$rhsmem, atom(A)}, A={$atom, link(P,L)}, rhslink={'+'(L), $link}.
		lhs={$lhs, atom(A)}, A={$atom, link(P,L)}, link={'+'(L), $link} :- int(P) |
			lhs={$lhs, atom(A)}, A={$atom, link(P,L)}, lhslink={'+'(L), $link}.
		rhs={$rhs, atom(A)}, A={$atom, link(P,L)}, link={'+'(L), $link} :- int(P) |
			rhs={$rhs, atom(A)}, A={$atom, link(P,L)}, rhslink={'+'(L), $link}.

		% リンク出現が4回(左辺に2回、右辺に2回)の時への対応
		% a(X), b(X') :- c(X) d(X') ==> a(X), b(X) :- c(X'), d(X')
		lhslink={name(N1), $link1, buddy(B1), '+'(B2)}, 
		rhslink={name(N2), $link2, buddy(B2), '+'(B1)},
		lhslink={name(N3), $link3, buddy(B3), '+'(B4)},
		rhslink={name(N4), $link4, buddy(B4), '+'(B3)} :-
			string(N1), string(N2), string(N3), string(N4), N1=N2, N1=N3, N1=N4 |
			lhslink={name(N1), $link1, buddy(B1), '+'(B3)}, 
			rhslink={name(N2), $link2, buddy(B2), '+'(B4)},
			lhslink={name(N3), $link3, buddy(B3), '+'(B1)},
			rhslink={name(N4), $link4, buddy(B4), '+'(B2)}.
		
	}.

}).

lmnconstructor.construct2({$g, @g}/) :-

lmnconstructor.construct3({$g.

	constructing_rule={$rule, @rule}/ :- constructing2_rule={$rule.
	
		lhsmem(M) :- mem(M).
		rhsmem(M) :- mem(M).

		lhslink(L) :- link(L).
		rhslink(R) :- link(R).
		
	}.
	
	constructing2_rule={$rule, @rule}/ :- rule={$rule}.

}).

lmnconstructor.construct3({$g, @g}/) :-
%
lmnconstructor.constructed_({$g}).

lmnconstructor.constructed_({global(G), $g[G]}/) :-

lmnconstructor.constructed(G),$g[G].

}.