*使い方
 /bin$ lmntal -I ../sample/kudo/lcl --use-source-library ../sample/kudo/lcl/frontend.lmn
で，標準入力にプログラムを入力．[EOF]で終わること．

*基本方針
-正しいプログラムに対して正しい命令列を吐く、ということができていればよい
--間違ったプログラムに対しての動作は未定義とする
--なぜなら、エラーチェックが相当に書きにくい上に、ソース上の位置を情報として取ってきていないので大したエラーメッセージが出せない。
--そういったエラーチェックを考えながらプログラムを書くと汚くなるものらしいので。

*注意事項
-ISBUDDY命令はリンクがbuddyであることを検査する命令．Java版には無いので追加するか，最適化で削除する
-未最適化時にはfindatom, anymem, getlink, isbuddyで全ての左辺の構造を見つける。当然効率が悪いので最適化必須。

*依存関係について
-同種の命令でも依存関係がある場合がある->命令の種類でソートするだけではだめ。
-例:NEWMEM, deref系, proxy関係等。
-そこで、命令を表すアトムの最終引数に依存関係項を作る。
-やっぱり依存関係は、単に各変数が出力変数として出てきたか、という情報をusable(0)みたいに表して、それを順序の制御に使うことにする
-ただし、proxy関係の命令や,removeまわりはまた別に制御が必要と思う。

*ガード
-ガードのコンパイルは、ヘッドをコンパイルした後にしたほうがいいような気がしてきた
-というか、ヘッドとボディを同時にコンパイルするのも本当は危険かも

*不明
-dequeuememは吐かれないようだがいいのだろうか

*DONE
**意味解析部での前処理
-アトム引数、膜引数の略記法の展開
-プロキシを挟む
**左辺
-findatom, anymem
-getlink, isbuddy
-stable
-natoms, nmems, norules, nfreelinks
**右辺
-newatom, newmem
-dequeueatom
-removeatom, removemem
-enqueueatom, enqueuemem
-freeatom, freemem
-copyrules
-alloclink, unifylinks
**その他
-spec, commit, proceed

*TODO
**debug
-プロセス文脈の引数にproxyを挟む
-ルールにproxyが出てきている時の、nfreelinksへの反映

**最適化
-isbuddyをderef, eqatomとかに置き換える． ==> 依存関係に注意
-Java版で行われている最適化
--CISC化
--再利用
--並び替えによる最適化
--ループ化
-アトム主導テスト

**意味解析
-同一ルールに同名リンクが三個出現する場合エラーに
-左辺に同名文脈が二つ以上出現する場合エラーに
-左辺に文脈が膜外に出現する場合エラーに
-型付きプロセス文脈関係
--型付きプロセス文脈関係は，Java版とはある程度違う命令列にしたほうが簡単かもしれない
