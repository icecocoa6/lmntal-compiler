{module(lmninstcollector).

	R=lmninstcollector.collect_insts({$g}) :-
	
		R=lmninstcollector.init({$g.
			rulename(RN) :- string(RN) | compiled_rule(RN, []).
		}).
		
		R=lmninstcollector.init({$g,@g}/) :-
		R=lmninstcollector.collect_free({$g.

			compiled_rule(RN, Rest), freeatom(A) :- int(A) |
				compiled_rule(RN, [freeatom(A)|Rest]).
		
		}).
		
		R=lmninstcollector.collect_free({$g,@g}/) :-
		R=lmninstcollector.collect_enqueue({$g.

			compiled_rule(RN, Rest), enqueueatom(A) :- int(A) |
				compiled_rule(RN, [enqueueatom(A)|Rest]).
		
		}).
		
		R=lmninstcollector.collect_enqueue({$g,@g}/) :-
		R=lmninstcollector.collect_make3({$g.
		
			compiled_rule(RN, Rest), unifylinks(L1, L2) :- int(L1), int(L2) |
				compiled_rule(RN, [unifylinks(L1, L2)|Rest]).
		
		}).
		
		R=lmninstcollector.collect_make3({$g, @g}/) :-
		R=lmninstcollector.collect_make2({$g.
		
			compiled_rule(RN, Rest), alloclink(L, A, P) :- int(L), int(A), int(P) |
				compiled_rule(RN, [alloclink(L, A, P)|Rest]).

		}).
		
		R=lmninstcollector.collect_make2({$g,@g}/) :-
		R=lmninstcollector.collect_make({$g.

			compiled_rule(RN, Rest), newatom(A, M, F) :- int(A), int(M), ground(F) |
				compiled_rule(RN, [newatom(A, M, F)|Rest]).

			compiled_rule(RN, Rest), loadruleset(M, RID) :- int(M), ground(RID) |
				compiled_rule(RN, [loadruleset(M, RID)|Rest]).
		
		}).
		
		R=lmninstcollector.collect_make({$g,@g}/) :-
		R=lmninstcollector.collect_remove({$g.

			compiled_rule(RN, Rest), removeatom(A, M, F) :- int(A), int(M), ground(F) |
				compiled_rule(RN, [removeatom(A, M, F)|Rest]).
		
		}).
		
		R=lmninstcollector.collect_remove({$g,@g}/) :-
		R=lmninstcollector.collect_find({$g.
		
			compiled_rule(RN, Rest), findatom(A, M, F) :- int(A), int(M), ground(F) |
				compiled_rule(RN, [findatom(A, M, F)|Rest]).

		}).
		
		R=lmninstcollector.collect_find({$g,@g}/) :-
		R=lmninstcollector.last_phase({$g.
		
		}).
		
	R=lmninstcollector.last_phase({$g, @g}/) :-
		R=insts_collected({$g}).
	
}.