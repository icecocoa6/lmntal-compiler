% プログラムを表すグラフ構造を，命令列に変換する
% 

{ module(lmncompiler).

	% 全体のコンパイル

	lmncompiler.compile={$g} :- lmncompiler.compiling1={$g.
	
		CompileRuleset1@@
		ruleset(RID, Rules) :- compiled_ruleset(RID, lmncompiler.compile_rules(Rules)).
		CompileRuleset2@@
		R=lmncompiler.compile_rules([Rule|Rest]) :- 
			R=[lmncompiler.compile_rule(Rule)|lmncompiler.compile_rules(Rest)].
		CompileRuleset3@@
		R=lmncompiler.compile_rules([]) :- R=[].

	}.
	
	lmncompiler.compiling1={$g, @g}/ :-
	lmncompiler.compiling2={$g.
	
		R=lmncompiler.compiled_rule({$rule, compiled_rule(RuleName, Insts)}) :- string(RuleName), ground(Insts) |
			R=compiled_rule(RuleName, Insts), $rule.
		
		rule('+') :- ().
	}.
	
	lmncompiler.compiling2={$g, @g}/ :- lmncompiler.compiled={ $g}.
	
	% 個々のルールのコンパイル
	% 1st Phase
	R=lmncompiler.compile_rule({
		$rule}) :-
		R=lmncompiler.compiling1_rule({
			lmnheadcompiler.phase1,
			lmnguardcompiler.phase1,
			lmnbodycompiler.phase1,
			$rule.
		}).
	
	% 2nd Phase
	R=lmncompiler.compiling1_rule({$rule, @rule}/) :-
		R=lmncompiler.compiling2_rule({$rule.
			lmnheadcompiler.phase2,
			lmnguardcompiler.phase2,
			lmnbodycompiler.phase2.
		}).
	
	% Numbering Phase
	R=lmncompiler.compiling2_rule({$rule, @rule}/) :-
		R=lmnnumberer.number({$rule}).

	% GC 1 Phase
	R=numbered({$rule, @rule}/) :-
		R=lmncompiler.gcing1_rule({$rule.
			lcl_gc.use1.
		}).

	% Instruction Collecting Phase
	R=lmncompiler.gcing1_rule({$rule, @rule}/) :-
		R=lmninstcollector.collect_insts({$rule}).

	% GC 2 Phase
	R=insts_collected({$rule, @rule}/) :-
		R=lmncompiler.gcing2_rule({$rule.
			lcl_gc.use2.
		}).

	% END
	R=lmncompiler.gcing2_rule({$rule, @rule}/):-
		R=lmncompiler.compiled_rule({$rule.
		}).
	
}.
