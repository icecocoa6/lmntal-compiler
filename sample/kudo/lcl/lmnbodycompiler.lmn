{module(lmnbodycompiler).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% 1st Phase %%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	lmnbodycompiler.phase1 :-
	
	lmnbodycompiler.remove, 
	lmnbodycompiler.make, 
	lmnbodycompiler.enqueue, 
	lmnbodycompiler.dequeue,
	lmnbodycompiler.free.
	
	( lmnbodycompiler.remove, lhs={$lhs} :- lmnbodycompiler.remove(R), lhs={'+'(R), $lhs} ),
	( lmnbodycompiler.make, rhs={$rhs} :- lmnbodycompiler.make(M), rhs={'+'(M), $rhs} ),
	( lmnbodycompiler.enqueue, rhs={$rhs} :- lmnbodycompiler.enqueue(M), rhs={'+'(M), $rhs} ),
	( lmnbodycompiler.dequeue, lhs={$lhs} :- lmnbodycompiler.dequeue(D), lhs={'+'(D), $lhs} ),
	( lmnbodycompiler.free, lhs={$lhs} :- lmnbodycompiler.free(F), lhs={'+'(F), $lhs} ),
	
%%%%%% M A K E %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% make for atom
	( MakeAtom@@
	lmnbodycompiler.make={$rhs, atom(A)} :-
		lmnbodycompiler.makeatom(A1), 
		lmnbodycompiler.make={$rhs, made_atom(A2)}, common.cpref(A1, A2, A) ),
	
	% make for mem
	( MakeMem@@
	lmnbodycompiler.make={$rhs, mem(M)} :-
		lmnbodycompiler.makemem(M1),
		lmnbodycompiler.make={$rhs, made_mem(M2)}, common.cpref(M1, M2, M) ),
	
	% NEWATOM
	( NewAtom@@
	lmnbodycompiler.makeatom({$atom, functor(F, A), mem(M)}) :- ground(F), int(A) |
		newatom({$atom, functor(F, A), mem(M1)}, M2, common.str_of_functor(F, A)),
		common.cpref(M1, M2, M) ),
	
	% NEWMEM
	% 種類0以外は未対応
	% newmemの最後の引数は依存関係を表す
	( NewMem@@
	lmnbodycompiler.makemem({$mem, parent(P)}) :- 
		lmnbodycompiler.make(M), newmem({$mem, parent(P1), '+'(M)}, P2, 0), common.cpref(P1, P2, P) ),
	
	% ALLOCLINK
	( newatom({$atom, link(P1, L1)}, M, F) :- int(P1) |
		newatom({$atom}, M, F), lmnbodycompiler.alloclink(L1) ),
	( lmnbodycompiler.alloclink({$link, pos(P), atom(A)}) :- int(P) | alloclink({$link}, A, P) ),

	% UNIFYLINKS
	( {buddy(B1), '+'(B2), $link}, {'+'(B1), buddy(B2), $buddy} :- unifylinks({$link}, {$buddy}) ),	

	% LOADRULESET
	( lmnbodycompiler.make={$rhs, rules(RID)} :- 
		loadruleset(M, RID), lmnbodycompiler.make={$rhs, '+'(M)} ),
	
	% COPYRULES
	( cxtdef={$def, lhsocc=L, rhsocc=R}, 
		rulecxt={'+'(L), mem(LM), $lcxt}, LM={$lmem}, rulecxt={'+'(R), mem(RM), $rcxt}, RM={$rmem} :-
		rulecxt={'+'(L), mem(LM), $lcxt}, LM={$lmem, '+'(LC)}, rulecxt={$rcxt}, {$rmem, '+'(RC)},
		copyrules(RC, LC), cxtdef={$def, lhsocc=L} ),
	
	% INSERTCONNECTORS
	( cxtdef={$def, lhsocc=L}, proccxt={'+'(L), $lhsocc, mem=M} :- 
		cxtdef={$def, connector_inserted_lhsocc=L, connector_set=S}, connector_set=CS,
		insertconnectors({'+'(S), '+'(CS)}, [], M1), proccxt={'+'(L), $lhsocc, mem=M2}, common.cpref(M1, M2, M) ),
	
	% プロセス文脈の明示的な自由リンクの相方は既にアトムの引数としてGETLINKが発行されている
	( insertconnectors(S, Rest, {$lhsmem, proccxt=P}), P={$lhsocc, impl(PI, L)}, {$link, '+'(L)} :- int(PI) |
		insertconnectors(S, [C|Rest], {$lhsmem, proccxt=P}), P={$lhsocc, connector_inserted_impl(PI, L)}, {$link, '+'(L), '+'(C)} ), 
	
	% DELETECONNECTORS, COPYCELLS
	( cxtdef={$def, connector_inserted_lhsocc=L, rhsocc=R, connector_set=S},S={$set},
		proccxt={'+'(L), mem(LM), $lcxt}, LM={$lmem}, proccxt={'+'(R), mem(RM), $rcxt}, RM={$rmem} :-
		proccxt={'+'(L), mem(LM), $lcxt}, LM={$lmem, '+'(LC)}, proccxt={$rcxt}, {$rmem, '+'(RC), '+'(RD)},
		deleteconnectors(SD, CM2, RD), S={$set, '+'(SD)},
		copycells(CM, RC, LC), cellmap={'+'(CM), '+'(CM2)},
		cxtdef={$def, connector_inserted_lhsocc=L, connector_set=S} ),

	% DROPMEM
	( cxtdef={$def, connector_inserted_lhsocc=LO}, LO={$lhsocc, mem(M)}, M={$mem} :-
		cxtdef={$def}, {$lhsocc, mem(M)}, M={$mem, '+'(D)}, dropmem(D) ),

%%%%%% E N Q U E U E %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	( Enqueue1@@
	lmnbodycompiler.enqueue({$rhs, made_atom(A)}) :-
		lmnbodycompiler.enqueueatom(A),
		lmnbodycompiler.enqueue({$rhs}) ),
	
	% ENQUEUEATOM
	( EnqueueAtom@@
		lmnbodycompiler.enqueueatom({$atom}) :- enqueueatom({$atom}) ),

	( Enqueue2@@
	lmnbodycompiler.enqueue({$rhs, made_mem(M)}) :-
		lmnbodycompiler.enqueuemem(M),
		lmnbodycompiler.enqueue({$rhs}) ),
	
	% ENQUEUEMEM
	( EnqueueMem@@
		lmnbodycompiler.enqueuemem({$mem}) :- lmnbodycompiler.enqueue(E), enqueuemem({$mem, '+'(E)}) ),

%%%%%% R E M O V E %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	( Remove1@@
	lmnbodycompiler.remove({$lhs, found_atom(A)}) :-
		lmnbodycompiler.removeatom(A1), 
		lmnbodycompiler.remove({$lhs, removed_atom(A2)}), common.cpref(A1, A2, A) ),
	
	( Remove2@@
	lmnbodycompiler.remove({$lhs, found_mem(M)}) :-
		lmnbodycompiler.removemem(M1),
		lmnbodycompiler.remove({$lhs, removed_mem(M2)}), common.cpref(M1, M2, M) ),

	% REMOVEATOM
	( RemoveAtom@@
	lmnbodycompiler.removeatom({$atom, mem(M), functor(F, A)}) :- ground(F), int(A) |
		removeatom({$atom, functor(F, A), mem(M1)},
		M2, common.str_of_functor(F, A)), common.cpref(M1, M2, M) ),

	% REMOVEMEM
	( RemoveMem@@
	lmnbodycompiler.removemem({$mem, parent(P)}) :-
		lmnbodycompiler.remove(R), removemem({$mem, parent(P1), '+'(R)}, P2), common.cpref(P1, P2, P) ),
		
%%%%%% D E Q U E U E %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	( Dequeue@@
	lmnbodycompiler.dequeue({$lhs, removed_atom(A)}) :-
		lmnbodycompiler.dequeueatom(A1), lmnbodycompiler.dequeue({$lhs, dequeued_atom(A2)}), common.cpref(A1, A2, A) ),
	
	( Dequeue1@@
	lmnbodycompiler.dequeue({$lhs, removed_mem(M)}) :-
		lmnbodycompiler.dequeuemem(M1), lmnbodycompiler.dequeue({$lhs, dequeued_mem(M2)}), common.cpref(M1, M2, M) ),
	
	( DequeueMem@@
	lmnbodycompiler.dequeuemem({$mem}) :- lmnbodycompiler.dequeue({$mem}) ),
	
	% DEQUEUEATOM
	( DequeueAtom@@
	lmnbodycompiler.dequeueatom(A) :- dequeueatom(A) ),

%%%%%% F R E E %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	( Free1@@
	lmnbodycompiler.free({$lhs, dequeued_atom(A)}) :-
		lmnbodycompiler.freeatom(A), lmnbodycompiler.free({$lhs}) ),
	
	% FREEATOM
	( FreeAtom@@
	lmnbodycompiler.freeatom({$atom}) :- freeatom({$atom}) ),

	( Free2@@
	lmnbodycompiler.free({$lhs, dequeued_mem(M)}) :-
		lmnbodycompiler.freemem(M), lmnbodycompiler.free({$lhs}) ),
	
	% FREEMEM
	( FreeMem@@
	lmnbodycompiler.freemem({$mem}) :- lmnbodycompiler.free(F), freemem({$mem, '+'(F)}) ),

	().


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	
%%%%%% 2nd Phase %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	lmnbodycompiler.phase2 :-
	
	( lmnbodycompiler.make({$rhs}) :- {$rhs} ),
	( lmnbodycompiler.enqueue({$rhs}) :- {$rhs} ),
	( lmnbodycompiler.remove({$lhs}) :- {$lhs} ),
	( lmnbodycompiler.dequeue({$lhs}) :- {$lhs} ),
	( lmnbodycompiler.free({$lhs}) :- {$lhs} ),
	
	().

}.