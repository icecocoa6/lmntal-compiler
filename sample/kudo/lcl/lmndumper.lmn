{module(lmndumper).

	lmndumper.dump={$g, global=[rulesetid(GID)]} :- int(GID) |
	lmndumper.dump_first={$g.
		lmndumper.now(GID). % 初期生成ルールを最初に出力する
		
		% 初期生成ルールセットIDを持つルールセットを探してきて出力
		lmndumper.now(N), compiled_ruleset(RID, Rules) :- N=:=RID |
			lmndumper.dump_rules(RID, Rules).
	}.
	
	lmndumper.dump_first={$g, lmndumper.dumped, @g}/ :-
	lmndumper.dump_rest={$g.
		
		lmndumper.dumped.

		% 残ったルールセットを順に出力(lmndumper.dumpedは排他制御の為のアトム)		
		lmndumper.dumped, compiled_ruleset(RID, Rules) :- lmndumper.dump_rules(RID, Rules).
		
	}.
	
	lmndumper.dump_rest={$g, lmndumper.dumped, @g}/ :-
		lmndumper.dumped={$g}.

	% ルールセットの出力
	% ルールセットID
	lmndumper.dump_rules(RID, Rules) :- int(RID) |
		lmndumper.dumping_rules_id(io.print("Compiled Ruleset @"++string.str_of_int(RID)), Rules).
	% ルール列の出力
	lmndumper.dumping_rules_id(done, Rules) :- lmndumper.dumping_rules(Rules).
	lmndumper.dumping_rules([]) :- lmndumper.dumped.

	% ルールの出力
	% ルール名の出力
	lmndumper.dumping_rules([compiled_rule(RuleName, AtomMatch, MemMatch, Guard, Body)|Rest]) :-
		string(RuleName) |
		lmndumper.dumping_rulename(io.print("Compiled Rule "++RuleName), AtomMatch, MemMatch, Guard, Body, Rest).
	% アトム主導テスト命令列出力
	lmndumper.dumping_rulename(done, AtomMatch, MemMatch, Guard, Body, Rest) :-
		lmndumper.dumping_atommatch(io.print("\t--atommatch:"), AtomMatch, MemMatch, Guard, Body, Rest).
	lmndumper.dumping_atommatch(done, AtomMatch, MemMatch, Guard, Body, Rest) :-
		lmndumper.dumping_atommatch_insts(lmndumper.dump_insts(AtomMatch), MemMatch, Guard, Body, Rest).
	% 膜主導テスト命令列出力
	lmndumper.dumping_atommatch_insts(done, MemMatch, Guard, Body, Rest) :-
		lmndumper.dumping_memmatch(io.print("\t--memmatch:"), MemMatch, Guard, Body, Rest).
	lmndumper.dumping_memmatch(done, MemMatch, Guard, Body, Rest) :-
		lmndumper.dumping_memmatch_insts(lmndumper.dump_insts(MemMatch), Guard, Body, Rest).
	% ガード命令列出力(未実装)
	lmndumper.dumping_memmatch_insts(done, Guard, Body, Rest) :-
		lmndumper.dumping_guard(Guard, Body, Rest).
	% ボディ命令列出力(未実装)
	lmndumper.dumping_guard(none, Body, Rest) :-
		lmndumper.dumping_body(Body, Rest).
	% ルール出力終了
	lmndumper.dumping_body(none, Rest) :-
		lmndumper.dumping_rules(Rest).


	% 文字列連結演算子
	R=S1++S2 :- string(S1), string(S2) | R=string.concat(S1, S2).

	% 命令の順次出力
	R=lmndumper.dump_insts([Inst|Rest]) :- R=lmndumper.dumping_inst(io.print("\t\t"++str_of_inst(Inst)),Rest).
	R=lmndumper.dumping_inst(done, Rest) :- R=lmndumper.dump_insts(Rest).
	R=lmndumper.dump_insts([]) :- R=lmndumper.dump_ln(io.print("")).
	R=lmndumper.dump_ln(done) :- R=done.
	lmndumper.dumping_insts(done, Rest) :- lmndumper.dumping_rules(Rest).

	% 変数番号出力
	R=var_str(v(N)) :- R=string.str_of_int(N).

	R=varlist_str(VL) :- R="["++varlist_commasep(VL)++"]".
	
	R=varlist_commasep([]) :- R="".
	R=varlist_commasep([V|Rest]) :- R=var_str(V)++varlist_commasep_rest(Rest).
	R=varlist_commasep_rest([C|Rest]) :- R=", "++varlist_commasep([C|Rest]).
	R=varlist_commasep_rest([]) :- R="".

	% 各命令ごとの出力ルール

	R=str_of_inst(findatom(A, M, F)) :- string(F) |
		R="findatom    ["++var_str(A)++", "++var_str(M)++", "++F++"]".
	R=str_of_inst(anymem(M, P, S)) :- 
		R="anymem      ["++var_str(M)++", "++var_str(P)++", "++string.str_of_int(S)++"]".
	R=str_of_inst(newatom(A, M, F)) :- string(F) |
		R="newatom     ["++var_str(A)++", "++var_str(M)++", "++F++"]".
	R=str_of_inst(newmem(M, P, S)) :- 
		R="newmem      ["++var_str(M)++", "++var_str(P)++", "++string.str_of_int(S)++"]".
	R=str_of_inst(removeatom(A, M, F)) :- string(F) |
		R="removeatom     ["++var_str(A)++", "++var_str(M)++", "++F++"]".
	R=str_of_inst(removemem(M, P)) :- 
		R="removemem      ["++var_str(M)++", "++var_str(P)++"]".
	R=str_of_inst(enqueueatom(A)) :- 
		R="enqueueatom    ["++var_str(A)++"]".
	R=str_of_inst(dequeueatom(A)) :- 
		R="dequeueatom    ["++var_str(A)++"]".
	R=str_of_inst(enqueuemem(M)) :- 
		R="enqueuemem     ["++var_str(M)++"]".
	R=str_of_inst(freeatom(A)) :- 
		R="freeatom       ["++var_str(A)++"]".
	R=str_of_inst(freemem(M)) :- 
		R="freemem        ["++var_str(M)++"]".
	R=str_of_inst(dropmem(M)) :- 
		R="dropmem        ["++var_str(M)++"]".
	R=str_of_inst(loadruleset(M,rulesetid(RID))) :- int(RID) |
		R="loadruleset    ["++var_str(M)++", "++"@"++string.str_of_int(RID)++"]".
	R=str_of_inst(alloclink(L, A, P)) :- int(P) |
		R="alloclink   ["++var_str(L)++", "++var_str(A)++", "++string.str_of_int(P)++"]".
	R=str_of_inst(getlink(L, A, P)) :- int(P) |
		R="getlink     ["++var_str(L)++", "++var_str(A)++", "++string.str_of_int(P)++"]".
	R=str_of_inst(unifylinks(L1, L2)) :- 
		R="unifylinks     ["++var_str(L1)++", "++var_str(L2)++"]".
	R=str_of_inst(copyrules(M1, M2)) :- 
		R="copyrules      ["++var_str(M1)++", "++var_str(M2)++"]".
	R=str_of_inst(copycells(CS, M1, M2)) :- 
		R="copycells      ["++var_str(CS)++", "++var_str(M1)++", "++var_str(M2)++"]".
	R=str_of_inst(insertconnectors(CMAP, LL, M)) :- 
		R="insertconnectors["++var_str(CMAP)++", "++varlist_str(LL)++", "++var_str(M)++"]".
	R=str_of_inst(deleteconnectors(CM, CS, M)) :- 
		R="deleteconnectors["++var_str(CM)++", "++var_str(CS)++", "++var_str(M)++"]".
	R=str_of_inst(isbuddy(L1,L2)) :- 
		R="isbuddy        ["++var_str(L1)++", "++var_str(L2)++"]".
	R=str_of_inst(testmem(M, A)) :- 
		R="testmem        ["++var_str(M)++", "++var_str(A)++"]".
	R=str_of_inst(dereflink(L, A, P)) :- int(P) |
		R="dereflink   ["++var_str(L)++", "++var_str(A)++", "++string.str_of_int(P)++"]".
	R=str_of_inst(func(A, F)) :- string(F) |
		R="func           ["++var_str(A)++", "++F++"]".
	R=str_of_inst(eqatom(A1, A2)) :- 
		R="eqatom         ["++var_str(A1)++", "++var_str(A2)++"]".
	R=str_of_inst(neqatom(A1, A2)) :- 
		R="neqatom        ["++var_str(A1)++", "++var_str(A2)++"]".
	R=str_of_inst(natoms(M, C)) :- 
		R="natoms         ["++var_str(M)++", "++string.str_of_int(C)++"]".
	R=str_of_inst(nmems(M, C)) :- 
		R="nmems          ["++var_str(M)++", "++string.str_of_int(C)++"]".
	R=str_of_inst(nfreelinks(M, C)) :- 
		R="nfreelinks     ["++var_str(M)++", "++string.str_of_int(C)++"]".
	R=str_of_inst(norules(M)) :- 
		R="norules        ["++var_str(M)++"]".
	R=str_of_inst(stable(M)) :- 
		R="stable         ["++var_str(M)++"]".
	R=str_of_inst(spec(F, L)) :- 
		R="spec           ["++string.str_of_int(F)++", "++string.str_of_int(L)++"]".
	R=str_of_inst(proceed) :- 
		R="proceed        []".
	R=str_of_inst(commit(RN)) :- string(RN) |
		R="commit         [\""++RN++"\"]".


}.