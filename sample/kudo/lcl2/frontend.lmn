% lcl : LMNtal Compiler on LMNtal

% 以下はいずれ別ファイルに

{
module(char).
C=char.charlist_of_string(S) :- S \= "" |
C=[ string.substring(S,0,1)|char.charlist_of_string(string.substring(S,1))].
C=char.charlist_of_string(S) :- S == "" | C=[].

C=char.charlist_of_stringlist([S|SR]):-
C=list.append(
	char.charlist_of_string(S),["\\n"|
		char.charlist_of_stringlist(SR)]).
C=char.charlist_of_stringlist([]):-C=[].

C=char.string_of_charlist([S|L]) :- C=string.concat(S,(char.string_of_charlist(L))).
C=char.string_of_charlist([]) :- C="".
}.

% 入力文字列をlmnlexerに通す

io.use.

I=done, result(S) :- string(S)|I = [S|io.readline(result)].
I=nil, result(""):-I=[].

INPUT=input(char.charlist_of_stringlist(io.readline(result))).

//出すルール
lexing{$lexing[LR|*V],L=[token(_Gtkind,_Gtargs,_Gtpos)|LR],@l}/:-
	L=[token(_Gtkind,_Gtargs,_Gtpos)|LR],lexing{$lexing[LR|*V],@l}.
lexing{$lexing,L=[],@l}/:-
	L=[], lexing{$lexing}.
//入れるルール
I=input([S|R]), lexing{$lexing[I|*L],@l}/:-string(S)|
	I1=input(R), lexing{I=[S|I1],$lexing[I|*L],@l}.
I=input([]), lexing{$lexing[I|*L],@l}/:-
	lexing{I=[], $lexing[I|*L],@l}.

lexing{
//	R=append([C|L1],L2):-R=[C|append(L1,L2)].
//	R=append([],L2):-R=L2.
//	lmnlexer.use.
	Lexed = lmnlexer.lex(INPUT).
}.

lexed=Lexed.

lexed(_GTokens):- parsing{lmnparser.parse(_GTokens)}.

% main

% 全入力tokenをlmnparserにかける(ここは、本当は全部わたす必要はなく、並列処理できる。
% でも、そもそもここまではinlineでもいいかもしれない)
//lexing={l=Lexed, $l[Lexed],@l}/ :- parsing={lmnparser.parse(Lexed), $l[Lexed]}.
//parsing={lmnparser.parsed(Parsed), $p[Parsed], @p}/ :- constructing={lmnconstructor.construct(Parsed), $p[Parsed]}.
//constructing={lmnconstructor.constructed(Constructed), $c[Constructed], @c}/ :- compiling={lmncompiler.compile({global(Constructed), $c[Constructed]}) }.
//compiling={lmncompiler.compiled(Compiled), {$c[Compiled], @c}/, @cc}/ :- dumping={lmndumper.dump(Compiled), {$c[Compiled]}}.
//dumping={lmndumper.dumped(Dumped), {$d[Dumped]}/, @d}/ :- end=Dumped, {$d[Dumped]}.

%end={io.stdin(SI), io.stdout(SO), $e}/ :- unary(SI), unary(SO) | end={c(io.close(SI), io.close(SO)), $e}.
