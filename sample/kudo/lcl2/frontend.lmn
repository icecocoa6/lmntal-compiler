% lcl : LMNtal Compiler on LMNtal

% 以下はいずれ別ファイルに

{
module(char).
C=char.charlist_of_string(S) :- S \= "" |
C=[ string.substring(S,0,1)|char.charlist_of_string(string.substring(S,1))].
C=char.charlist_of_string(S) :- S = "" | C=[].

C=char.charlist_of_stringlist([S|SR]):-
C=list.append(
	char.charlist_of_string(S),["\\n"|
		char.charlist_of_stringlist(SR)]).
C=char.charlist_of_stringlist([]):-C=[].

C=char.string_of_charlist([S|L]) :- C=string.concat(S,(char.string_of_charlist(L))).
C=char.string_of_charlist([]) :- C="".
}.

% 入力文字列をlmnlexerに通す
lexing = {
//	R=append([C|L1],L2):-R=[C|append(L1,L2)].
//	R=append([],L2):-R=L2.
//	lmnlexer.use.
	io.use.
	
	I=input :- I=char.charlist_of_stringlist(io.readline(result)).
	I=done, result(S) :- string(S)|I = [S|io.readline(result)].
	I=nil, result(""):-I=[].
	
	l = lmnlexer.lex(input).
}.

% main

% 全入力tokenをlmnparserにかける(ここは、本当は全部わたす必要はなく、並列処理できる。
% でも、そもそもここまではinlineでもいいかもしれない)
//lexing={l=Lexed, $l[Lexed],@l}/ :- parsing={lmnparser.parse(Lexed), $l[Lexed]}.
//parsing={lmnparser.parsed(Parsed), $p[Parsed], @p}/ :- constructing={lmnconstructor.construct(Parsed), $p[Parsed]}.
//constructing={lmnconstructor.constructed(Constructed), $c[Constructed], @c}/ :- compiling={lmncompiler.compile({global(Constructed), $c[Constructed]}) }.
//compiling={lmncompiler.compiled(Compiled), {$c[Compiled], @c}/, @cc}/ :- dumping={lmndumper.dump(Compiled), {$c[Compiled]}}.
//dumping={lmndumper.dumped(Dumped), {$d[Dumped]}/, @d}/ :- end=Dumped, {$d[Dumped]}.

%end={io.stdin(SI), io.stdout(SO), $e}/ :- unary(SI), unary(SO) | end={c(io.close(SI), io.close(SO)), $e}.
