// LMNtalソース用構文解析器
// with lmnlexer, seq
// by kudo
//
// SINCE 2006/06/28(Wed.)

{
module(lmnparser).

lmnparser.parse(Tokens) :- ground(Tokens) |

lmnparser.parsed=seq.run({src(Tokens)},

[
// 諸々の名前を処理する
// リンク名/アトム名 @@ を、ルール名とする
// $ アトム名 を、プロセス文脈名とする
// @ アトム名を、ルール文脈とする
// "mod" という名前を予約語として認識する
{
	LinkName_At_At@@
	L=[token(linkname,LN,LPos), token(at_at,[],_GAPos)|R] :-
		L=[token(rulename,LN,LPos)|R].
	
	AtomName_At_At@@
	L=[token(atomname,AN,APos), token(at_at,[],_GAPos)|R] :-
		L=[token(rulename,AN,APos)|R].
	
	Dollar_AtomName@@
	L=[token(dollar,[],DPos), token(atomname,AN,_GAPos)|R] :-
		L=[token(proccxtname,AN,DPos)|R].
	
	At_AtomName@@
	L=[token(at,[],AtPos), token(atomname,AN,_GAPos)|R] :-
		L=[token(rulecxtname,AN,AtPos)|R].
	
	Mod@@
	L=[token(atomname,["mod"],APos)|R] :- L=[token(mod,[],APos)|R].
},

// 通常アトム
// 数字リテラル
// 小数リテラル
// '..'
// ".."
// [: .. :]
{
	Parse_NormalAtomName@@
	L=[token(atomname,[AN],APos)|R] :- L=[token(funcname,[normalfunc(AN)],APos)|R].

	Parse_Int@@
	L=[token(num,[N],NPos)|R] :- L=[token(funcname,[intfunc(N)],NPos)|R].
	
	Parse_Float@@
	L=[token(floatnum,[FN],FPos)|R] :- L=[token(funcname,[floatfunc(FN)],FPos)|R].
	
	Parse_SQString@@
	L=[token(sq_string,[SS],SPos)|R] :- L=[token(funcname,[normalfunc(SS)],SPos)|R].
	
	Parse_DQString@@
	L=[token(dq_string,[DS],DPos)|R] :- L=[token(funcname,[stringfunc(DS)],DPos)|R].

	Parse_BracketString@@
	L=[token(bracket_string,[DS],DPos)|R] :- L=[token(funcname,[stringfunc(DS)],DPos)|R].
},

// error check
{
	RuleName_Error@@
	L=[token(at_at,[],APos)|R]:-
		L=R, syntax_error("SYNTAX_ERROR : '@@' can't find name", APos), stop_seq.

	Process_Context_Name_Error1@@
	L=[token(dollar,[],DPos)|R]:-
		L=R, syntax_error("SYNTAX ERROR : '$' can't find name", DPos), stop_seq.
	
	Rule_Context_Name_Error@@
	L=[token(at,[],APos)|R]:-
		L=R, syntax_error("SYNTAX_ERROR : '@' can't find name", APos), stop_seq.
},

// まず、'{', '}' で切り分ける
{
	// ground,unaryの比較に定数項が使えない為
	braces_t(lbrace, rbrace).

	// '{'は膜の始まり
	Parse_Braces1@@
	L=[token(lbrace,[],LBPos)|R] :- L=[braces_begin(LBPos,B,B)|R].
	
	// '}'は膜の終わり
	Parse_Braces2@@
	L=[braces_begin(LBPos, MH, MT), token(rbrace,RArg,_GRBPos)|R] :-
		L=[token(braces,[MH|RArg],LBPos)|R], MT=[].
	
	// '{', '}'以外が出てきたら膜の中に入れる
	// ※ '{'もはじくことによって、階層構造にも対応できている
	Parse_Braces3@@
	L=[braces_begin(LBPos,MH,MT), token($tkind, TArgs, TPos)|R], braces_t($lbrace, $rbrace) :-
		$tkind \= $lbrace, $tkind \= $rbrace|
		L=[braces_begin(LBPos,MH,T)|R], MT=[token($tkind,TArgs,TPos)|T],
		braces_t($lbrace,$rbrace).
},

// エラーチェック ( { } の対応誤り )
{
	braces_t(lbrace, rbrace) :- ().
	
	// { が余る
	LBrace_Error@@
	L=[braces_begin(LPos,MH,MT)|R] :-
		L=R, dead_srcmem(MH), MT=[],
		syntax_error("SYNTAX ERROR : '{' can't find '}'. ", LPos), stop_seq.
	
	// } が余る
	RBrace_Error@@
	L=[token(rbrace,_GRArg,RPos)|R] :-
		L=R, syntax_error("SYNTAX ERROR : '}' can't find '{'. ", RPos), stop_seq.
},

//各文(膜内は独立した文)の終わりに'.'が無ければ挿入する
{
	dot_t(dot).

	Insert_Dots@@
	L=[token($last_token,LArgs,LPos)], dot_t($dot) :- $last_token \= $dot |
		dot_t($dot), L=[token($last_token,LArgs,LPos), token(dot,[],nopos)].
},

// '.'で切り分ける
{
	Parse_Dots1@@
	L=[token(dot,[],_GDPos)|R] :- L=[sentence([])|R].

	Parse_Dots2@@
	L=[token($tkind,TArgs,TPos), sentence(RestTokens)|R], dot_t($dot) :-
		$tkind \= $dot|
		L=[sentence([token($tkind,TArgs,TPos)|RestTokens])|R], dot_t($dot).
},

// '(' ')' '[' ']'で切り分ける
{
	dot_t(dot):-().

	parens_t(lparen, rparen).
	brackets_t(lbracket, rbracket).
	
	Parse_Parens1@@
	L=[token(lparen,[],LPos)|R] :- L=[parens_begin(LPos,B,B)|R].
	
	Parse_Parens2@@
	L=[parens_begin(LPos,MH,MT), token(rparen,[],_GRPos)|R] :-
		L=[token(parens,[MH],LPos)|R], MT=[].
	
	Parse_Parens3@@
	L=[parens_begin(LPos, MH, MT), token($tkind,TA,TP)|R], parens_t($lparen, $rparen) :-
		$tkind \= $lparen, $tkind \= $rparen|
		L=[parens_begin(LPos, MH, T)|R], MT=[token($tkind, TA, TP)|T],
		parens_t($lparen, $rparen).

	Parse_Brackets1@@
	L=[token(lbracket,[],LBPos)|R] :- L=[brackets_begin(LBPos, B, B)|R].
	
	Parse_Brackets2@@
	L=[brackets_begin(LBPos, MH, MT), token(rbracket, [], _GRBPos)|R] :-
		L=[token(brackets,[MH],LBPos)|R], MT=[].
	
	Parse_Brackets3@@
	L=[brackets_begin(LBPos, MH, MT), token($tkind,TA,TP)|R], brackets_t($lbracket, $rbracket):-
		$tkind \= $lbracket, $tkind \= $rbracket|
		L=[brackets_begin(LBPos, MH, T)|R], MT=[token($tkind, TA,TP)|T],
		brackets_t($lbracket, $rbracket).
},

{
	parens_t(lparen,rparen):-().
	brackets_t(lbracket,rbracket):-().

	LParen_Error@@
	L=[parens_begin(LPos,MH,MT)|R] :-
		L=R, dead_parens(MH), MT=[],
		syntax_error("SYNTAX ERROR : '(' can't find ')'. ", LPos), stop_seq.
	
	RParen_Error@@
	L=[token(rparen,[],RPos)|R] :-
		L=R, syntax_error("SYNTAX ERROR : ')' can't find '('. ", RPos), stop_seq.

	LBracket_Error@@
	L=[brackets_begin(LPos,MH,MT)|R] :-
		L=R, dead_brackets(MH), MT=[],
		syntax_error("SYNTAX ERROR : '[' can't find ']'. ", LPos), stop_seq.
	
	RBracket_Error@@
	L=[token(rbracket,[],RPos)|R] :-
		L=R, syntax_error("SYNTAX ERROR : ']' can't find '['. ", RPos), stop_seq.
},

// a(...) $p[...]
{
	Parse_ArityAtom@@
	L=[token(funcname,[FA],FPos), token(parens,[PA],_GPPos)|R] :-
		L=[token(atom,[FA,PA],FPos)|R].

},

// ... :- ... | ... の処理
{
	bar_t(bar).
	
	Parse_Rule1@@
	L=[token(colon_minus,[],CMPos)|R] :- L=[head([],CMPos),body(P,P)|R].
	
	Parse_Rule2@@
	L=[T,head(Rest,RPos)|R] :-L=[head([T|Rest],RPos)|R].
	
	Parse_Rule3@@
	L=[body(H,T),token($tkind,TA,TP)|R], bar_t($bar) :- $tkind \= $bar |
		L=[body(H,PT)|R], T=[token($tkind,TA,TP)|PT], bar_t($bar).
	
	Parse_Rule4@@
	L=[body(H,T),token(bar,[],_GBPos)|R] :- L=[guard(H),body(P,P)|R], T=[].
},

// ルールを作る
{
	bar_t(bar):-().
	
	Parse_HeadBodyRule@@
	L=[head(H,RPos), body(BH,BT)] :- L=[token(rule,["", H, [], BH],RPos)], BT=[].

	Parse_HeadGuardBodyRule@@
	L=[head(H,RPos), guard(G), body(BH,BT)] :-
		L=[token(rule,["", H, G, BH],RPos)], BT=[].
	
	Parse_NamingRule@@
	T=token(rule,["", [token(rulename,[RN],_GRNPos)|H], G, B],RPos) :-
		T=token(rule,[RN, H, G, B],RPos).
	
},

// [ ] 内を '|' でわける
{
	
	Parse_Bar@@
	L=[token(bar,[],BPos)|R] :- L=[before_bar(BPos,[]), after_bar(P,P)|R].
	
	Parse_BeferBar@@
	L=[token(TK,TA,TP), before_bar(BPos,P)|R] :-
		L=[before_bar(BPos,[token(TK,TA,TP)|P])|R].
	
	Parse_BarRest@@
	L=[after_bar(H,T), token(TK,TA,TP)|R] :-
		L=[after_bar(H,BT)|R], T=[token(TK,TA,TP)|BT].
	Parse_CarCdr@@
	L=[token(brackets,[[before_bar(_GBarPos, Car), after_bar(Cdr, CdrT)]],BPos)|R] :-
		L=[token(brackets_with_bar,[Car, Cdr],BPos)|R], CdrT=[].

},

// pc のリンクリスト
{
	ParseProcCxtLinkList@@
	L=[token(proccxtname,[PN],PPos), token(brackets,[Ps],_GBPos)|R]:-
		L=[token(proccxt,[PN,[Ps],[]],PPos)|R].
	ParseProcCxtLinkList2@@
	L=[token(proccxtname,[PN],PPos), token(brackets_with_bar,[Car,Cdr],_GBPos)|R]:-
		L=[token(proccxt,[PN,Car,Cdr],PPos)|R].
},

//各リストの終わりに','を挿入する
//TODO : この前の段階で、終わりに','があるリストは構文エラーにする
{
	comma_t(comma).

	Insert_Comma@@
	L=[token($lasttoken,LA,LP)], comma_t($comma) :- $lasttoken \= $comma |
		L=[token($lasttoken,LA,LP),token(comma,[],nopos)], comma_t($comma).
},

// ','で切り分ける
{
	Parse_Comma1@@
	L=[token(comma,[],_GCPos)|R] :- L=[clause([])|R].

	Parse_Comma2@@
	L=[token($tkind,TA,TP), clause(Rest)|R], comma_t($comma) :-
		$tkind \= $comma|
		L=[clause([token($tkind,TA,TP)|Rest])|R], comma_t($comma).
},

{
	comma_t(comma):-().
	src=[clause(C)] :- src=C.

	ParseList2@@
	L=[token(brackets_with_bar,[[Car1, Car2|CarRest],Cdr],BPos)|R] :-
		L=[token(cons,[Car1,clause([token(brackets_with_bar,
		[[Car2|CarRest],Cdr],nopos)])],BPos)|R].
	
	// cdr が一節だけならOK. TODO : 二節以上は構文エラー．
	ParseList3@@
	L=[token(brackets_with_bar,[[Car],[Cdr]],BPos)|R] :-
		L=[token(cons,[Car,Cdr],BPos)|R].
	
	ParseList4@@
	L=[token(brackets,[[C|CR]],BPos)|R] :-
		L=[token(brackets_with_bar,[[C|CR],[token(nil,[],nopos)]],BPos)|R].
	
	ParseList5@@
	L=[token(brackets,[[clause([])]],BPos)|R] :- L=[token(nil,[],BPos)|R].
	
	ParseList6@@
	L=[token(brackets,[[]],BPos)|R] :- L=[token(nil,[],BPos)|R].
	
},

// 中置記法関係演算子の処理
{

/* = */Parse_Equal@@
L=[token(equal,[],Pos)|R]:- L=[make_relop(normalfunc("=",2),Pos)|R].
/* == */Parse_EqualEqual@@
L=[token(equal_equal,[],Pos)|R]:-L=[make_relop(normalfunc("==",2),Pos)|R].
/* \= */Parse_BackslashEqual@@
L=[token(backslash_equal,[],Pos)|R]:- L=[make_relop(normalfunc("\=",2),Pos)|R].
/* =:= */Parse_EqualColonEqual@@
L=[token(equal_colon_equal,[],Pos)|R]:-L=[make_relop(normalfunc("=:=",2),Pos)|R].
/* =\= */Parse_EqualBackslashEqual@@
L=[token(equal_backslash_equal,[],Pos)|R]:- L=[make_relop(normalfunc("=\=",2),Pos)|R].
/* =:=. */Parse_EqualColonEqualDot@@
L=[token(equal_colon_equal_dot,[],Pos)|R]:- L=[make_relop(normalfunc("=:=.",2),Pos)|R].
/* =\=. */Parse_EqualBackslashEqualDot@@
L=[token(equal_backslash_equal_dot,[],Pos)|R]:- L=[make_relop(normalfunc("=\=.",2),Pos)|R].
/* != */Parse_ExclamationEqual@@
L=[token(exclamation_equal,[],Pos)|R]:-L=[make_relop(normalfunc("!=",2),Pos)|R].
/* >= */Parse_Geq@@
L=[token(geq,[],Pos)|R]:- L=[make_relop(normalfunc(">=",2),Pos)|R].
/* =< */Parse_Leq@@
L=[token(leq,[],Pos)|R]:- L=[make_relop(normalfunc("=<",2),Pos)|R].
/* >  */Parse_Grt@@
L=[token(grt,[],Pos)|R]:- L=[make_relop(normalfunc(">",2),Pos)|R].
/* <  */Parse_Les@@
L=[token(les,[],Pos)|R]:- L=[make_relop(normalfunc("<",2),Pos)|R].
/* >=. */Parse_GeqDot@@
L=[token(geq_dot,[],Pos)|R]:- L=[make_relop(normalfunc(">=.",2),Pos)|R].
/* =<. */Parse_LeqDot@@
L=[token(leq_dot,[],Pos)|R]:- L=[make_relop(normalfunc("=<.",2),Pos)|R].
/* >.  */Parse_GrtDot@@
L=[token(grt_dot,[],Pos)|R]:- L=[make_relop(normalfunc(">.",2),Pos)|R].
/* <.  */Parse_LesDot@@
L=[token(les_dot,[],Pos)|R]:- L=[make_relop(normalfunc("<.",2),Pos)|R].

	Parse_RelOp0@@
	L=[make_relop(Op,Pos)|R] :- 
		L=[before_relop([]),relop(Op,Pos),after_relop(P,P)|R].
	
	Parse_RelOp1@@
	L=[token(TK,TA,TP), before_relop(Rest)|R] :-
		L=[before_relop([token(TK,TA,TP)|Rest])|R].
	
	Parse_RelOp2@@
	L=[after_relop(H,T),token(TK,TA,TP)|R] :-
		L=[after_relop(H,RT)|R],T=[token(TK,TA,TP)|RT].
},

// 中置記法関係演算子の構成
{
	Parse_RelOp3@@
	L=[before_relop(B), relop(Op,Pos), after_relop(AH,AT)] :-
	L=[token(atom,[Op, [clause(B),clause(AH)]],Pos)], AT=[].
},

// 中置記法乗除演算子の処理

{
/* * */Parse_Asterisk@@
L=[token(asterisk,[],Pos)|R]:-L=[make_asmop(normalfunc("*",2),Pos)|R].
/* / */Parse_Slash@@
L=[token(slash,[],Pos)|R]:-L=[make_asmop(normalfunc("/",2),Pos)|R].
/* *. */Parse_AsteriskDot@@
L=[token(asterisk_dot,[],Pos)|R]:-L=[make_asmop(normalfunc("*.",2),Pos)|R].
/* /. */Parse_SlashDot@@
L=[token(slash_dot,[],Pos)|R]:-L=[make_asmop(normalfunc("/.",2),Pos)|R].
/* mod */Parse_Mod@@
L=[token(mod,[],Pos)|R]:-L=[make_asmop(normalfunc("mod",2),Pos)|R].

	Parse_AsmOp0@@
	L=[make_asmop(Op,Pos)|R]:-L=[before_asmop([]),asmop(Op,Pos),after_asmop(P,P)|R].
	
	Parse_AsmOp1@@
	L=[token(TK,TA,TP), before_asmop(Rest)|R] :-
		L=[before_asmop([token(TK,TA,TP)|Rest])|R].
	
	Parse_AsmOp2@@
	L=[after_asmop(H,T),token(TK,TA,TP)|R] :-
		L=[after_asmop(H,RT)|R],T=[token(TK,TA,TP)|RT].
},

// 中置記法乗除演算子の構成
{
	Parse_AsmOp3@@
	L=[before_asmop(B), asmop(Op,Pos), after_asmop(AH,AT)] :-
	L=[token(atom,[Op, [clause(B),clause(AH)]],Pos)], AT=[].
},

// 中置記法加減演算子の処理
{

/* + */Parse_Plus@@
L=[token(plus,[],Pos)|R]:-L=[make_pmop(normalfunc("+",2),Pos)|R].
/* - */Parse_Minus@@
L=[token(minus,[],Pos)|R]:-L=[make_pmop(normalfunc("-",2),Pos)|R].
/* +. */Parse_PlusDot@@
L=[token(plus_dot,[],Pos)|R]:-L=[make_pmop(normalfunc("+.",2),Pos)|R].
/* -. */Parse_MinusDot@@
L=[token(minus_dot,[],Pos)|R]:-L=[make_pmop(normalfunc("-.",2),Pos)|R].

	Parse_PmOp0@@
	L=[make_pmop(Op,Pos)|R]:-L=[before_pmop([]),pmop(Op,Pos),after_pmop(P,P)|R].
	
	Parse_PmOp1@@
	L=[token(TK,TA,TP), before_pmop(Rest)|R] :-
		L=[before_pmop([token(TK,TA,TP)|Rest])|R].
	
	Parse_PmOp2@@
	L=[after_pmop(H,T),token(TK,TA,TP)|R]:-
		L=[after_pmop(H,RT)|R],T=[token(TK,TA,TP)|RT].
},

// 中置記法加減演算子の構成
{
	Parse_PmOp3@@
	L=[before_pmop(B), pmop(Op,Pos), after_pmop(AH,AT)]:-
		L=[token(atom,[Op, [clause(B),clause(AH)]], Pos)], AT=[].
},

// 引数無しのアトム, リンク束，'.', '[]', $p, @p
{
	Parse_OneAtom@@
	L=[token(funcname,[AN],FPos)|R] :- L=[token(atom,[AN,[]],FPos)|R].
	
//	Parse_ArityAtom@@
//	L=[token(arityatom,[AN,P]|R] :- L=[token(atom,srcatom(AN,P)|R].
	
//	Parse_Link@@
//	L=[token(linkname,[LN],LPos)|R] :- L=[token(link,[LN],LPos)|R].
	
	Parse_Bundle@@
	L=[token(asterisk,[],APos), token(link,[LN],_GLPos)|R] :- L=[token(bundle,[LN],APos)|R].

// この処理はLMNParserにまわす。1引数とは限らないし、、、今は認めないので。
//	Parse_Aggregate@@
//	L=[srcatom(AN,[clause([srcbundle])])|R] :- L=[srcaggregate(AN,[clause([srcbundle])])|R].

	ParseCons@@
	L=token(cons,[Car, Cdr],CPos) :- L=token(atom,[normalfunc("."),[Car,Cdr]],CPos).
	
	ParseNil@@
	L=token(nil,[],NPos) :- L=token(atom,[normalfunc("[]"),[]],NPos).	
	
	ParseProccxt@@
	L=token(proccxtname,[PN],PPos):-L=token(proccxt,[PN,[],[fvs]],PPos).
	
	ParseRulecxt@@
	L=token(rulecxtname,[RN],RPos):-L=token(rulecxt,[RN],RPos).
},

// 節(要素が一つであること)、括弧、節、文を展開する
{
	Break_Clause@@
	L=[clause([S])|R] :- L=[S|R].

	Break_Sentence@@
	L=[sentence([S|SR])|R] :- L=[S|list.append(SR,R)].
	
	Break_Parens@@
	L=[token(parens,[[S|SR]],_GPPos)|R] :- L=[S|list.append(SR,R)].
	
	Break_Parens2@@
	L=[token(parens,[[]],_GPPos)|R] :- L=R.
},

//非token化
{
	L=token(atom,[F,Args],Pos):-L=srcatom(F,Args,Pos).
	L=token(linkname,[LN],LPos):-L=srclink(LN,LPos).
	L=token(rule,[Name,H,G,B],Pos):-L=srcrule(Name,H,G,B,Pos).
	L=token(braces,[Process|Attr],MPos):-L=srcmem(Process,Attr,MPos).
	L=token(proccxt,[Name,Car,Cdr],PPos):-L=srcproccxt(Name,Car,Cdr,PPos).
	L=token(rulecxt,[Name],RPos):-L=srcrulecxt(Name,RPos).
}]).

lmnparser.parsed({src=$srcTree, $s[]}/) :- ground($srcTree)|
	lmnparser.parsed($srcTree).
}.
