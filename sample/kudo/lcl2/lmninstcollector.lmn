{module(lmninstcollector).

	R=lmninstcollector.collect_insts({$g}) :-
	
		R=lmninstcollector.init({$g.

			rulename($rn) :- string($rn) | compiled_rule($rn, eoi), proceed, commit($rn), usable(v(0)).			

		}).
		
		R=lmninstcollector.init({$g,@g}/) :-
		R=lmninstcollector.collect_spec({$g.
		
			E=eoi, spec(F, L) :- E=[spec(F, L)|eoi].

		}).
		
		R=lmninstcollector.collect_spec({$g,@g}/) :-
		R=lmninstcollector.collect_find({$g.
		
			findatom($a, $m, F), usable($m1), E=eoi :- ground($a), $m1 = $m | E=[findatom($a, $m, F)|eoi], usable($m1), usable($a).
			anymem($m, $p, K), usable($p1), E=eoi :- ground($m), $p1 = $p | E=[anymem($m, $p, K)|eoi], usable($p1), usable($m).
			getlink($l, $a, P), usable($a1), E=eoi :- ground($l), $a1 = $a | E=[getlink($l, $a, P)|eoi], usable($a1), usable($l).
			isbuddy($l1, $l2,M), usable($lu1), usable($lu2), E=eoi :- $lu1 = $l1, $lu2 = $l2 | E=[isbuddy($l1, $l2,M)|eoi], usable($lu1), usable($lu2).
			neqatom($a1, $a2), usable($au1), usable($au2), E=eoi :- $a1 = $au1, $a2 = $au2 | E=[neqatom($a1,$a2)|eoi], usable($au1), usable($au2).

		}).
		
		R=lmninstcollector.collect_find({$g,@g}/) :-
		R=lmninstcollector.collect_find4({$g.
		
%			E=eoi, dereflink(A, L, P) :- E=[dereflink(A, L, P)|eoi].
%			E=eoi, func(A, F) :- E=[func(A,F)|eoi].
%			E=eoi, testmem(M, A) :- E=[testmem(M, A)|eoi].
%			E=eoi, eqatom(A1, A2) :- E=[eqatom(A1,A2)|eoi].

		}).
		
		R=lmninstcollector.collect_find4({$g,@g}/) :-
		R=lmninstcollector.collect_numcheck({$g.
		
			natoms(M, C), E=eoi :- E=[natoms(M, C)|eoi].
			nmems(M, C), E=eoi :- E=[nmems(M, C)|eoi].
			norules(M), E=eoi :- E=[norules(M)|eoi].
			nfreelinks(M, C), E=eoi :- E=[nfreelinks(M, C)|eoi].

		}).
		
		R=lmninstcollector.collect_numcheck({$g,@g}/) :-
		R=lmninstcollector.collect_stable({$g.
		
			E=eoi, stable(M) :- E=[stable(M)|eoi].

		}).
		
		R=lmninstcollector.collect_stable({$g,@g}/) :-
		R=lmninstcollector.collect_commit({$g.
		
			E=eoi, commit(C) :- E=[commit(C)|eoi].

		}).
		
		R=lmninstcollector.collect_commit({$g,@g}/) :-
		R=lmninstcollector.collect_dequeue({$g.
		
			dequeueatom(A), E=eoi :- E=[dequeueatom(A)|eoi].
		}).
		
		R=lmninstcollector.collect_dequeue({$g,@g}/) :-
		R=lmninstcollector.collect_remove({$g.

			E=eoi, removeatom(A, M, F) :- E=[removeatom(A, M, F)|eoi].
			E=eoi, removemem(M, P) :- E=[removemem(M, P)|eoi].
		
		}).
		
		R=lmninstcollector.collect_remove({$g,@g}/) :-
		R=lmninstcollector.collect_insertconnectors({$g.

			E=eoi, insertconnectors($cs, LL, M) :- ground($cs) | E=[insertconnectors($cs, LL, M)|eoi], usable($cs).
%			E=eoi, removemem(M, P) :- E=[removemem(M, P)|eoi].
		
		}).
		
		R=lmninstcollector.collect_insertconnectors({$g,@g}/) :-
		R=lmninstcollector.collect_make({$g.

			newatom($a, $m, F), usable($m1), E=eoi :- ground($a), $m1 = $m | E=[newatom($a, $m, F)|eoi], usable($m1), usable($a).
			newmem($m, $p, S), usable($p1), E=eoi :- ground($m), $p = $p1 | E=[newmem($m, $p, S)|eoi], usable($p1), usable($m).
			alloclink($l, $a, P), usable($a1), E=eoi :- ground($l), $a1 = $a | E=[alloclink($l, $a, P)|eoi], usable($a1), usable($l).
			// TODO 今は本膜からだけにしか対応していない
			unifylinks($l1, $l2, v(0)), usable($lu1), usable($lu2), E=eoi :-
				$l1 = $lu1, $l2 = $lu2 |
				E=[unifylinks($l1, $l2, v(0))|eoi], usable($lu1), usable($lu2).
			loadruleset($m, RID), usable($m1), E=eoi :- $m1 = $m | E=[loadruleset($m, RID)|eoi], usable($m1).
			copyrules($m1, $m2), usable($mu1), usable($mu2), E=eoi :- $mu1 = $m1, $mu2 = $m2 | 
				E=[copyrules($m1, $m2)|eoi], usable($mu1), usable($mu2).
			copycells($cmap, $m1, $m2), usable($mu1), usable($mu2), E=eoi :- ground($cmap), $mu1 = $m1, $mu2 = $m2 | 
				E=[copycells($cmap, $m1, $m2)|eoi], usable($mu1), usable($mu2), usable($cmap).
		}).
		
		R=lmninstcollector.collect_make({$g,@g}/) :-
		R=lmninstcollector.collect_deleteconnectors({$g.

			E=eoi, deleteconnectors(CS, CM, M) :- E=[deleteconnectors(CS, CM, M)|eoi].
%			E=eoi, enqueuemem(M) :- E=[enqueuemem(M)|eoi].
		
		}).
		
		R=lmninstcollector.collect_deleteconnectors({$g,@g}/) :-
		R=lmninstcollector.collect_enqueue({$g.

			E=eoi, enqueueatom(A) :- E=[enqueueatom(A)|eoi].
			E=eoi, enqueuemem(M) :- E=[enqueuemem(M)|eoi].
		
		}).
		
		R=lmninstcollector.collect_enqueue({$g,@g}/) :-
		R=lmninstcollector.collect_drop({$g.

			E=eoi, dropmem(M) :- E=[dropmem(M)|eoi].
		
		}).
		
		R=lmninstcollector.collect_drop({$g,@g}/) :-
		R=lmninstcollector.collect_free({$g.

			E=eoi, freeatom(A) :- E=[freeatom(A)|eoi].
			E=eoi, freemem(M) :- E=[freemem(M)|eoi].
		
		}).
		
		R=lmninstcollector.collect_free({$g,@g}/) :-
		R=lmninstcollector.collect_proceed({$g.

			E=eoi, proceed :- E=[proceed|eoi].
		
		}).
		
		R=lmninstcollector.collect_proceed({$g,@g}/) :-
		R=lmninstcollector.last_phase({$g.
		
			E=eoi :- E=[].
		
			compiled_rule(RN, Insts) :- compiled_rule(RN,
				[spec(2,2)],Insts,none,none). % 膜主導テスト命令列として返す
		
		}).
		
	R=lmninstcollector.last_phase({$g, @g}/) :-
		R=insts_collected({$g}).
	
}.