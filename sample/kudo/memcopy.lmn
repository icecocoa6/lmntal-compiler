% 「非線形プロセス文脈with非明示自由リンク」の代わりをinlineで書いてみる by kudo
%
% 非線形プロセス文脈with非明示自由リンク:
% {$p[|*Z]} :- {$p[|*Z1]},{$p[|*Z2]}, *Z=*Z1, *copy(*Z2)
%
% とりあえず仕様としては，
% R=mem.copy(M), {$p[M|*Z]}
% ->
% R=copied(M,M'), {$p[M|*Z]}, {$p[M'|*Z']}, *nil(*Z')
% という感じでやってみる
% ...nilでいいのか?
%
%
% (1)
% ret = mem.copy({test})
% ->
% ret = copied({test},{test}) 
%
% (2)
% ret = mem.copy(M), M={a(A)},b(A)
% ->
% ret = copied(M1,M2),M1={a(A1)},b(A1), M2={a(A2)}, nil(A2)
%
% (3)
% ret1 = mem.copy(M1), ret2 = mem.copy(M2), {'+'(M1), '+'(M2), hello}
% ->
% ret1 = copied(M11,M12), ret2 = mem.copy(M2), {'+'(M11), '+'(M2), hello},
%                                              {'+'(M12), '+'(NIL_1), hello}, nil(NIL_1)
% ->
% ret1 = copied(M11,M12), ret2 = mem.copied(M21,M22),
%                                              {'+'(M11), '+'(M21), hello},
%                                              {'+'(M12), '+'(NIL_1), hello}, nil(NIL_1),
%                                              {'+'(M22), '+'(NIL_2), hello}, nil(NIL_2)
%
% (4)
% mem.copy({a(A)}) = mem.copy({b(A)})
% ->
% copied({a(A)},{a(NIL_1)}) = mem.copy({b(A)}), nil(NIL_1)
% ->
% copied({a(A)},{a(NIL_1)}) = copied({b(A)},{b(NIL_2)}), nil(NIL_1), nil(NIL_2)
%

% とりあえずこの三つのケースはうまくいった
%ret = memcopy({}).
%ret = memcopy({a,{}}).
%ret = memcopy({a(A)}),b(A).

% TODO モジュル化

  R=memcopy(M) :-
  R=[:/*inline*/
  	Atom osp = me.nthAtom(0);
  	if(!osp.getFunctor().equals(Functor.OUTSIDE_PROXY)){ // 子膜に繋がっていない
  		Atom er = mem.newAtom(new Functor("copy_error",1));
  		mem.relink(er, 0, me, 1);
  		mem.removeAtom(me.nthAtom(0));
  		mem.removeAtom(me);
  	}
  	else{
  		Atom isp = osp.nthAtom(0);
  		AbstractMembrane origmem = isp.getMem();
  		origmem.recursiveLock();
  		AbstractMembrane targmem = mem.newMem();
  		Map origToTarg = targmem.copyCellsFrom(origmem);
  		Atom newisp = (Atom)origToTarg.get(isp);
  		Atom newosp = mem.newAtom(Functor.OUTSIDE_PROXY);
  		mem.newLink(newisp, 0, newosp, 0);
  		Iterator it = origmem.atomIteratorOfFunctor(Functor.INSIDE_PROXY);
  		while(it.hasNext()){
  			Atom origisp = (Atom)it.next();
  			if(origisp == isp)continue;
  			Atom targisp = (Atom)origToTarg.get(origisp);
  			Atom targosp = mem.newAtom(Functor.OUTSIDE_PROXY);
  			mem.newLink(targisp, 0, targosp, 0);
  			Atom nil = mem.newAtom(new Functor("nil",1));
  			mem.newLink(targosp, 1, nil, 0);
  		}
  		origmem.recursiveUnlock();
  		Atom copied = mem.newAtom(new Functor("copied",3));
  		mem.relink(copied, 2, me,1);
  		mem.relink(copied, 0, me,0);
  		mem.newLink(newosp,1,copied,1);
  		mem.removeAtom(me);
  	}
  :](M).