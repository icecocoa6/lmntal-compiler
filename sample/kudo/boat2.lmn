% 改良版 狼と羊とキャベツの問題 by kudo
% 
% 問題は一緒. 
% 複製ルールを少し頭よくした. 一度でやり, 多少失敗を避ける. 相当効率は上がった. 
% あと, データ表現を少し変えた. 膜は手順の記録のみ(それも膜いらないか). 
%
% state(1,[[w,w],[g],[c]],[[],[],[c]],[g,c],15,{move(0,[g,g]),move[1,[]),,,,,,})
% 引数1 : ボートの残り席数
%     2 : ボートがある岸の様子
%     3 : ボートのない岸の様子
%     4 : ボートの様子
%     5 : 今何手目か
%     6 : これまでの手順が入った膜
%
% 狼, 羊, キャベツがそれぞれ沢山ある場合にも対応. ボートの席も複数あって良い. 
%
% ただし, 解けない問題に対して無限ループ. stageアトムのせい. changedみたいなアトムを用意すべきか. 
% でもstageに上限をつけることで, 何手以内でなければ諦める, という書き方になる
%
% 問題の形式:
% full = [W,G,C]   フルメンバー. 此岸の初期状態であり, 対岸の最終状態.
%         W      = 狼の数だけ w の入ったリスト
%           G    = 羊の数だけ g の入ったリスト
%             C  = キャベツの数だけ c の入ったリスト
% boat = ボートの席の数

% 7手
full = [[w],[g],[c]].
boat = 1.

%% 1手 (ボートの上で食い合う気がする)
%full = [[w],[g],[c]].
%boat = 3.

%% 7手
%full = [[w,w,w],[g,g],[c]].
%boat = 2.

%% 19手 (農夫が食われる気がする)
%full = [[w,w,w,w,w,w,w,w,w,w],[],[]].
%boat = 1.

%% 3手
%full = [[w],[g,g,g,g,g],[c]].
%boat = 5.

start.

%幅優先にする為の変数.
stage(0).

%初期状態生成
start,full=F,boat=B :- int(B),ground(F) | un , unsaved_state(B,F,[[],[],[]],[],left,0,{}),full=F,boat=B.

%正解判定(もっとも優先される必要がある)
un,state(B,[[],[],[]],OS,[],left,N,movin(M)),full = F :- OS=F,int(B),int(N) | solution=M.


%狼が羊を食べる,キャベツが羊を食べる(下の二つのルールより優先される必要がある)
un,unsaved_state(B,S,[[w|W],[g|G],   C ],[],BS,N,{$m[]}) :- ground(S),ground(W),ground(G),ground(C),int(B),int(N),unary(BS) | un.
un,unsaved_state(B,S,[   W ,[g|G],[c|C]],[],BS,N,{$m[]}) :- ground(S),ground(W),ground(G),ground(C),int(B),int(N),unary(BS) | un.

%過去に辿った状態の排除(下のルールより優先される必要がある)
un,unsaved_state(B,S,OS,[],BS,N,{$m[]}),saved(BSS,SS,OSS,NS) :- int(B),unary(BS),BS=BSS,int(N),N>=NS,S=SS,OS=OSS |
un,                                     saved(BSS,SS,OSS,NS).

%過去に辿ってない状態の保存
un,unsaved_state(B,S,OS,[],BS,N,M) :- ground(S),ground(OS),unary(BS),int(N) |
un,        state(B,S,OS,[],BS,N,M), saved(BS,S,OS,N).


%以下複製ルール. 次の5つしかない筈. ボートの空席が埋まるまで繰り返す筈.

%狼と羊がいる -> 狼を乗せるか, 羊を乗せる
un,state(B  ,[[w|W],[g|G],C],OS,   BOAT ,BS,N,{$m[]}) :- B>0,unary(BS),ground(W),ground(G),ground(C),ground(OS),ground(BOAT),int(N) |
un,state(B-1,[   W ,[g|G],C],OS,[w|BOAT],BS,N,{$m[]}),
   state(B-1,[[w|W],   G ,C],OS,[g|BOAT],BS,N,{$m[]}).

%羊とキャベツがいる -> 羊を乗せるか, キャベツを乗せる
un,state(B  ,[W,[g|G],[c|C]],OS,   BOAT ,BS,N,{$m[]}) :- B>0,unary(BS),ground(W),ground(G),ground(C),ground(OS),ground(BOAT),int(N) |
un,state(B-1,[W,   G ,[c|C]],OS,[g|BOAT],BS,N,{$m[]}),
   state(B-1,[W,[g|G],   C ],OS,[c|BOAT],BS,N,{$m[]}).

%狼がいるが羊がいない -> 狼を乗せるか, 何も乗せない
un,state(B  ,[[w|W],[],C],OS,   BOAT ,BS,N,{$m[]}) :- B>0,unary(BS),ground(W),ground(C),ground(OS),ground(BOAT),int(N) |
un,state(B-1,[   W ,[],C],OS,[w|BOAT],BS,N,{$m[]}),
   state(B-1,[[w|W],[],C],OS,   BOAT ,BS,N,{$m[]}).

%キャベツはいるが羊がいない -> キャベツを乗せるか, 何も乗せない
un,state(B  ,[W,[],[c|C]],OS,   BOAT ,BS,N,{$m[]}) :- B>0,unary(BS),ground(W),ground(C),ground(OS),ground(BOAT),int(N) |
un,state(B-1,[W,[],   C ],OS,[c|BOAT],BS,N,{$m[]}),
   state(B-1,[W,[],[c|C]],OS,   BOAT ,BS,N,{$m[]}).

%羊しかいない -> 羊を乗せるか, 何も乗せない
un,state(B  ,[[],[g|G],[]],OS,   BOAT ,BS,N,{$m[]}) :- B>0,unary(BS),ground(G),ground(OS),ground(BOAT),int(N)|
un,state(B-1,[[],   G ,[]],OS,[g|BOAT],BS,N,{$m[]}),
   state(B-1,[[],[g|G],[]],OS,   BOAT ,BS,N,{$m[]}).

%幅優先探索にすべく, NがSTAGEと一致しないとボートが動かない
un,stage(STAGE),state(0,S,OS,BOAT,BS,N,{$m[]}) :- N=STAGE,ground(BOAT)|un,stage(STAGE),state(0,S,OS,BOAT,BS,N,movin({move(N,BOAT),$m[]})).

%対岸に移動
un,state(0,S,[W,G,C],[w|BOAT],BS,N,movin(M)) :- un,state(0,S,[[w|W],G,C],BOAT,BS,N,movin(M)).
un,state(0,S,[W,G,C],[g|BOAT],BS,N,movin(M)) :- un,state(0,S,[W,[g|G],C],BOAT,BS,N,movin(M)).
un,state(0,S,[W,G,C],[c|BOAT],BS,N,movin(M)) :- un,state(0,S,[W,G,[c|C]],BOAT,BS,N,movin(M)).

%1手終了
un,boat(B),state(0,S,OS,[],left ,N,movin(M)) :-int(N),int(B) | un,boat(B),unsaved_state(B,OS,S,[],right,N+1,M).
un,boat(B),state(0,S,OS,[],right,N,movin(M)) :-int(N),int(B) | un,boat(B),unsaved_state(B,OS,S,[],left ,N+1,M).

%STAGEを一つ進める(探索中では一番優先されないルール)
un,stage(STAGE) :- un,stage(STAGE+1).

%以下の5ルールは, 解けた際に余計なものを防ぐ為に削除するルール(もっとも優先されないルール).(コメントアウト可)
solution=SL,state(B,S,OS,BOAT,BS,N,movin({$m[]})) :- int(B),ground(S),ground(OS),ground(BOAT),unary(BS),int(N)| solution=SL.
solution=SL,state(B,S,OS,BOAT,BS,N,{$m[]}) :- int(B),ground(S),ground(OS),ground(BOAT),unary(BS),int(N)| solution=SL.
solution=SL,saved(BSS,SS,OSS,NS) :- unary(BSS),ground(SS),ground(OSS),int(NS) | solution=SL.
solution=SL,stage=ST,boat=B :- int(ST),int(B) | solution=SL.
solution={$s[]} :- $s[].
