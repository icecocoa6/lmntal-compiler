init({
	/* ノード生成 */
	startpoint(32).
	makep(94).
	makep(X), startpoint(ST) :- X=\=ST, X>0 | startpoint(ST), makep(X-1), p(X, {}, 100000).
	makep(X), startpoint(ST) :- X==ST       | startpoint(ST), makep(X-1), p(ST, {}, 0).
	makep(0) :-.
	
	
	/* リンクをファイルから読出し */
	r(0)=io.fileReader([:testfile2:]).
	r(X,O) :- class(O,"java.io.BufferedReader"),X<135 | r(X+1,O), readline(O).
	
	readline(Object) :- class(Object, "java.io.BufferedReader") |
		[:/*inline*/
			try {
				java.io.BufferedReader br = (java.io.BufferedReader) ((ObjectFunctor)me.nthAtom(0).getFunctor()).getObject();
				String s = br.readLine();
			 	String r[] = s.split(" ");
	  			Atom e = mem.newAtom(new Functor("e", 3));
				Atom result1 = mem.newAtom(new IntegerFunctor(Integer.parseInt(r[1])));
				Atom result2 = mem.newAtom(new IntegerFunctor(Integer.parseInt(r[2])));
				Atom result3 = mem.newAtom(new IntegerFunctor(Integer.parseInt(r[3])));
	
				mem.newLink(e, 0, result1, 0);
				mem.newLink(e, 1, result2, 0);
				mem.newLink(e, 2, result3, 0);
				
				me.nthAtom(0).remove();
				me.remove();
			} catch(Exception e) {Env.e(e);}
		:](Object).
	
	/* ノードとリンクをつなぐ */
	p(X1, {$p}, W), e(X2,Y2,Z) :- X1==X2 | p(X1, {+(X), $p}, W), e(X,Y2,Z).
	p(Y1, {$p}, W), e(X2,Y2,Z) :- Y1==Y2 | p(Y1, {+(Y), $p}, W), e(X2,Y,Z).
	%p(X1, {$p}), p(Y1, {$q}), e(X2,Y2) :- X1==X2, Y1==Y2 | p(X1, {+(X), $p}), p(Y1, {+(Y), $q}), e(X,Y).
}).

shr({
	p(X, {$p}, W) :- int(X), int(W) | {w(X,W), $p}.
}).


/* Moore-Bellman-Fordのアルゴリズムによる最短経路探索 */
mbf({
	go :- started.
	started, e(V1, V2, Weight), {+(V1), w(X1, PoA), $p1}, {+(V2), w(X2, PoB), $p2}
		:- PoA + Weight < PoB, int(X1), int(X2) |
			started, e(V1, V2, Weight), {+(V1), w(X1, PoA), $p1}, {+(V2), w(X2, PoA+Weight), $p2}.
	started, e(V2, V1, Weight), {+(V1), w(X1, PoA), $p1}, {+(V2), w(X2, PoB), $p2}
		:- PoA + Weight < PoB, int(X1), int(X2) |
			started, e(V1, V2, Weight), {+(V1), w(X1, PoA), $p1}, {+(V2), w(X2, PoA+Weight), $p2}.
%	e(V1, V2, Weight), p(X1, {+(V1), $p1}, PoA), p(X2, {+(V2), $p2}, PoB)
%		:- PoA + Weight < PoB, int(X1), int(X2) |
%			e(V1, V2, Weight), p(X1, {+(V1), $p1}, PoA), p(X2, {+(V2), $p2}, PoA+Weight).
	/* 有向グラフの場合、コメントアウト */
%	e(V2, V1, Weight), p(X1, {+(V1), $p1}, PoA), p(X2, {+(V2), $p2}, PoB)
%		:- PoA + Weight < PoB, int(X1), int(X2) |
%			e(V1, V2, Weight), p(X1, {+(V1), $p1}, PoA), p(X2, {+(V2), $p2}, PoA+Weight).
}).

init({$p, @p}/), shr({@q}) :- shrink({$p,@p,@q}).
shrink({$p, @p}/), mbf({@q}) :- timer:benchmark(X,"Elapsed Time"), search({+(X),$p,@p,@q}).