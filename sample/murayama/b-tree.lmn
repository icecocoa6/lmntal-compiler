% B木の根
root({r=[0],num(1),leaf}). 
    
% レコード内をsort
{R=[H1, H2 | B],$p[R,B|*Z]}
	:- H1>H2 | {R=[H2, H1 | B],$p[R,B|*Z]}.

% レコードの分割
root({num(5),$p}) :- \+($p=(+(A),$q)) | root({r=[+(T2)],num(0)}).
{num(5),$p} :- \+($p=(+(A),$q)) | {num(5),$p,+(T2)},{r=[+(T2)],num(0)}.
{R=[+(T2)|B2],$q[R,B2|*Z],num(N)},
{leaf,+(T2),r=[H1,H2,H3 | B1],num(5),$p}
	:- ground(B1) ,int(H1),int(H2),int(H3),int(N)
	| {R=[+(T1),H3,+(T2)|B2],$q[R,B2|*Z],num(N+1),$p}
	  {leaf,+(T1),r=[H1,H2],num(2)},
	  {leaf,+(T2),r(B1),num(2)}.
{R=[+(T2)|B2],$q[R,B2|*Z],num(N)},
{+(T2),r=[+(T3),H1,+(T4),H2,+(T5),H3 | B1],num(5),$p[B1|*Z2]}
	:- int(H1),int(H2),int(H3),int(N)
	| {R=[+(T1),H3,+(T2)|B2],$q[R,B2|*Z],num(N+1)}
	  {+(T1),r=[+(T3),H1,+(T4),H2,+(T5)],num(2)},
	  {+(T2),r(B1),num(2),$p[B1|*Z2]}.

% レコードに値を追加
{leaf,spread(H,ins),$p} :- int(H)|{leaf,ins(H),$p}.
{leaf,R=[H1|B1],num(N),ins(H3),$p[R,B1|*Z]},
    :- int(N),int(H1),int(H3)
    | {leaf,R=[H3,H1 | B1],num(N+1),$p[R,B1|*Z]}. 

% レコード内を検索
search([H|B],X) :- int(X),int(H),ground(B),X=H | found(X).
search([H|B],X) :- int(X),int(H),X=\=H | search(B,X).
search([],X) :- int(X) | notfound(X).
{leaf,spread(H,search),$p} :- int(H)|{leaf,search(H),$p}.
{leaf,search(H),r=List,$p}
	:- int(H),ground(List) | {leaf,r=List,$p},search(List,H).

% 値を子ノードに渡す
% ルールが３つに分割されてしまうのが気持ち悪い。
% レコードの左端と右端に-∞と+∞を置くべき？
% case 左端
{r=[+(T),H2 | B1],spread(H3,F) ,$p[B1|*Z]},{+(T),$q}
	:- H3<H2,unary(F)
	| {r=[+(T),H2 | B1],$p[B1|*Z]},
	  {+(T),spread(H3,F),$q}.
% case 真ん中
{R=[H1,+(T),H3 | B1],spread(H2,F) ,$p[R,B1|*Z]},{+(T),$q}
	:- H1<H2,H2<H3,unary(F)
	| {R=[H1,+(T),H3 | B1],$p[R,B1|*Z]},
	  {+(T),spread(H2,F),$q}.
% case 右端
{R=[H1,+(T)],spread(H3,F) ,$p[R|*Z]},{+(T),$q}
	:- H1<H3,unary(F)
	| {R=[H1,+(T)],$p[R|*Z]},
	  {+(T),spread(H3,F),$q}.

% rootに次々と値を代入する
%create([9,15,20,81,16,31,53,12,28,63,26,52,18,24,25,36,27,65,61]).
create([9,15,20,81,16,31,53]).
create([]) :-.
root({$p}),create([H|B]) :- int(H) | root({spread(H,ins),$p}),create(B).

% B木内を検索
search([16,28]).
search([]) :-.
root({$p}),search([H|B]) :- int(H) | root({spread(H,search),$p}),search(B).