{
module(thread).

	{
		system_ruleset.
		{thread(N,{$p,@p}), $q,@q}/ :- int(N) | {$p,$q,@q}.
	}.
	/*
		thread.create(N).
		Create N threads.
	*/
	thread.create(N) :- N>0 | thread.num(N), thread.cre(N).
	thread.cre(N) :- N>0 | thread.cre(N-1), thread(N,{}@"localhost").
	thread.cre(0) :-.

	/*
		thread.at(N, {atoms or rules}).
		Create atoms or rules at a thread numbered N.
	*/
	thread.at(N,{$p,@p}), thread(M,{$q,@q}) :- int(N),int(M), M=:=(N+1) |
		thread(N+1,{$p,$q,@p,@q}).
		
	
	/*
		thread.any({atoms or rules}).
		Create atoms or rules at a thread randomly selected.
	*/
	thread.any({$p,@p}), thread(M,{$q,@q}@T) :- int(M) |
		thread(M, {$p,$q,@p,@q}@T).

	/*
		thread.all({atoms or rules}).
		Create atoms or rules at all threads.
	*/
	thread.all({$p,@p}), thread.num(N) :- int(N) |
		thread.allcre(N, {$p,@p}), thread.num(N).
	thread.allcre(N, {$p[],@p}), thread(M,{$q,@q}@T) :- M>0, N>0, M=:=N |
		thread.allcre(N-1, {$p[],@p}), thread(M,{$p[],$q,@p,@q}@T).
	thread.allcre(0,{$p[],@p}):-.
}.

init({
	thread.create(3).

	/* ノードをファイルから読出し */
	rd(0)=io.fileReader([:testfile3:]).
	rd(X,O) :- class(O,"java.io.BufferedReader"),X<94 | rd(X+1,O), readnode(O).
	
	readnode(Object) :- class(Object, "java.io.BufferedReader") |
		[:/*inline*/
			try {
				java.io.BufferedReader br = (java.io.BufferedReader) ((ObjectFunctor)me.nthAtom(0).getFunctor()).getObject();
				String s = br.readLine();
			 	String r[] = s.split(" ");
	  			Atom e = mem.newAtom(new Functor("p", 2));
				Atom result1 = mem.newAtom(new IntegerFunctor(Integer.parseInt(r[0])));
				Atom result2 = mem.newAtom(new IntegerFunctor(Integer.parseInt(r[1])));
	
				mem.newLink(e, 0, result1, 0);
				mem.newLink(e, 1, result2, 0);
				
				me.nthAtom(0).remove();
				me.remove();
			} catch(Exception e) {Env.e(e);}
		:](Object).
	p(32,Y1), p(X1,Y2), e(32, X2, Weight, Thread)
		:-  int(Y1), int(Y2), int(X1), int(Weight), int(X2), X1==X2 |
			p(32,Y1), p(X1, {}, Weight, Y2), e(32, X2, Weight, Thread), put.
	p(32,Y1), p(X1,Y2), e(X2, 32, Weight, Thread)
		:-  int(Y1), int(Y2), int(X1), int(Weight), int(X2), X1==X2 |
			p(32,Y1), p(X1, {}, Weight, Y2), e(32, X2, Weight, Thread), put.
	put, put, put :- ok.
	ok, p(32,Y) :- int(Y) | ok, p(32, {}, 0, Y).
	ok, p(X,Y) :- int(X), int(Y), X=\=32 | ok, p(X, {}, 100000, Y).
	
	/* リンクをファイルから読出し */
	r(0)=io.fileReader([:testfile2:]).
	r(X,O) :- class(O,"java.io.BufferedReader"),X<135 | r(X+1,O), readlink(O).
	
	readlink(Object) :- class(Object, "java.io.BufferedReader") |
		[:/*inline*/
			try {
				java.io.BufferedReader br = (java.io.BufferedReader) ((ObjectFunctor)me.nthAtom(0).getFunctor()).getObject();
				String s = br.readLine();
			 	String r[] = s.split(" ");
	  			Atom e = mem.newAtom(new Functor("e", 4));
				Atom result1 = mem.newAtom(new IntegerFunctor(Integer.parseInt(r[1])));
				Atom result2 = mem.newAtom(new IntegerFunctor(Integer.parseInt(r[2])));
				Atom result3 = mem.newAtom(new IntegerFunctor(Integer.parseInt(r[3])));
				Atom result4 = mem.newAtom(new IntegerFunctor(Integer.parseInt(r[4])));
	
				mem.newLink(e, 0, result1, 0);
				mem.newLink(e, 1, result2, 0);
				mem.newLink(e, 2, result3, 0);
				mem.newLink(e, 3, result4, 0);
				
				me.nthAtom(0).remove();
				me.remove();
			} catch(Exception e) {Env.e(e);}
		:](Object).
	
	/* ノードとリンクをつなぐ */
	p(X1, {$p}, W, Thread1), e(X2,Y2,Z, Thread2)
		:- X1==X2, int(Thread1), int(Thread2) |
			p(X1, {+(X), $p}, W, Thread1), e(X,Y2,Z, Thread2).
	p(Y1, {$p}, W, Thread1), e(X2,Y2,Z, Thread2)
		:- Y1==Y2, int(Thread1), int(Thread2) |
			p(Y1, {+(Y), $p}, W, Thread1), e(X2,Y,Z, Thread2).
}).

/* スレッド割り当て */
scatter({
	p(X, {$p}, Weight, Thread) :- int(X), int(Weight), Thread=\=100 |
		thread.at(Thread, {{$p, w(X, Weight)}}).
	e(X,Y,Weight,Thread) :- int(Weight), Thread=\=100 |
		thread.at(Thread, {e(X,Y,Weight)}).
}).

/* Moore-Bellman-Fordのアルゴリズムによる最短経路探索 */
mbf({
	go :-
		started,
		thread.all({
			e(V1, V2, Weight), {+(V1), w(X1, PoA), $p1}, {+(V2), w(X2, PoB), $p2}
				:- PoA + Weight < PoB, int(X1), int(X2) |
					e(V1, V2, Weight), {+(V1), w(X1, PoA), $p1}, {+(V2), w(X2, PoA+Weight), $p2}.
			e(V2, V1, Weight), {+(V1), w(X1, PoA), $p1}, {+(V2), w(X2, PoB), $p2}
				:- PoA + Weight < PoB, int(X1), int(X2) |
					e(V1, V2, Weight), {+(V1), w(X1, PoA), $p1}, {+(V2), w(X2, PoA+Weight), $p2}.
					}).


 	started
 	, thread(X,{e(V1, V2, Weight), {+(V1), w(X1, PoA), $p1}, $p, @p})
 	, thread(Y, {{+(V2), w(X2, PoB), $p2}, $q, @q})
 		:- int(X), int(Y), PoA + Weight < PoB, int(X1), int(X2) |
 			started
 			, thread(X,{e(V1, V2, Weight), {+(V1), w(X1, PoA), $p1}, $p, @p})
 			, thread(Y,{{+(V2), w(X2, PoA+Weight), $p2}, $q, @q}).
 	started
 	, thread(X,{{+(V1), w(X1, PoA), $p1}, $p, @p})
 	, thread(Y, {e(V1, V2, Weight), {+(V2), w(X2, PoB), $p2}, $q, @q})
 		:- int(X), int(Y), PoA + Weight < PoB, int(X1), int(X2) |
 			started
 			, thread(X,{{+(V1), w(X1, PoA), $p1}, $p, @p})
 			, thread(Y,{e(V1, V2, Weight), {+(V2), w(X2, PoA+Weight), $p2}, $q, @q}).

 	started
 	, thread(X,{e(V2, V1, Weight), {+(V1), w(X1, PoA), $p1}, $p, @p})
 	, thread(Y, {{+(V2), w(X2, PoB), $p2}, $q, @q})
 		:- int(X), int(Y), PoA + Weight < PoB, int(X1), int(X2) |
 			started
 			, thread(X,{e(V1, V2, Weight), {+(V1), w(X1, PoA), $p1}, $p, @p})
 			, thread(Y,{{+(V2), w(X2, PoA+Weight), $p2}, $q, @q}).
 	started
 	, thread(X,{{+(V1), w(X1, PoA), $p1}, $p, @p})
 	, thread(Y, {e(V2, V1, Weight), {+(V2), w(X2, PoB), $p2}, $q, @q})
 		:- int(X), int(Y), PoA + Weight < PoB, int(X1), int(X2) |
 			started
 			, thread(X,{{+(V1), w(X1, PoA), $p1}, $p, @p})
 			, thread(Y,{e(V1, V2, Weight), {+(V2), w(X2, PoA+Weight), $p2}, $q, @q}).
}).

init({$p, @p}/), scatter({@q}) :- scattering({$p,@p,@q}).
scattering({$p, @p}/), mbf({@q}) :- timer:benchmark(X,"Elapsed Time"), mbfing({+(X),$p,@p,@q}).
