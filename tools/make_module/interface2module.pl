#!/usr/bin/perl

# java の型 => Functor
%functors = (
	"int"				=> "IntegerFunctor",
	"long"				=> "IntegerFunctor",
	"float"				=> "FloatingFunctor",
	"double"			=> "FloatingFunctor",
	"java.lang.String"	=> "StringFunctor",
);

%getmethods = (
	"IntegerFunctor"	=> "intValue()",
	"IntegerFunctor"	=> "intValue()",
	"FloatingFunctor"	=> "floatValue()",
	"FloatingFunctor"	=> "floatValue()",
	"StringFunctor"		=> "stringValue()",
);

#モジュールを生成するディレクトリ
$dir=".";

#オプション解析
use Getopt::Std;
my $opt = {}; 
getopts('d:h',$opt);
if ($opt->{'d'}) {
	$dir=$opt->{'d'};
}
#ディレクトリが存在するかどうかチェック
if (!-d $dir) {
	die "$0: Directory '$dir' is not found.\n";
}
#クラスが指定されないか、-hオプションのときは使い方を表示する
if ($opt->{'h'} || $#ARGV == -1) {
	print STDERR "Usage: $0 [options] <classes>\n";
	print STDERR "\n";
	print STDERR "\t-d <dir>\tSet output directory\n";
	exit(0);
}

for ($i = 0; $i <= $#ARGV; $i++) {
	$class = $ARGV[$i];
	open(CLASS, "javap -public $class |");
	while (<CLASS>) {
		if (/interface ([\w.]+)\.(\w+)/) {
			$class = $2;
			$absolute_class = $module = "$1.$2";
			$module =~ tr/./_/;
			printf STDERR "%-73s[%3d%%]\n", "$dir/$module.lmn", 100*($i+1)/($#ARGV+1);
			open(STDOUT, ">$dir/$module.lmn");
			print "//---------------------------------------------------------\n";
			print "// The following code was generated by interface2module.pl\n";
			print "// " . localtime(time) . "\n";
			print "//---------------------------------------------------------\n";
			print "{module($module).\n";
			print "[:/*inline_define*/\n";
			print "class LMNtal$class implements $absolute_class {\n";
			print "\tprivate Membrane mem;\n";
			print "\tpublic LMNtal$class(Membrane mem) {\n";
			print "\t\tthis.mem = mem;\n";
			print "\t}\n";
		} elsif (/public abstract ([\w.]+) (\S+)\((.*)\)/) {
			dump_method($1, $2, $3);
		}
	}
	close(CLASS);
	
	print "}\n";
	print ":].\n";
	print "\n";
	print "H=$module.new :- H=[:/*inline*/\n";
	print "\tAtom o = mem.newAtom(new ObjectFunctor(new LMNtal$class(mem)));\n";
	print "\tmem.relink(o, 0, me, 0);\n";
	print "\tme.remove();\n";
	print "\t:].\n";
	print "\n";

	print "H=$module.new({\$p,\@p}) :- H=[:/*inline*/\n";
	print "\tMembrane m = me.nthAtom(0).nthAtom(0).getMem();\n";
	print "\tAtom o = mem.newAtom(new ObjectFunctor(new LMNtal$class(m)));\n";
	print "\tmem.relink(o, 0, me, 1);\n";
	print "\tmem.relink(me.nthAtom(0), 0, me.nthAtom(0), 0);\n";
	print "\tme.remove();\n";
	print "	:]({\$p,\@p}).\n";
	print "}.\n";
	
	close(STDOUT);
}

# react 部を出力する
sub dump_react {
	print "\t\tmem.lock();\n";
	print "\t\tboolean updated = true;\n";
	print "\t\twhile (updated) {\n";
	print "\t\t\tupdated = false;\n";
	print "\t\t\tfor (Iterator iter = mem.rulesetIterator(); iter.hasNext();) {\n";
	print "\t\t\t\tRuleset ruleset = (Ruleset)iter.next();\n";
	print "\t\t\t\twhile (ruleset.react(mem)) updated = true;\n";
	print "\t\t\t}\n";
	print "\t\t}\n";
	print "\t\tmem.unlock();\n";
}

# 引数アトムを生成する部分の出力
sub dump_argatom {
	my ($type, $i) = @_;
	
	if (exists($functors{$type})) {
		$functor = "$functors{$type}(v$i)";
	} elsif ($type eq "boolean") {
		$functor = "SymbolFunctor(v$i?\"true\":\"false\", 1)";
	} else {
		$functor = "ObjectFunctor(v$i)";
	}
	print "\t\tAtom a$i = mem.newAtom(new $functor);\n";
	print "\t\tmem.newLink(a, $i, a$i, 0);\n";	
}

sub dump_args {
	my (@args) = @_;
	my $args;
	for (my $i = 0; $i <= $#args; $i++) {
		$args .= "$args[$i] v$i,";
	}
	chop($args);
	return $args;
}

sub dump_method {
	my ($type, $method, $args) = @_;
	my @args = split(/\s*,\s*/, $args);
	my $argc = $#args+1;
	my $i;
	
	print "\tpublic $type $method(" . dump_args(@args) . ") {\n";
	
	$arity = ($type eq "void" ? $argc : $argc+1);
	print "\t\tAtom a = mem.newAtom(new SymbolFunctor(\"$method\", $arity));\n";

	for ($i = 0; $i < $argc; $i++) {
		dump_argatom($args[$i], $i);
	}
	
	if ($type ne "void") {
		print "\t\tAtom res = mem.newAtom(new SymbolFunctor(\"res\", 1));\n";
		print "\t\tmem.newLink(a, $argc, res, 0);\n";	
	}
	
	dump_react();
	
	if ($type eq "void") {
		print "\t}\n";
		return;
	}
	
	print "\n";
	if ($type eq "boolean") {
		print "\t\treturn (res.nthAtom(0).getName().equals(\"true\") ? true : false);\n";
	} elsif (exists($functors{$type})) {
		$functor = $functors{$type};
		print "\t\treturn (($functor)res.nthAtom(0).getFunctor()).$getmethods{$functor};\n";
	} else {
		print "\t\treturn ($type)res.nthAtom(0).getFunctor().getValue();\n";
	}
	
	print "\t}\n";
}
