#!/usr/bin/perl
#
###############################################################
#
# javap -public の出力から LMNtal モジュールを自動生成します
#
# 使用例
# $ javap -public java.lang.Math | ./make_module.pl > math.lmn
#
# History
#
# 2006/06/29(Thu)
# 	アンダーバーで始まるメソッド名に対応した
# 	$ が含まれるクラス名に対応した
# 	例外が発生した場合 Exception オブジェクトを返すようにした
# 2006/07/05(Wed)
#   クラス名は大文字にした
###############################################################

# java の型 => Functor
%functors = (
	"int"				=> "IntegerFunctor",
	"long"				=> "IntegerFunctor",
	"float"				=> "FloatingFunctor",
	"double"			=> "FloatingFunctor",
	"boolean"			=> "SymbolFunctor",
	"java.lang.String"	=> "StringFunctor",
);

# java 変数の型 => その変数を取得するファンクタのメソッド
%getmethods = (
	"int"				=> "intValue()",
	"long"				=> "intValue()",
	"float"				=> "floatValue()",
	"double"			=> "floatValue()",
	"boolean"			=> "getName().equals(\"false\")?false:true",
	"java.lang.String"	=> "stringValue()",
);

# java の型 => ガード制約
%guards = (
	"int"				=> "int",
	"long"				=> "int",
	"float"				=> "float",
	"double"			=> "float",
#	"boolean"			=> "boolean",
	"java.lang.String"	=> "string",
);

# java の戻り値型 => 結果を返すアトム用の Functor
%result_functors = (
	"int"				=> "IntegerFunctor(r)",
	"long"				=> "IntegerFunctor((int)r)",
	"float"				=> "FloatingFunctor(r)",
	"double"			=> "FloatingFunctor(r)",
	"boolean"			=> "SymbolFunctor(r?\"true\":\"false\", 1)",
	"void"				=> "SymbolFunctor(\"done\", 1)",
	"java.lang.String"	=> "StringFunctor(r)",
);

# メイン
$time = localtime(time);# いったん変数にとらないとうまく表示されない
print "//----------------------------------------------------\n";
print "// The following code was generated by make_module.pl\n";
print "// ", $time, "\n";
print "//----------------------------------------------------\n";
while (<>) {
	# コンストラクタ，static メソッド，インスタンスメソッドの 3 種類がある

	if (/(abstract )?class ([\w.]+)\.(\w+)/) {
		$abstract = $1; # 抽象クラスの場合 undef 以外の値が入る
		$class = $3;
		$absolute_class = "$2.$3";
		$module = $absolute_class; # パッケージ名をとりたいときは $class にする
		$module =~ tr/./_/;
		print "{module($module).\n";
	} elsif (/compareTo\(java\.lang\.Object\)/) {
		# Comparable インタフェースのメソッドは無視
	} elsif (/char|byte|short|float/) {
		#とりあえず無視
	} elsif (/public [\w.\$]+\((\S*)\)/ && $abstract eq "") {# 抽象クラスはコンストラクタなし
		dump_constructor(split_args($1));
	} elsif (/public static (?:synchronized )?(\S+) (\S+)\((.*)\)/) {
		# 戻り値がlongのときは除外
		if (!($3 =~ /\[\]/) && $1 ne "long") { #TODO Javaの配列をLMNtalのリストで処理
			dump_static_method(trim_class($1), $2, split_args($3));
		}
	} elsif (/public (?:synchronized )?(\S+) (\S+)\((.*)\)/) {
		# 戻り値がlongのときは除外
		if (!($3 =~ /\[\]/) && $1 ne "long") { #TODO Javaの配列をLMNtalのリストで処理
			dump_method(trim_class($1), $2, split_args($3));
		}
	}
}
print "}.\n";

# 引数を配列に展開する
sub split_args {
	my ($args) = @_;
	my @args = split(/\s*,\s*/, trim_class($args));
	return @args;
}

# クラス名を正しく整形する
sub trim_class {
	my ($class) = @_;
	$class =~ s/\$/\./g;
	return $class;
}

# ガードを出力する
sub dump_guards {
	@args = @_;
	my $guards = "";
	for ($i = 0; $i <= $#args; $i++) {
		$arg = $args[$i];
		if ($arg eq "boolean") {
			next;
		}
		if (exists($guards{$arg})) {
			$guards .= "$guards{$arg}(Arg$i),";
		} else {
			$guards .= "class(Arg$i, \"$arg\"),";
		}
	}
	chop($guards); #最後のカンマを除去
	return $guards;
}

# ヘッド部分を出力する
sub dump_head {
	my ($args, $method, @args) = @_;
	print "H=$module.$method($args) :- ";
	my $guards = dump_guards(@args);
	if ($guards ne "") {
		print "$guards | ";
	}
	print "H=[:/*inline*/\n";
}

# コンストラクタを出力する
sub dump_constructor {
	@args = @_;
	$argc = $#args+1;

	$ARGS=make_lmntal_args($argc);
	dump_head($ARGS, "new", @args);

	$args = dump_args(0, @args);
	print "\ttry {\n";
	print "\t\tAtom o = mem.newAtom(new ObjectFunctor(new $absolute_class($args)));\n";
	print "\t\tmem.relink(o, 0, me, $argc);\n";
	print "\t} catch (Exception e) { System.err.println(e); }\n";

	for ($i = 0; $i < $argc; $i++) {
		print "\tme.nthAtom($i).remove();\n";
	}
	print "\tme.remove();\n";
	print "\t:]($ARGS).\n";
	print "\n";
}

# java のメソッド名から LMNtal 用のメソッド名を生成する
sub lmnmethod {
	my ($method) = @_;
	$method =~ s/^_//; # 先頭の _ を削除
	return lcfirst($method); # 先頭を小文字にして返す
}

# メソッドを出力する
sub dump_method {
	my ($type, $method, @args) = @_;
	$argc = $#args+1;

	$ARGS = make_lmntal_args($argc+1);

	dump_head("${ARGS}", lmnmethod($method), ($absolute_class,@args));

#	print "class($class, \"$absolute_class\") | H=[:/*inline*/\n";
	print "\t$absolute_class o = ($absolute_class) ((ObjectFunctor)me.nthAtom(0).getFunctor()).getObject();\n";
	
	$args = dump_args(1, @args);

	printf "\tmem.relink(me.nthAtom(0), 0, me, %d);\n", $argc+1;
	printf "\tAtom result = null;\n";
	printf "\ttry {\n";
	if ($type eq "void") {
		printf "\t\to.$method($args);\n";
	} else {
		printf "\t\t$type r = o.$method($args);\n";
	}
	printf "\t\t%s", dump_result_atom($type);
	printf "\t} catch (Exception e) {\n";
	printf "\t\tresult = mem.newAtom(new ObjectFunctor(e));\n";
	printf "\t} finally {\n";
	printf "\t\tmem.relink(result, 0, me, %d);\n", $argc+1;
	printf "\t}\n";

	dump_tail($argc+1, "${ARGS}");
}

# static メソッドを出力する
sub dump_static_method {
	($type, $method, @args) = @_;
	$argc = $#args+1;

	$ARGS = make_lmntal_args($argc);

	dump_head(${ARGS}, lmnmethod($method), @args);

	$args = dump_args(0, @args);
	
	print "\tAtom result = null;\n";
	print "\ttry {\n";
	if ($type eq "void") {
		print "\t\t$absolute_class.$method($args);\n";
	} else {
		print "\t\t$type r = $absolute_class.$method($args);\n";
	}
	printf "\t\t%s", dump_result_atom($type);
	print "\t} catch (Exception e) {\n";
	print "\t\tresult = mem.newAtom(new ObjectFunctor(e));\n";
	print "\t} finally {\n";
	print "\t\tmem.relink(result, 0, me, $argc);\n";
	print "\t}\n";

	dump_tail($argc, $ARGS);
}

# 最後の出力
sub dump_tail {
	my ($argc, $args) = @_;
	for ($i = $argc-1; $i >= 0; $i--) {
		print "\tme.nthAtom($i).remove();\n";
	}
	print "\tme.remove();\n";
	print "\t:]($args).\n";
	print "\n";
}

# LMNtal の引数の文字列を生成する
sub make_lmntal_args {
	my ($argc) = @_;
	my $args = "";
	for ($i = 0; $i < $argc; $i++) {
		$args .= "Arg$i,";
	}
	chop($args); #最後のカンマを除去
	return $args;
}

# 引数を取得する処理の出力
sub dump_args {
	my ($start, @args) = @_;
	my $argc = $#args;
	my $args = "";
	for ($i = 0; $i <= $argc; $i++) {
		my $type = $args[$i];
		$type =~ s/\s//;
		$args .= "v$i,";
		if (exists($functors{$type})) {
			$functor = $functors{$type};
			$cast = "";
			$getmethod = $getmethods{$type};
		} else {
			$functor = "ObjectFunctor";
			$cast = "($type) ";
			$getmethod = "getValue()";
		}
		printf "\t$type v$i = $cast(($functor)me.nthAtom(%d).getFunctor()).$getmethod;\n", $i+$start;
	}
	chop($args); #最後のカンマを除去
	return $args;
}

# 結果を返すアトムを生成する処理の出力
sub dump_result_atom {
	my ($type) = @_;

	if (exists($result_functors{$type})) {
		$functor = $result_functors{$type};
	} else {
		$functor = "ObjectFunctor(r)";
	}
	return "result = mem.newAtom(new $functor);\n";
}
